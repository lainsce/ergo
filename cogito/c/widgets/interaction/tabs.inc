static int cogito_tabs_hit_index(CogitoNode* n, int x, int y) {
  if (!n || n->kind != COGITO_TABS) return -1;
  if (!cogito_hit_node(n, x, y)) return -1;
  int size = cogito_node_font_size(n);
  int th = cogito_text_height_size(size);
  int pad_x = 12;
  int pad_y = 8;
  int gap = 6;
  int tab_h = th + pad_y * 2;
  int ty = n->y + (n->h - tab_h) / 2;
  if (y < ty || y > ty + tab_h) return -1;
  int cx = n->x + n->padding_left;
  for (size_t i = 0; i < n->tab_len; i++) {
    const char* t = n->tab_labels[i] ? n->tab_labels[i]->data : "";
    int tw = cogito_text_width_size(t, size);
    int tab_w = tw + pad_x * 2;
    if (x >= cx && x <= cx + tab_w) return (int)i;
    cx += tab_w + gap;
  }
  return -1;
}
static CogitoNode* cogito_tabs_new_obj(void) {
  CogitoNode* t = cogito_node_new(COGITO_TABS);
  t->selected = 0;
  return t;
}
static ErgoVal cogito_tabs_new(void) {
  return EV_OBJ(cogito_tabs_new_obj());
}
static void cogito_tabs_set_items(ErgoVal tabsv, ErgoVal arrv) {
  if (tabsv.tag != EVT_OBJ) ergo_trap("cogito.tabs_set_items expects tabs");
  if (arrv.tag != EVT_ARR) ergo_trap("cogito.tabs_set_items expects array");
  CogitoNode* n = (CogitoNode*)tabsv.as.p;
  if (n->tab_labels) {
    for (size_t i = 0; i < n->tab_len; i++) {
      if (n->tab_labels[i]) ergo_release_val(EV_STR(n->tab_labels[i]));
    }
    free(n->tab_labels);
    n->tab_labels = NULL;
  }
  if (n->tab_ids) {
    for (size_t i = 0; i < n->tab_len; i++) {
      if (n->tab_ids[i]) ergo_release_val(EV_STR(n->tab_ids[i]));
    }
    free(n->tab_ids);
    n->tab_ids = NULL;
  }
  n->tab_len = 0;
  n->tab_cap = 0;
  ErgoArr* a = (ErgoArr*)arrv.as.p;
  if (!a || a->len == 0) { n->selected = -1; return; }
  n->tab_labels = (ErgoStr**)malloc(sizeof(ErgoStr*) * (size_t)a->len);
  n->tab_len = (size_t)a->len;
  n->tab_cap = n->tab_len;
  for (size_t i = 0; i < n->tab_len; i++) {
    ErgoVal v = ergo_arr_get(a, (int64_t)i);
    ErgoStr* s = stdr_to_string(v);
    n->tab_labels[i] = s;
    if (s) ergo_retain_val(EV_STR(s));
  }
  if (n->selected < 0 && n->tab_len > 0) n->selected = 0;
  if (n->view_switcher && n->tab_ids && n->selected >= 0 && (size_t)n->selected < n->tab_len) {
    CogitoNode* vs = n->view_switcher;
    ErgoStr* id = n->tab_ids[n->selected];
    if (id) {
      if (vs->view_active_id) ergo_release_val(EV_STR(vs->view_active_id));
      vs->view_active_id = id;
      ergo_retain_val(EV_STR(vs->view_active_id));
    }
  }
  cogito_window_relayout(cogito_node_window(n));
}
static void cogito_tabs_set_ids(ErgoVal tabsv, ErgoVal arrv) {
  if (tabsv.tag != EVT_OBJ) ergo_trap("cogito.tabs_set_ids expects tabs");
  if (arrv.tag != EVT_ARR) ergo_trap("cogito.tabs_set_ids expects array");
  CogitoNode* n = (CogitoNode*)tabsv.as.p;
  if (n->tab_ids) {
    for (size_t i = 0; i < n->tab_len; i++) {
      if (n->tab_ids[i]) ergo_release_val(EV_STR(n->tab_ids[i]));
    }
    free(n->tab_ids);
    n->tab_ids = NULL;
  }
  ErgoArr* a = (ErgoArr*)arrv.as.p;
  size_t len = a ? (size_t)a->len : 0;
  if (n->tab_len == 0) {
    n->tab_len = len;
    n->tab_cap = len;
    if (!n->tab_labels && len > 0) {
      n->tab_labels = (ErgoStr**)calloc(len, sizeof(ErgoStr*));
    }
  }
  if (n->tab_len == 0) return;
  n->tab_ids = (ErgoStr**)calloc(n->tab_len, sizeof(ErgoStr*));
  for (size_t i = 0; i < n->tab_len; i++) {
    if (i < len) {
      ErgoVal v = ergo_arr_get(a, (int64_t)i);
      ErgoStr* s = stdr_to_string(v);
      n->tab_ids[i] = s;
      if (s) ergo_retain_val(EV_STR(s));
    }
  }
  if (n->view_switcher && n->selected >= 0 && (size_t)n->selected < n->tab_len) {
    CogitoNode* vs = n->view_switcher;
    ErgoStr* id = n->tab_ids[n->selected];
    if (id) {
      if (vs->view_active_id) ergo_release_val(EV_STR(vs->view_active_id));
      vs->view_active_id = id;
      ergo_retain_val(EV_STR(vs->view_active_id));
    }
  }
  cogito_window_relayout(cogito_node_window(n));
}
static void cogito_tabs_set_selected(ErgoVal tabsv, ErgoVal idxv) {
  if (tabsv.tag != EVT_OBJ) ergo_trap("cogito.tabs_set_selected expects tabs");
  CogitoNode* n = (CogitoNode*)tabsv.as.p;
  int idx = (int)ergo_as_int(idxv);
  if (idx < 0) idx = -1;
  if (n->tab_len > 0 && idx >= (int)n->tab_len) idx = (int)n->tab_len - 1;
  n->selected = idx;
  if (n->view_switcher && n->tab_ids && idx >= 0 && (size_t)idx < n->tab_len) {
    CogitoNode* vs = n->view_switcher;
    ErgoStr* id = n->tab_ids[idx];
    if (id) {
      if (vs->view_active_id) ergo_release_val(EV_STR(vs->view_active_id));
      vs->view_active_id = id;
      ergo_retain_val(EV_STR(vs->view_active_id));
    }
  }
  cogito_window_relayout(cogito_node_window(n));
}
static ErgoVal cogito_tabs_get_selected(ErgoVal tabsv) {
  if (tabsv.tag != EVT_OBJ) ergo_trap("cogito.tabs_get_selected expects tabs");
  CogitoNode* n = (CogitoNode*)tabsv.as.p;
  return EV_INT(n->selected);
}
static void cogito_tabs_on_change(ErgoVal tabsv, ErgoVal handler) {
  if (tabsv.tag != EVT_OBJ) ergo_trap("cogito.tabs_on_change expects tabs");
  if (handler.tag != EVT_FN) ergo_trap("cogito.tabs_on_change expects function");
  CogitoNode* n = (CogitoNode*)tabsv.as.p;
  if (n->on_change) ergo_release_val(EV_FN(n->on_change));
  n->on_change = (ErgoFn*)handler.as.p;
  ergo_retain_val(EV_FN(n->on_change));
}
static void cogito_tabs_bind(ErgoVal tabsv, ErgoVal vsv) {
  if (tabsv.tag != EVT_OBJ) ergo_trap("cogito.tabs_bind expects tabs");
  if (vsv.tag != EVT_OBJ) ergo_trap("cogito.tabs_bind expects view_switcher");
  CogitoNode* t = (CogitoNode*)tabsv.as.p;
  CogitoNode* vs = (CogitoNode*)vsv.as.p;
  if (vs->kind != COGITO_VIEWSWITCHER) ergo_trap("cogito.tabs_bind expects view_switcher");
  t->view_switcher = vs;
  if (t->tab_ids && t->selected >= 0 && (size_t)t->selected < t->tab_len) {
    ErgoStr* id = t->tab_ids[t->selected];
    if (id) {
      if (vs->view_active_id) ergo_release_val(EV_STR(vs->view_active_id));
      vs->view_active_id = id;
      ergo_retain_val(EV_STR(vs->view_active_id));
    }
  }
}
