cask gui_gallery

bring stdr
bring cogito

def app = cogito.app()

fun build_page(title = string, blurb = string) (( cogito.VStack )) {
    let vstack = cogito.vstack()
    .set_vexpand(true)
    .set_hexpand(true)
    .set_gap(12)
    .set_padding(0, 18, 0, 18)

    let info = cogito.label(blurb)
    .set_class(@"body")
    .set_wrap(true)
    vstack.add(info)

    return vstack
}

fun build_button_page() (( cogito.VStack )) {
    let vstack = build_page(@"Button", @"Buttons trigger immediate actions. This page showcases all button variants, sizes, and states.")

    let status = cogito.label(@"Tap a button to update this status.")
    .set_class(@"body")
    .set_wrap(true)
    vstack.add(status)

    -- Section: Button Styles
    let styles_label = cogito.label(@"Styles")
    .set_class(@"heading")
    vstack.add(styles_label)

    let styles_row = cogito.hstack()
    .set_gap(12)
    .set_hexpand(true)

    let filled = cogito.button(@"Filled")
    .on_click((b = cogito.Button) => {
        status.set_text(@"Filled button clicked.")
    })
    styles_row.add(filled)

    let outlined = cogito.button(@"Outlined")
    .set_class(@"outlined") 
    .on_click((b = cogito.Button) => {
        status.set_text(@"Outlined button clicked.")
    })
    styles_row.add(outlined)

    let text_btn = cogito.button(@"Text")
    .set_class(@"text")
    .on_click((b = cogito.Button) => {
        status.set_text(@"Text button clicked.")
    })
    styles_row.add(text_btn)

    vstack.add(styles_row)

    -- Section: Button Sizes
    let sizes_label = cogito.label(@"Sizes")
    .set_class(@"heading")
    vstack.add(sizes_label)

    let sizes_row = cogito.hstack()
    .set_gap(12)
    .set_hexpand(true)

    let xs_btn = cogito.button(@"XS")
    .set_size(0)
    .on_click((b = cogito.Button) => {
        status.set_text(@"XS button clicked.")
    })
    sizes_row.add(xs_btn)

    let s_btn = cogito.button(@"S")
    .set_size(1)
    .on_click((b = cogito.Button) => {
        status.set_text(@"S button clicked.")
    })
    sizes_row.add(s_btn)

    let m_btn = cogito.button(@"M")
    .set_size(2)
    .on_click((b = cogito.Button) => {
        status.set_text(@"M button clicked.")
    })
    sizes_row.add(m_btn)

    let l_btn = cogito.button(@"L")
    .set_size(3)
    .on_click((b = cogito.Button) => {
        status.set_text(@"L button clicked.")
    })
    sizes_row.add(l_btn)

    let xl_btn = cogito.button(@"XL")
    .set_size(4)
    .on_click((b = cogito.Button) => {
        status.set_text(@"XL button clicked.")
    })
    sizes_row.add(xl_btn)

    vstack.add(sizes_row)

    -- Section: Disabled States
    let disabled_label = cogito.label(@"Disabled States")
    .set_class(@"heading")
    vstack.add(disabled_label)

    let disabled_row = cogito.hstack()
    .set_gap(12)
    .set_hexpand(true)

    let disabled_filled = cogito.button(@"Filled")
    .set_disabled(true)
    disabled_row.add(disabled_filled)

    let disabled_outlined = cogito.button(@"Outlined")
    .set_class(@"outlined")
    .set_disabled(true)
    disabled_row.add(disabled_outlined)

    let disabled_text = cogito.button(@"Text")
    .set_class(@"text")
    .set_disabled(true)
    disabled_row.add(disabled_text)

    vstack.add(disabled_row)

    return vstack
}

fun make_iconbtn_row(label_text = string, icon = string, color_style = num, shape = num) (( cogito.HStack )) {
    let row = cogito.hstack()
    .set_hexpand(true)
    .set_gap(12)
    .set_padding(18, 0, 18, 0)

    let lbl = cogito.label(label_text)
    .set_class(@"body")
    .set_hexpand(true)
    row.add(lbl)

    -- XS
    let xs = cogito.iconbtn(icon)
    .set_xs()
    .set_color_style(color_style)
    .set_shape(shape)
    row.add(xs)

    -- S (default)
    let s = cogito.iconbtn(icon)
    .set_s()
    .set_color_style(color_style)
    .set_shape(shape)
    row.add(s)

    -- M
    let m = cogito.iconbtn(icon)
    .set_color_style(color_style)
    .set_shape(shape)
    row.add(m)

    -- L
    let l = cogito.iconbtn(icon)
    .set_color_style(color_style)
    .set_shape(shape)
    .set_l()
    row.add(l)

    -- XL
    let xl = cogito.iconbtn(icon)
    .set_color_style(color_style)
    .set_shape(shape)
    .set_xl()
    row.add(xl)
    return row
}

fun build_iconbtn_page() (( cogito.VStack )) {
    let vstack = build_page(@"Icon Button", @"Icon buttons come in 4 color styles (Filled, Tonal, Outlined, Iconic), 2 shapes (Circle, Rounded Square), and 3 widths (Narrow, Default, Wide).")

    let status = cogito.label(@"Tap an icon button.")
    .set_class(@"body")
    vstack.add(status)

    -- Section: Color Styles (circle shape, default width)
    let sec1 = cogito.label(@"Color Styles")
    .set_class(@"heading")
    vstack.add(sec1)

    -- Filled row
    let filled_row = make_iconbtn_row(@"Filled", @"sf:pencil", 0, 0)
    vstack.add(filled_row)

    -- Tonal row
    let tonal_row = make_iconbtn_row(@"Tonal", @"sf:pencil", 1, 0)
    vstack.add(tonal_row)

    -- Outlined row
    let outlined_row = make_iconbtn_row(@"Outlined", @"sf:pencil", 2, 0)
    vstack.add(outlined_row)

    -- Iconic row
    let iconic_row = make_iconbtn_row(@"Iconic", @"sf:pencil", 3, 0)
    vstack.add(iconic_row)

    -- Section: Shapes
    let sec2 = cogito.label(@"Shapes")
    .set_class(@"heading")
    vstack.add(sec2)

    let shape_row = cogito.hstack()
    .set_gap(12)

    let circle_lbl = cogito.label(@"Circle")
    .set_class(@"body")
    shape_row.add(circle_lbl)

    let circle_btn = cogito.iconbtn(@"sf:star.fill")
    .set_color_style(0)
    .set_shape(0)
    shape_row.add(circle_btn)

    let sq_lbl = cogito.label(@"Rounded Square")
    .set_class(@"body")
    shape_row.add(sq_lbl)

    let sq_btn = cogito.iconbtn(@"sf:star.fill")
    .set_color_style(0)
    .set_shape(1)
    shape_row.add(sq_btn)

    vstack.add(shape_row)

    -- Section: Widths
    let sec3 = cogito.label(@"Widths")
    .set_class(@"heading")
    vstack.add(sec3)

    let width_row = cogito.hstack()
    .set_gap(12)

    let narrow_lbl = cogito.label(@"Narrow")
    .set_class(@"body")
    width_row.add(narrow_lbl)

    let narrow_btn = cogito.iconbtn(@"sf:pencil")
    .set_color_style(1)
    .set_width(0)
    width_row.add(narrow_btn)

    let default_lbl = cogito.label(@"Default")
    .set_class(@"body")
    width_row.add(default_lbl)

    let default_btn = cogito.iconbtn(@"sf:pencil")
    .set_color_style(1)
    .set_width(1)
    width_row.add(default_btn)

    let wide_lbl = cogito.label(@"Wide")
    .set_class(@"body")
    width_row.add(wide_lbl)

    let wide_btn = cogito.iconbtn(@"sf:pencil")
    .set_color_style(1)
    .set_width(2)
    width_row.add(wide_btn)

    vstack.add(width_row)

    -- Section: Toggle
    let sec4 = cogito.label(@"Toggle")
    .set_class(@"heading")
    vstack.add(sec4)

    let toggle_row = cogito.hstack()
    .set_gap(12)

    let toggle_btn = cogito.iconbtn(@"sf:heart")
    .set_color_style(0)
    .set_shape(0)
    .set_toggle(true)
    .on_click((b = cogito.IconButton) => {
        let state = if b.checked() { @"on" } else { @"off" }
        status.set_text(@"Toggle: $state")
    })
    toggle_row.add(toggle_btn)

    let toggle_tonal = cogito.iconbtn(@"sf:bookmark")
    .set_color_style(1)
    .set_toggle(true)
    .on_click((b = cogito.IconButton) => {
        let state = if b.checked() { @"bookmarked" } else { @"not bookmarked" }
        status.set_text(@"Bookmark: $state")
    })
    toggle_row.add(toggle_tonal)

    vstack.add(toggle_row)

    return vstack
}

fun build_textfield_page() (( cogito.VStack )) {
    let vstack = build_page(@"TextField", @"TextField is a single-line editable input for concise text entry.")

    let status = cogito.label(@"Current value: Text field")
    .set_class(@"body")
    vstack.add(status)

    let tf = cogito.textfield(@"Text field")
    .set_hexpand(true)
    tf.on_change((field = cogito.TextField) => {
        status.set_text(@"Current value: $field.text()")
    })
    vstack.add(tf)

    return vstack
}

fun build_searchfield_page() (( cogito.VStack )) {
    let vstack = build_page(@"SearchField", @"SearchField is optimized for query text with search-focused styling and behavior.")

    let status = cogito.label(@"Query: ")
    .set_class(@"body")
    vstack.add(status)

    let sf = cogito.searchfield(@"Search…")
    .set_hexpand(true)
    sf.on_change((field = cogito.SearchField) => {
        status.set_text(@"Query: $field.text()")
    })
    vstack.add(sf)

    return vstack
}

fun build_textview_page() (( cogito.VStack )) {
    let vstack = build_page(@"TextView", @"TextView is a multi-line editable area suitable for notes and longer text.")

    let status = cogito.label(@"Edit the text view to trigger change notifications.")
    .set_class(@"body")
    .set_wrap(true)
    vstack.add(status)

    let tv = cogito.textview(@"Multi-line text view")
    .set_hexpand(true)
    tv.on_change((field = cogito.TextView) => {
        status.set_text(@"TextView changed.")
    })
    vstack.add(tv)

    return vstack
}

fun build_checkbox_page() (( cogito.VStack )) {
    let vstack = build_page(@"Checkbox", @"Checkboxes capture independent yes/no selections.")

    let status = cogito.label(@"Toggle a checkbox.")
    .set_class(@"body")
    vstack.add(status)

    let cb1 = cogito.checkbox(@"Enable notifications", null)
    cb1.on_change((c = cogito.Checkbox) => {
        status.set_text(@"Enable notifications: $c.checked()")
    })
    vstack.add(cb1)

    let cb2 = cogito.checkbox(@"Sync in background", null)
    cb2.on_change((c = cogito.Checkbox) => {
        status.set_text(@"Sync in background: $c.checked()")
    })
    vstack.add(cb2)

    return vstack
}

fun build_switch_page() (( cogito.VStack )) {
    let vstack = build_page(@"Switch", @"Switches represent immediate on/off state and are ideal for settings toggles.")

    let status = cogito.label(@"Switch is off.")
    .set_class(@"body")
    vstack.add(status)

    let sw = cogito.switch(@"Airplane Mode")
    .on_change((s = cogito.Switch) => {
        let on = if s.checked() { @"on" } else { @"off" }
        status.set_text(@"Switch is $on.")
    })
    vstack.add(sw)

    return vstack
}

fun build_slider_page() (( cogito.VStack )) {
    let vstack = build_page(@"Slider", @"Sliders let users choose a value along a continuous range.")

    let status = cogito.label(@"Value: 50")
    .set_class(@"body")
    vstack.add(status)

    let sl = cogito.slider(0, 100, 50)
    .set_hexpand(true)
    sl.on_change((s = cogito.Slider) => {
        status.set_text(@"Value: $s.value()")
    })
    vstack.add(sl)

    return vstack
}

fun build_stepper_page() (( cogito.VStack )) {
    let vstack = build_page(@"Stepper", @"Steppers provide precise incremental adjustments using +/- controls.")

    let info = cogito.label(@"Use the steppers buttons to increment or decrement.")
    .set_class(@"body")
    vstack.add(info)

    let step = cogito.stepper(0, 100, 5, 1)
    vstack.add(step)

    return vstack
}

fun build_datepicker_page() (( cogito.VStack )) {
    let vstack = build_page(@"DatePicker", @"DatePicker allows users to choose calendar dates in a structured UI.")

    let status = cogito.label(@"Pick a date.")
    .set_class(@"body")
    vstack.add(status)

    let dp = cogito.datepicker()
    dp.on_change((d = cogito.DatePicker) => {
        status.set_text(@"Date selection changed.")
    })
    vstack.add(dp)

    return vstack
}

fun build_colorpicker_page() (( cogito.VStack )) {
    let vstack = build_page(@"ColorPicker", @"ColorPicker exposes channels and previews for selecting colors.")

    let status = cogito.label(@"Pick a color.")
    .set_class(@"body")
    vstack.add(status)

    let cp = cogito.colorpicker()
    .on_change((c = cogito.ColorPicker) => {
        status.set_text(@"Color selection changed.")
    })
    vstack.add(cp)

    return vstack
}

fun build_timepicker_page() (( cogito.VStack )) {
    let vstack = build_page(@"TimePicker", @"TimePicker is used for selecting hour/minute values.")

    let status = cogito.label(@"Selected: --:--")
    .set_class(@"body")
    vstack.add(status)

    let tp = cogito.timepicker()
    .on_change((picker = cogito.TimePicker) => {
        status.set_text(@"Selected: $picker.hour():$picker.minute()")
    })
    vstack.add(tp)

    return vstack
}

fun build_dropdown_page() (( cogito.VStack )) {
    let vstack = build_page(@"Dropdown", @"Dropdown presents a compact list of mutually exclusive options.")

    let status = cogito.label(@"Selected index: 0")
    .set_class(@"body")
    vstack.add(status)

    let dd = cogito.dropdown()
    .set_items([@"Low", @"Medium", @"High"])
    .set_selected(0)
    dd.on_change((d = cogito.Dropdown) => {
        status.set_text(@"Selected index: $d.selected()")
    })
    vstack.add(dd)

    return vstack
}

fun build_progress_page() (( cogito.VStack )) {
    let vstack = build_page(@"Progress", @"Progress indicators communicate task completion and indeterminate loading states.")

    let linear = cogito.progress(0.72)
    .set_hexpand(true)
    vstack.add(linear)

    let ind = cogito.progress(0.0)
    .set_hexpand(true)
    .set_indeterminate(true)
    vstack.add(ind)

    let circular = cogito.progress(0.65)
    .set_circular(true)
    vstack.add(circular)

    return vstack
}

fun build_list_page() (( cogito.VStack )) {
    let vstack = build_page(@"List", @"Lists present vertical collections and expose selection/activation callbacks.")

    let status = cogito.label(@"Select a row.")
    .set_class(@"body")
    vstack.add(status)

    let list = cogito.list()
    .set_hexpand(true)
    .add(cogito.label(@"Inbox"))
    .add(cogito.label(@"Archive"))
    .add(cogito.label(@"Trash"))
    .on_select((idx) => {
        status.set_text(@"Selected row: $idx")
    })
    .on_activate((idx) => {
        status.set_text(@"Activated row: $idx")
    })
    vstack.add(list)

    return vstack
}

fun build_grid_page() (( cogito.VStack )) {
    let vstack = build_page(@"Grid", @"Grid arranges content in rows and columns with consistent gaps.")

    let status = cogito.label(@"Select a cell.")
    .set_class(@"body")
    vstack.add(status)

    let grid = cogito.grid(3)
    .set_hexpand(true)
    .set_gap(8, 8)
    .add(cogito.label(@"A1"))
    .add(cogito.label(@"A2"))
    .add(cogito.label(@"A3"))
    .add(cogito.label(@"B1"))
    .add(cogito.label(@"B2"))
    .add(cogito.label(@"B3"))
    .on_select((idx) => {
        status.set_text(@"Selected cell: $idx")
    })
    vstack.add(grid)

    return vstack
}

fun build_tabs_page() (( cogito.VStack )) {
    let vstack = build_page(@"Tabs", @"Tabs switch between multiple related content panels while preserving context.")

    let status = cogito.label(@"Selected tab index: 0")
    .set_class(@"body")
    vstack.add(status)

    let tabs = cogito.tabs()
    .set_items([@"Overview", @"Details", @"History", @"Misc"])
    .set_ids([@"overview", @"details", @"history", @"misc"])
    .set_selected(0)
    .set_hexpand(true)
    .on_change((idx) => {
        status.set_text(@"Selected tab index: $idx")
    })
    vstack.add(tabs)

    let tab_views = cogito.view_switcher()
    .set_hexpand(true)
    .add(@"overview", (vs = cogito.ViewSwitcher) => cogito.label(@"Overview content"))
    .add(@"details", (vs = cogito.ViewSwitcher) => cogito.label(@"Details content"))
    .add(@"history", (vs = cogito.ViewSwitcher) => cogito.label(@"History content"))
    .add(@"misc", (vs = cogito.ViewSwitcher) => cogito.label(@"Misc content"))
    .set_active(@"overview")
    tabs.bind(tab_views)
    vstack.add(tab_views)

    return vstack
}

fun build_buttongroup_page() (( cogito.VStack )) {
    let vstack = build_page(@"ButtonGroup Control", @"ButtonGroup controls expose a compact set of mutually exclusive options.")

    let status = cogito.label(@"Select a time range.")
    .set_class(@"body")
    vstack.add(status)

    -- Section: Default ButtonGroup
    let default_label = cogito.label(@"Default")
    .set_class(@"heading")
    vstack.add(default_label)

    let seg = cogito.buttongroup()
    .add(cogito.button(@"Day"))
    .add(cogito.button(@"Week"))
    .add(cogito.button(@"Month"))
    .add(cogito.button(@"Year"))
    .on_select((idx) => {
        let opt = if idx == 0 { @"Day" } elif idx == 1 { @"Week" } elif idx == 2 { @"Month" } else { @"Year" }
        status.set_text(@"Selected: $opt")
    })
    vstack.add(seg)

    -- Section: Sizes
    let sizes_label = cogito.label(@"Sizes")
    .set_class(@"heading")
    vstack.add(sizes_label)

    let sizes_info = cogito.label(@"ButtonGroup supports 5 sizes: XS(0), S(1), M(2), L(3), XL(4)")
    .set_class(@"body")
    .set_wrap(true)
    vstack.add(sizes_info)

    let sizes_row = cogito.hstack()
    .set_gap(12)
    .set_hexpand(true)

    let xs_bg = cogito.buttongroup()
    .add(cogito.button(@"XS"))
    .set_size(0)
    .on_select((idx) => {
        status.set_text(@"XS size selected, index: $idx")
    })
    sizes_row.add(xs_bg)

    let s_bg = cogito.buttongroup()
    .add(cogito.button(@"S"))
    .set_size(1)
    .on_select((idx) => {
        status.set_text(@"S size selected, index: $idx")
    })
    sizes_row.add(s_bg)

    let m_bg = cogito.buttongroup()
    .add(cogito.button(@"M"))
    .set_size(2)
    .on_select((idx) => {
        status.set_text(@"M size selected, index: $idx")
    })
    sizes_row.add(m_bg)

    vstack.add(sizes_row)

    -- Section: Shapes
    let shapes_label = cogito.label(@"Shapes")
    .set_class(@"heading")
    vstack.add(shapes_label)

    let shapes_info = cogito.label(@"Two shapes: Round(0) and Square(1)")
    .set_class(@"body")
    .set_wrap(true)
    vstack.add(shapes_info)

    let shapes_row = cogito.hstack()
    .set_gap(24)
    .set_hexpand(true)

    let round_label = cogito.label(@"Round")
    .set_class(@"body")
    shapes_row.add(round_label)

    let round_bg = cogito.buttongroup()
    .add(cogito.button(@"A"))
    .add(cogito.button(@"B"))
    .add(cogito.button(@"C"))
    .set_shape(0)
    .on_select((idx) => {
        status.set_text(@"Round shape selected, index: $idx")
    })
    shapes_row.add(round_bg)

    let square_label = cogito.label(@"Square")
    .set_class(@"body")
    shapes_row.add(square_label)

    let square_bg = cogito.buttongroup()
    .add(cogito.button(@"A"))
    .add(cogito.button(@"B"))
    .add(cogito.button(@"C"))
    .set_shape(1)
    .on_select((idx) => {
        status.set_text(@"Square shape selected, index: $idx")
    })
    shapes_row.add(square_bg)

    vstack.add(shapes_row)

    -- Section: Connected
    let connected_label = cogito.label(@"Connected")
    .set_class(@"heading")
    vstack.add(connected_label)

    let connected_info = cogito.label(@"Connected mode removes internal spacing between segments")
    .set_class(@"body")
    .set_wrap(true)
    vstack.add(connected_info)

    let connected_row = cogito.hstack()
    .set_gap(24)
    .set_hexpand(true)

    let disconnected_label = cogito.label(@"Not Connected")
    .set_class(@"body")
    connected_row.add(disconnected_label)

    let disconnected_bg = cogito.buttongroup()
    .add(cogito.button(@"One"))
    .add(cogito.button(@"Two"))
    .add(cogito.button(@"Three"))
    .set_connected(false)
    .on_select((idx) => {
        status.set_text(@"Disconnected mode, index: $idx")
    })
    connected_row.add(disconnected_bg)

    let connected_label2 = cogito.label(@"Connected")
    .set_class(@"body")
    connected_row.add(connected_label2)

    let connected_bg = cogito.buttongroup()
    .add(cogito.button(@"One"))
    .add(cogito.button(@"Two"))
    .add(cogito.button(@"Three"))
    .set_connected(true)
    .on_select((idx) => {
        status.set_text(@"Connected mode, index: $idx")
    })
    connected_row.add(connected_bg)

    vstack.add(connected_row)

    return vstack
}

fun build_chip_page() (( cogito.VStack )) {
    let vstack = build_page(@"Chip", @"Chips represent attributes, filters, or compact actions.")

    let status = cogito.label(@"Interact with a chip.")
    .set_class(@"body")
    vstack.add(status)

    let row = cogito.hstack()
    .set_gap(8)
    vstack.add(row)

    let filter = cogito.chip(@"Filter")
    .on_click((c = cogito.Chip) => {
        status.set_text(@"Filter clicked.")
    })
    row.add(filter)

    let selected = cogito.chip(@"Selected")
    .set_selected(true)
    .on_click((c = cogito.Chip) => {
        status.set_text(@"Selected state: $c.selected()")
    })
    row.add(selected)

    let closeable = cogito.chip(@"Closable")
    .set_closable(true)
    .on_close((c = cogito.Chip) => {
        status.set_text(@"Close action triggered.")
    })
    row.add(closeable)

    return vstack
}

fun build_fab_page() (( cogito.VStack )) {
    let vstack = build_page(@"FAB", @"Floating Action Buttons emphasize the primary action on a screen.")

    let status = cogito.label(@"Tap a FAB.")
    .set_class(@"body")
    vstack.add(status)

    let row = cogito.hstack()
    .set_gap(12)
    vstack.add(row)

    let fab1 = cogito.fab(@"plus")
    .on_click((f = cogito.FAB) => {
        status.set_text(@"Compact FAB clicked.")
    })
    row.add(fab1)

    let fab2 = cogito.fab(@"sf:pencil")
    .set_extended(true, @"Compose")
    .on_click((f = cogito.FAB) => {
        status.set_text(@"Extended FAB clicked.")
    })
    row.add(fab2)

    return vstack
}

fun build_carousel_page() (( cogito.VStack )) {
    let vstack = build_page(@"Carousel", @"Carousel presents horizontally swipeable cards with a focused active item.")

    let status = cogito.label(@"Active item: 0")
    .set_class(@"body")
    vstack.add(status)

    let carousel = cogito.carousel()
    .set_hexpand(true)

    let item1 = cogito.carousel_item()
    .set_vexpand(true)
    .set_hexpand(true)
    .set_text(@"Mountain View")
    .set_halign(0)
    .set_valign(2)
    let img1 = cogito.image(@"")
    .set_source(@"cogito/examples/assets/image.jpg")
    .set_hexpand(true)
    .set_vexpand(true)
    .set_radius(26)
    item1.add(img1)
    carousel.add(item1)

    let item2 = cogito.carousel_item()
    .set_vexpand(true)
    .set_hexpand(true)
    .set_text(@"Lakeside")
    .set_halign(0)
    .set_valign(2)
    let img2 = cogito.image(@"")
    .set_source(@"cogito/examples/assets/image2.jpg")
    .set_hexpand(true)
    .set_vexpand(true)
    .set_radius(26)
    item2.add(img2)
    carousel.add(item2)

    let item3 = cogito.carousel_item()
    .set_vexpand(true)
    .set_hexpand(true)
    .set_text(@"Sunset Vistas")
    .set_halign(0)
    .set_valign(2)
    let img3 = cogito.image(@"")
    .set_source(@"cogito/examples/assets/image3.jpg")
    .set_hexpand(true)
    .set_vexpand(true)
    .set_radius(26)
    item3.add(img3)
    carousel.add(item3)

    vstack.add(carousel)

    let next_btn = cogito.button(@"Next Item")
    .on_click((b = cogito.Button) => {
        let cur = carousel.active_index()
        let next = if cur >= 2 { 0 } else { cur + 1 }
        carousel.set_active_index(next)
        status.set_text(@"Active item: $next")
    })
    vstack.add(next_btn)

    return vstack
}

fun build_nav_rail_page() (( cogito.VStack )) {
    let vstack = build_page(@"Nav Rail", @"Navigation rails provide persistent, vertically arranged destinations.")

    let status = cogito.label(@"Selected: Home")
    .set_class(@"body")
    vstack.add(status)

    let rail = cogito.nav_rail()
    .set_items([@"Home", @"Search", @"Profile"], [@"sf:house", @"sf:magnifyingglass", @"sf:person"])
    .set_toggle(true)
    .set_badges([1, -1, 0])
    .set_selected(0)
    .on_change((idx) => {
        let item = if idx == 0 { @"Home" } elif idx == 1 { @"Search" } else { @"Profile" }
        status.set_text(@"Selected: $item")
    })
    vstack.add(rail)

    return vstack
}

fun build_bottom_nav_page() (( cogito.VStack )) {
    let vstack = build_page(@"BottomNav", @"Bottom navigation is a compact destination bar intended for top-level views.")

    let status = cogito.label(@"Selected: Home")
    .set_class(@"body")
    vstack.add(status)

    let nav = cogito.bottom_nav()
    .set_hexpand(true)
    .set_items([@"Home", @"Search", @"Library"], [@"sf:house", @"sf:magnifyingglass", @"sf:books.vertical"])
    .set_selected(0)
    .on_change((idx) => {
        let item = if idx == 0 { @"Home" } elif idx == 1 { @"Search" } else { @"Library" }
        status.set_text(@"Selected: $item")
    })
    vstack.add(nav)

    return vstack
}

fun build_bottom_toolbar_page() (( cogito.VStack )) {
    let vstack = build_page(@"BottomToolbar", @"Bottom toolbars support six slot-based actions; docked and floating variants share the same slot model.")

    let dock_label = cogito.label(@"Docked")
    .set_class(@"body")
    vstack.add(dock_label)

    let docked = cogito.bottom_toolbar()
    .set_hexpand(true)
    .add(cogito.iconbtn(@"archivebox"))
    .add(cogito.iconbtn(@"trash"))
    .add(cogito.iconbtn(@"photo"))
    .add(cogito.iconbtn(@"clock"))
    .add(cogito.iconbtn(@"star"))
    .add(cogito.iconbtn(@"ellipsis"))
    vstack.add(docked)

    let float_label = cogito.label(@"Floating")
    .set_class(@"body")
    vstack.add(float_label)

    let floating = cogito.bottom_toolbar()
    .set_class(@"floating")
    .set_hexpand(true)

    let bold = cogito.iconbtn(@"sf:textformat.bold")
    .set_class(@"toolbar_float_icon")
    floating.add(bold)

    let italic = cogito.iconbtn(@"sf:textformat.italic")
    .set_class(@"toolbar_float_icon")
    floating.add(italic)

    let underline = cogito.iconbtn(@"sf:textformat.underline")
    .set_class(@"toolbar_float_icon")
    floating.add(underline)

    let accent = cogito.iconbtn(@"sf:textformat")
    .set_class(@"toolbar_float_icon")
    floating.add(accent)

    let palette = cogito.iconbtn(@"sf:paintbrush")
    .set_class(@"toolbar_float_icon")
    floating.add(palette)

    let menu = cogito.iconbtn(@"sf:ellipsis")
    .set_class(@"toolbar_float_icon")
    floating.add(menu)
    vstack.add(floating)

    let compact_label = cogito.label(@"Floating Compact")
    .set_class(@"body")
    vstack.add(compact_label)

    let compact_wrap = cogito.hstack()
    .set_hexpand(true)
    .set_gap(8)

    let compact = cogito.bottom_toolbar()
    .set_class(@"floating_compact")
    .add(cogito.iconbtn(@"sf:checkmark.square"))
    .add(cogito.iconbtn(@"sf:paintbrush"))
    .add(cogito.iconbtn(@"sf:mic"))
    .add(cogito.iconbtn(@"sf:photo"))
    compact_wrap.add(compact)

    let add_btn = cogito.fab(@"plus")
    .set_class(@"toolbar_plus")
    .set_valign(1)
    compact_wrap.add(add_btn)

    vstack.add(compact_wrap)

    return vstack
}

fun build_dialog_page() (( cogito.VStack )) {
    let vstack = build_page(@"Dialog", @"Dialogs interrupt normal flow to request confirmation or gather focused input.")

    let status = cogito.label(@"Open the dialog to continue.")
    .set_class(@"body")
    .set_wrap(true)
    vstack.add(status)

    let show_btn = cogito.button(@"Show Dialog")
    vstack.add(show_btn)

    let slot = cogito.dialog_slot()
    vstack.add(slot)

    show_btn.on_click((b = cogito.Button) => {
        let dlg = cogito.dialog(@"Example Dialog")
        let content = cogito.vstack()
        .set_gap(8)
        .set_hexpand(true)
        .set_vexpand(true)
        .set_padding(24, 24, 24, 24)
        .add(cogito.label(@"This is a dialog body."))

        let close_btn = cogito.button(@"Close")
        .set_hexpand(true)
        .set_valign(1)
        .on_click((cb = cogito.Button) => {
            dlg.close()
            status.set_text(@"Dialog closed.")
        })
        content.add(close_btn)

        dlg.add(content)
        slot.show(dlg)
        status.set_text(@"Dialog opened.")
    })

    return vstack
}

fun build_toast_page() (( cogito.VStack )) {
    let vstack = build_page(@"Toast", @"Toasts provide lightweight, temporary notifications without blocking interaction.")

    let status = cogito.label(@"Show a toast notification.")
    .set_class(@"body")
    .set_wrap(true)
    vstack.add(status)

    let btn = cogito.button(@"Show Toast")
    vstack.add(btn)

    let toasts = cogito.toasts()
    vstack.add(toasts)

    btn.on_click((b = cogito.Button) => {
        let t = cogito.toast(@"Saved. Click me to acknowledge.")
        t.on_click((tt = cogito.Toast) => {
            status.set_text(@"Toast clicked.")
        })
        toasts.add(t)
        status.set_text(@"Toast shown.")
    })

    return vstack
}

fun build_treeview_page() (( cogito.VStack )) {
    let vstack = build_page(@"TreeView", @"TreeView shows hierarchical content where branches can be expanded or collapsed.")

    let tree = cogito.treeview()
    .set_hexpand(true)
    .set_vexpand(true)

    let branch_files = cogito.vstack()
    .set_class(@"files")
    .add(cogito.button(@"README.md"))
    .add(cogito.button(@"LICENSE"))

    let branch_src = cogito.vstack()
    .set_class(@"src")
    .add(cogito.button(@"cogito.c"))
    .add(cogito.button(@"theme.sum"))

    tree.add(branch_files)
    tree.add(branch_src)
    vstack.add(tree)

    return vstack
}

fun build_card_page() (( cogito.VStack )) {
    let vstack = build_page(@"Card", @"Cards group related content and actions within an elevated container.")

    let card = cogito.card(@"Release Notes")
    .set_hexpand(true)

    let body = cogito.label(@"Version 1.0 includes improved layout, theming, and gallery structure.")
    .set_class(@"body")
    .set_wrap(true)
    card.add(body)

    let action = cogito.button(@"View Details")
    .set_class(@"outlined")
    card.add(action)

    vstack.add(card)
    return vstack
}

fun build_avatar_page() (( cogito.VStack )) {
    let vstack = build_page(@"Avatar", @"Avatars represent people or entities through initials, icons, or images.")

    let row = cogito.hstack()
    .set_gap(12)
    .add(cogito.avatar(@"Alice"))
    .add(cogito.avatar(@"Bob"))
    .add(cogito.avatar(@"Charlie"))
    .add(cogito.avatar(@"sf:person"))
    vstack.add(row)

    return vstack
}

fun build_badge_page() (( cogito.VStack )) {
    let vstack = build_page(@"Badge", @"Badges annotate nearby UI with counts or status dots.")

    let row = cogito.hstack()
    .set_gap(14)
    .add(cogito.badge_dot())
    .add(cogito.badge(3))
    .add(cogito.badge(42))
    .add(cogito.badge(999))
    vstack.add(row)

    return vstack
}

fun build_banner_page() (( cogito.VStack )) {
    let vstack = build_page(@"Banner", @"Banners communicate high-priority information and can include an inline action.")

    let status = cogito.label(@"Trigger a banner action.")
    .set_class(@"body")
    vstack.add(status)

    let banner = cogito.banner(@"Your connection was lost.")
    .set_hexpand(true)
    .set_icon(@"sf:exclamationmark.triangle")
    .set_action(@"Retry", (b = any) => {
        status.set_text(@"Retry clicked.")
    })
    vstack.add(banner)

    return vstack
}

fun build_divider_page() (( cogito.VStack )) {
    let vstack = build_page(@"Divider", @"Dividers separate sections and improve scanability in dense layouts.")

    vstack.add(cogito.label(@"Section A"))
    let d1 = cogito.divider(@"horizontal", false)
    .set_hexpand(true)
    vstack.add(d1)

    vstack.add(cogito.label(@"Section B"))
    let d2 = cogito.divider(@"horizontal", true)
    .set_hexpand(true)
    vstack.add(d2)

    vstack.add(cogito.label(@"Section C"))

    return vstack
}

fun build_image_page() (( cogito.VStack )) {
    let vstack = build_page(@"Image", @"Image displays icons or file-backed assets with configurable size and corner radius.")

    let img = cogito.image(@"")
    .set_source(@"cogito/examples/assets/image.jpg")
    .set_size(360, 360)
    .set_radius(12)
    vstack.add(img)

    return vstack
}

fun build_active_indicator_page() (( cogito.VStack )) {
    let vstack = build_page(@"ActiveIndicator", @"ActiveIndicator is a compact spinner for signaling ongoing activity.")

    let ai = cogito.active_indicator()
    vstack.add(ai)

    return vstack
}

fun build_switchbar_page() (( cogito.VStack )) {
    let vstack = build_page(@"SwitchBar", @"SwitchBar combines descriptive text with an inline switch for preference toggles.")

    let status = cogito.label(@"Notifications disabled.")
    .set_class(@"body")
    vstack.add(status)

    let sb = cogito.switchbar(@"Enable notifications")
    .set_hexpand(true)
    .on_change((s = cogito.SwitchBar) => {
        let on = if s.get_checked() { @"enabled" } else { @"disabled" }
        status.set_text(@"Notifications $on.")
    })
    vstack.add(sb)

    return vstack
}

fun build_menu_button_page() (( cogito.VStack )) {
    let vstack = build_page(@"MenuButton", @"MenuButtons trigger a dropdown menu with selectable items.")

    let status = cogito.label(@"Select a menu item.")
    .set_class(@"body")
    vstack.add(status)

    let hstack = cogito.hstack()
    .set_gap(18)

    let mb1 = cogito.menu_button(@"sf:ellipsis")
    .add_menu(@"Item 1", (b = any) => {
        status.set_text(@"Item 1 selected.")
    })
    .add_menu(@"Item 2", (b = any) => {
        status.set_text(@"Item 2 selected.")
    })
    .add_menu(@"Item 3", (b = any) => {
        status.set_text(@"Item 3 selected.")
    })
    hstack.add(mb1)

    let mb2 = cogito.menu_button(@"sf:gearshape")
    .add_menu(@"Settings", (b = any) => {
        status.set_text(@"Settings selected.")
    })
    .add_menu_section(@"Preferences", (b = any) => {
        status.set_text(@"Preferences selected.")
    })
    .add_menu(@"About", (b = any) => {
        status.set_text(@"About selected.")
    })
    hstack.add(mb2)

    let mb3 = cogito.menu_button(@"sf:star")
    .set_menu_vibrant(true)
    .add_menu(@"Vibrant Item 1", (b = any) => {
        status.set_text(@"Vibrant Item 1 selected.")
    })
    .add_menu_section(@"Vibrant Item 2", (b = any) => {
        status.set_text(@"Vibrant Item 2 selected.")
    })
    .add_menu(@"Vibrant Item 3", (b = any) => {
        status.set_text(@"Vibrant Item 3 selected.")
    })
    hstack.add(mb3)

    vstack.add(hstack)

    return vstack
}

fun build_split_button_page() (( cogito.VStack )) {
    let vstack = build_page(@"SplitButton", @"SplitButton exposes a primary action plus a secondary dropdown menu.")

    let status = cogito.label(@"Choose an action.")
    .set_class(@"body")
    vstack.add(status)

    let sp = cogito.split_button(@"Save")
    .on_click((b = any) => {
        status.set_text(@"Primary Save clicked.")
    })
    .add_menu(@"Save As…", (b = any) => {
        status.set_text(@"Save As selected.")
    })
    .add_menu_section(@"Export", (b = any) => {
        status.set_text(@"Export selected.")
    })
    vstack.add(sp)

    return vstack
}

fun build_content_list_page() (( cogito.VStack )) {
    let vstack = build_page(@"ContentList", @"ContentList is a stylized list container for grouped content rows.")

    let cl = cogito.content_list()
    .set_hexpand(true)
    .add(cogito.label(@"First item"))
    .add(cogito.label(@"Second item"))
    .add(cogito.label(@"Third item"))
    vstack.add(cl)

    return vstack
}

fun build_empty_page_widget_page() (( cogito.VStack )) {
    let vstack = build_page(@"EmptyPage", @"EmptyPage communicates a zero-state with optional supporting action.")

    let status = cogito.label(@"No action yet.")
    .set_class(@"body")
    vstack.add(status)

    let ep = cogito.empty_page(@"No Items Yet")
    .set_description(@"Add some items to get started.")
    .set_icon(@"sf:folder")
    .set_action(@"Add Item", (b = any) => {
        status.set_text(@"EmptyPage action clicked.")
    })
    .set_hexpand(true)
    vstack.add(ep)

    return vstack
}

fun build_welcome_screen_page() (( cogito.VStack )) {
    let vstack = build_page(@"WelcomeScreen", @"WelcomeScreen is an onboarding-friendly hero container with an optional call to action.")

    let status = cogito.label(@"Ready")
    .set_class(@"body")
    vstack.add(status)

    let ws = cogito.welcome_screen(@"Welcome to Cogito")
    .set_description(@"Build responsive desktop interfaces with familiar declarative patterns.")
    .set_icon(@"sf:sparkles")
    .set_action(@"Get Started", (b = any) => {
        status.set_text(@"Welcome action clicked.")
    })
    .set_hexpand(true)
    vstack.add(ws)

    return vstack
}

fun build_settings_window_page() (( cogito.VStack )) {
    let vstack = build_page(@"SettingsWindow", @"SettingsWindow hosts structured preference pages built from settings page/list/row widgets.")

    let sw = cogito.settings_window(@"Preferences")
    .set_hexpand(true)
    .set_vexpand(true)

    let page_general = cogito.settings_page(@"General")
    let list_general = cogito.settings_list(@"Appearance")
    .set_hexpand(true)

    let row_dark = cogito.settings_row(@"Dark Mode")
    .set_hexpand(true)
    .add(cogito.switch(@""))
    list_general.add(row_dark)

    let row_font = cogito.settings_row(@"Font Size")
    .set_hexpand(true)
    .add(cogito.dropdown()
    .set_items([@"Small", @"Medium", @"Large"])
    .set_selected(1))
    list_general.add(row_font)

    page_general.add(list_general)
    sw.add(page_general)

    let page_about = cogito.settings_page(@"About")
    let list_about = cogito.settings_list(@"App Info")
    .set_hexpand(true)

    let row_version = cogito.settings_row(@"Version")
    .set_hexpand(true)
    .add(cogito.label(@"1.0.0"))
    list_about.add(row_version)

    page_about.add(list_about)
    sw.add(page_about)

    vstack.add(sw)
    return vstack
}

fun build_view_dual_page() (( cogito.VStack )) {
    let vstack = build_page(@"ViewDual", @"ViewDual splits content into resizable panes for side-by-side workflows.")

    let vd = cogito.view_dual()
    .set_hexpand(true)
    .set_vexpand(true)
    .set_ratio(0.4)

    let left = cogito.vstack()
    .set_hexpand(true)
    .set_vexpand(true)
    .set_gap(8)
    .set_padding(12, 12, 12, 12)
    .add(cogito.label(@"Left Pane"))
    .add(cogito.label(@"Resize by dragging the divider."))
    vd.add(left)

    let right = cogito.vstack()
    .set_hexpand(true)
    .set_vexpand(true)
    .set_gap(8)
    .set_padding(12, 12, 12, 12)
    .add(cogito.label(@"Right Pane"))
    .add(cogito.label(@"Content goes here."))
    vd.add(right)

    vstack.add(vd)
    return vstack
}

fun build_view_chooser_page() (( cogito.VStack )) {
    let vstack = build_page(@"ViewChooser", @"ViewChooser binds to a ViewSwitcher and controls which view is active.")

    let views = cogito.view_switcher()
    .set_hexpand(true)
    .add(@"option_a", (vs = cogito.ViewSwitcher) => cogito.label(@"Option A selected"))
    .add(@"option_b", (vs = cogito.ViewSwitcher) => cogito.label(@"Option B selected"))
    .add(@"option_c", (vs = cogito.ViewSwitcher) => cogito.label(@"Option C selected"))
    .set_active(@"option_a")

    let chooser = cogito.view_chooser()
    .set_items([@"Option A", @"Option B", @"Option C"])
    .bind(views)

    vstack.add(chooser)
    vstack.add(views)

    return vstack
}

fun build_fabmenu_page() (( cogito.VStack )) {
    let vstack = build_page(@"FabMenu", @"FabMenu is a floating action button that shows a menu of actions.")

    let status = cogito.label(@"Tap a FAB.")
    .set_class(@"body")
    .set_wrap(true)
    vstack.add(status)

    let fabmenu = cogito.fab_menu(@"plus")
    .set_hexpand(true)
    .set_vexpand(true)
    .add_item(@"Add", (b = any) => {
        status.set_text(@"Add action selected.")
    })
    .add_item(@"Edit", (b = any) => {
        status.set_text(@"Edit action selected.")
    })
    .add_item(@"Delete", (b = any) => {
        status.set_text(@"Delete action selected.")
    })
    vstack.add(fabmenu)

    return vstack
}

fun build_about_window_page() (( cogito.VStack )) {
    let vstack = build_page(@"AboutWindow", @"AboutWindow presents product metadata such as name, version, description, and website.")

    let status = cogito.label(@"Open the about dialog.")
    .set_class(@"body")
    .set_wrap(true)
    vstack.add(status)

    let show_btn = cogito.button(@"Show About Dialog")
    vstack.add(show_btn)

    let slot = cogito.dialog_slot()
    vstack.add(slot)

    show_btn.on_click((b = cogito.Button) => {
        let dlg = cogito.dialog(@"")
        let aw = cogito.about_window(@"Cogito Gallery", @"1.0.0")
        aw.set_icon(@"sf:sparkles")
        aw.set_description(@"A showcase of Cogito widgets.")
        aw.set_website(@"https://github.com/lainsce/ergo")
        aw.set_issue_url(@"https://github.com/lainsce/ergo/issues")
        dlg.add(aw)
        slot.show(dlg)
        status.set_text(@"About dialog opened.")
    })

    return vstack
}

fun add_typography_row(vstack = cogito.VStack, name = string, cls = string, sample = string, ypad = num) (( -- )) {
    let row = cogito.hstack()
    .set_hexpand(true)
    .set_gap(24)
    .set_padding(ypad, 0, ypad, 0)

    let left = cogito.label(name)
    .set_class(@"content-title")
    left.set_valign(1)
    row.add(left)

    let right = cogito.label(sample)
    right.set_class(cls)
    right.set_text_align(2)
    right.set_valign(1)
    right.set_hexpand(true)
    row.add(right)

    vstack.add(row)
}

fun build_typography_page() (( cogito.VStack )) {
    let vstack = build_page(@"Typography", @"Typography classes define consistent text rhythm for headings and content.")

    let header = cogito.hstack()
    .set_hexpand(true)
    .set_gap(24)

    let header_class = cogito.label(@"Class")
    .set_class(@"caption")
    header.add(header_class)

    let header_sample = cogito.label(@"Sample")
    header_sample.set_class(@"caption")
    header_sample.set_text_align(2)
    header_sample.set_hexpand(true)
    header.add(header_sample)

    vstack.add(header)

    let table = cogito.vstack()
    .set_hexpand(true)
    .set_gap(0)

    add_typography_row(table, @"Big Display", @"big-display", @"Serif, 56", 10)
    add_typography_row(table, @"Display", @"display", @"Serif, 36", 8)
    add_typography_row(table, @"View Title", @"view-title", @"Sans, 24", 6)
    add_typography_row(table, @"View Subtitle", @"view-subtitle", @"Sans Bold, 18", 4)
    add_typography_row(table, @"Heading", @"heading", @"Sans, 16", 3)
    add_typography_row(table, @"Content Title", @"content-title", @"Sans Bold, 16", 3)
    add_typography_row(table, @"Content Subtitle", @"content-subtitle", @"Sans, 14", 3)
    add_typography_row(table, @"Body", @"body", @"Sans, 14", 3)
    add_typography_row(table, @"Caption", @"caption", @"Sans Bold, 12", 2)

    let tabular_row = cogito.hstack()
    .set_hexpand(true)
    .set_gap(24)
    .set_padding(10, 0, 0, 0)

    let tabular_name = cogito.label(@"Tabular")
    .set_class(@"content-title")
    tabular_name.set_valign(1)
    tabular_row.add(tabular_name)

    let nums = cogito.label(@"09:41  001  128  999")
    .set_class(@"tabular")
    .set_text_align(2)
    .set_valign(1)
    .set_hexpand(true)
    tabular_row.add(nums)

    let monospace_row = cogito.hstack()
    .set_hexpand(true)
    .set_gap(24)
    .set_padding(10, 0, 0, 0)

    let monospace_name = cogito.label(@"Monospace")
    .set_class(@"content-title")
    monospace_name.set_valign(1)
    monospace_row.add(monospace_name)

    let bash = cogito.label(@"$ bash ~/")
    .set_class(@"monospace")
    .set_text_align(2)
    .set_valign(1)
    .set_hexpand(true)
    monospace_row.add(bash)

    table.add(tabular_row)
    table.add(monospace_row)
    vstack.add(table)

    return vstack
}

fun build_side_sheet_page() (( cogito.VStack )) {
    let vstack = build_page(@"SideSheet", @"SideSheet slides in from the right edge, useful for detail views or settings.")

    let status = cogito.label(@"Click the button to open a side sheet.")
    .set_class(@"body")
    .set_wrap(true)
    vstack.add(status)

    let button_row = cogito.hstack().set_gap(12)
    vstack.add(button_row)

    let open_modal_btn = cogito.button(@"Open Modal Side Sheet")
    .on_click((b = cogito.Button) => {
        let win = b.window()
        if win {
            let ss = cogito.side_sheet(@"Modal Details")
            ss.set_mode(0) -- COGITO_SIDE_SHEET_MODAL
            ss.add(cogito.label(@"This is a modal side sheet content."))
            win.set_side_sheet(ss)
        }
    })
    button_row.add(open_modal_btn)

    let open_inset_btn = cogito.button(@"Open Inset Side Sheet")
    .on_click((b = cogito.Button) => {
        let win = b.window()
        if win {
            let ss = cogito.side_sheet(@"Inset Details")
            ss.set_mode(1) -- COGITO_SIDE_SHEET_INSET
            ss.add(cogito.label(@"This is an inset side sheet content."))
            win.set_side_sheet(ss)
        }
    })
    button_row.add(open_inset_btn)

    let open_sidebar_btn = cogito.button(@"Open Sidebar")
    .on_click((b = cogito.Button) => {
        let win = b.window()
        if win {
            let ss = cogito.side_sheet(@"Sidebar")
            ss.set_mode(2) -- COGITO_SIDE_SHEET_SIDEBAR
            ss.add(cogito.label(@"This is sidebar content."))
            win.set_side_sheet(ss)
        }
    })
    button_row.add(open_sidebar_btn)

    -- Placeholder for where sidebar content would go
    let sidebar_placeholder = cogito.vstack()
        .set_hexpand(true)
        .add(cogito.label(@"Press 'Open Sidebar' to show the sidebar."))
    vstack.add(sidebar_placeholder)

    return vstack
}

fun view_id_from_index(idx = num) (( string )) {
    return if idx == 0 {
        @"button"
    } elif idx == 1 {
        @"iconbtn"
    } elif idx == 2 {
        @"textfield"
    } elif idx == 3 {
        @"searchfield"
    } elif idx == 4 {
        @"textview"
    } elif idx == 5 {
        @"checkbox"
    } elif idx == 6 {
        @"switch"
    } elif idx == 7 {
        @"slider"
    } elif idx == 8 {
        @"stepper"
    } elif idx == 9 {
        @"datepicker"
    } elif idx == 10 {
        @"colorpicker"
    } elif idx == 11 {
        @"timepicker"
    } elif idx == 12 {
        @"dropdown"
    } elif idx == 13 {
        @"progress"
    } elif idx == 14 {
        @"list"
    } elif idx == 15 {
        @"grid"
    } elif idx == 16 {
        @"tabs"
    } elif idx == 17 {
        @"buttongroup"
    } elif idx == 18 {
        @"chip"
    } elif idx == 19 {
        @"fab"
    } elif idx == 20 {
        @"carousel"
    } elif idx == 21 {
        @"nav_rail"
    } elif idx == 22 {
        @"bottom_nav"
    } elif idx == 23 {
        @"bottom_toolbar"
    } elif idx == 24 {
        @"dialog"
    } elif idx == 25 {
        @"toast"
    } elif idx == 26 {
        @"treeview"
    } elif idx == 27 {
        @"card"
    } elif idx == 28 {
        @"avatar"
    } elif idx == 29 {
        @"badge"
    } elif idx == 30 {
        @"banner"
    } elif idx == 31 {
        @"divider"
    } elif idx == 32 {
        @"image"
    } elif idx == 33 {
        @"active_indicator"
    } elif idx == 34 {
        @"switchbar"
     } elif idx == 35 {
        @"split_button"
    } elif idx == 36 {
        @"menu_button"
    } elif idx == 37 {
        @"content_list"
    } elif idx == 38 {
        @"empty_page"
    } elif idx == 39 {
        @"welcome_screen"
    } elif idx == 40 {
        @"settings_window"
    } elif idx == 41 {
        @"view_dual"
    } elif idx == 42 {
        @"view_chooser"
    } elif idx == 43 {
        @"about_window"
    } elif idx == 44 {
        @"typography"
    } elif idx == 45 {
        @"side_sheet"
    } elif idx == 46 {
        @"fabmenu"
    } elif idx == 47 {
        @"ensor"
    } else {
        @"button"
    }
}

fun view_title_from_index(idx = num) (( string )) {
    return if idx == 0 {
        @"Button"
    } elif idx == 1 {
        @"Icon Button"
    } elif idx == 2 {
        @"TextField"
    } elif idx == 3 {
        @"SearchField"
    } elif idx == 4 {
        @"TextView"
    } elif idx == 5 {
        @"Checkbox"
    } elif idx == 6 {
        @"Switch"
    } elif idx == 7 {
        @"Slider"
    } elif idx == 8 {
        @"Stepper"
    } elif idx == 9 {
        @"DatePicker"
    } elif idx == 10 {
        @"ColorPicker"
    } elif idx == 11 {
        @"TimePicker"
    } elif idx == 12 {
        @"Dropdown"
    } elif idx == 13 {
        @"Progress"
    } elif idx == 14 {
        @"List"
    } elif idx == 15 {
        @"Grid"
    } elif idx == 16 {
        @"Tabs"
    } elif idx == 17 {
        @"ButtonGroups"
    } elif idx == 18 {
        @"Chip"
    } elif idx == 19 {
        @"FAB"
    } elif idx == 20 {
        @"Carousel"
    } elif idx == 21 {
        @"Nav Rail"
    } elif idx == 22 {
        @"BottomNav"
    } elif idx == 23 {
        @"BottomToolbar"
    } elif idx == 24 {
        @"Dialog"
    } elif idx == 25 {
        @"Toast"
    } elif idx == 26 {
        @"TreeView"
    } elif idx == 27 {
        @"Card"
    } elif idx == 28 {
        @"Avatar"
    } elif idx == 29 {
        @"Badge"
    } elif idx == 30 {
        @"Banner"
    } elif idx == 31 {
        @"Divider"
    } elif idx == 32 {
        @"Image"
    } elif idx == 33 {
        @"ActiveIndicator"
    } elif idx == 34 {
        @"SwitchBar"
     } elif idx == 35 {
        @"SplitButton"
    } elif idx == 36 {
        @"MenuButton"
    } elif idx == 37 {
        @"ContentList"
    } elif idx == 38 {
        @"EmptyPage"
    } elif idx == 39 {
        @"WelcomeScreen"
    } elif idx == 40 {
        @"SettingsWindow"
    } elif idx == 41 {
        @"ViewDual"
    } elif idx == 42 {
        @"ViewChooser"
    } elif idx == 43 {
        @"AboutWindow"
    } elif idx == 44 {
        @"Typography"
    } elif idx == 45 {
        @"SideSheet"
    } elif idx == 46 {
        @"FabMenu"
    } elif idx == 47 {
        @"Ensor"
    } else {
        @"Button"
    }
}

fun build_ensor_page() (( cogito.VStack )) {
    let vstack = build_page(@"Ensor Color System", @"Ensor generates color schemes from a single accent color. Choose a variant to change the palette character.")

    let variants_label = cogito.label(@"Scheme Variant")
    .set_class(@"heading")
    vstack.add(variants_label)

    let variants = cogito.buttongroup()
    .add(cogito.button(@"Default").on_click((b = cogito.Button) => {
        app.set_ensor_variant(0)
    }))
    .add(cogito.button(@"Vibrant").on_click((b = cogito.Button) => {
        app.set_ensor_variant(1)
    }))
    .add(cogito.button(@"Muted").on_click((b = cogito.Button) => {
        app.set_ensor_variant(2)
    }))
    .add(cogito.button(@"Fruit Salad").on_click((b = cogito.Button) => {
        app.set_ensor_variant(4)
    }))
    .set_connected (true)
    .set_size(3)

    vstack.add(variants)

    return vstack
}

fun build_ui(win = cogito.Window) (( -- )) {
    let sidebar_bar = cogito.appbar(@"Widgets", @"")
    .set_class(@"sidebar")
    let content_bar = cogito.appbar(@"Button", @"")

    let root = cogito.hstack()
    .set_vexpand(true)
    .set_hexpand(true)

    let views = cogito.view_switcher()
    .set_hexpand(true)
    .set_vexpand(true)
    .add(@"button", (vs = cogito.ViewSwitcher) => build_button_page())
    .add(@"iconbtn", (vs = cogito.ViewSwitcher) => build_iconbtn_page())
    .add(@"textfield", (vs = cogito.ViewSwitcher) => build_textfield_page())
    .add(@"searchfield", (vs = cogito.ViewSwitcher) => build_searchfield_page())
    .add(@"textview", (vs = cogito.ViewSwitcher) => build_textview_page())
    .add(@"checkbox", (vs = cogito.ViewSwitcher) => build_checkbox_page())
    .add(@"switch", (vs = cogito.ViewSwitcher) => build_switch_page())
    .add(@"slider", (vs = cogito.ViewSwitcher) => build_slider_page())
    .add(@"stepper", (vs = cogito.ViewSwitcher) => build_stepper_page())
    .add(@"datepicker", (vs = cogito.ViewSwitcher) => build_datepicker_page())
    .add(@"colorpicker", (vs = cogito.ViewSwitcher) => build_colorpicker_page())
    .add(@"timepicker", (vs = cogito.ViewSwitcher) => build_timepicker_page())
    .add(@"dropdown", (vs = cogito.ViewSwitcher) => build_dropdown_page())
    .add(@"progress", (vs = cogito.ViewSwitcher) => build_progress_page())
    .add(@"list", (vs = cogito.ViewSwitcher) => build_list_page())
    .add(@"grid", (vs = cogito.ViewSwitcher) => build_grid_page())
    .add(@"tabs", (vs = cogito.ViewSwitcher) => build_tabs_page())
    .add(@"buttongroup", (vs = cogito.ViewSwitcher) => build_buttongroup_page())
    .add(@"chip", (vs = cogito.ViewSwitcher) => build_chip_page())
    .add(@"fab", (vs = cogito.ViewSwitcher) => build_fab_page())
    .add(@"carousel", (vs = cogito.ViewSwitcher) => build_carousel_page())
    .add(@"nav_rail", (vs = cogito.ViewSwitcher) => build_nav_rail_page())
    .add(@"bottom_nav", (vs = cogito.ViewSwitcher) => build_bottom_nav_page())
    .add(@"bottom_toolbar", (vs = cogito.ViewSwitcher) => build_bottom_toolbar_page())
    .add(@"dialog", (vs = cogito.ViewSwitcher) => build_dialog_page())
    .add(@"toast", (vs = cogito.ViewSwitcher) => build_toast_page())
    .add(@"treeview", (vs = cogito.ViewSwitcher) => build_treeview_page())
    .add(@"card", (vs = cogito.ViewSwitcher) => build_card_page())
    .add(@"avatar", (vs = cogito.ViewSwitcher) => build_avatar_page())
    .add(@"badge", (vs = cogito.ViewSwitcher) => build_badge_page())
    .add(@"banner", (vs = cogito.ViewSwitcher) => build_banner_page())
    .add(@"divider", (vs = cogito.ViewSwitcher) => build_divider_page())
    .add(@"image", (vs = cogito.ViewSwitcher) => build_image_page())
    .add(@"active_indicator", (vs = cogito.ViewSwitcher) => build_active_indicator_page())
    .add(@"switchbar", (vs = cogito.ViewSwitcher) => build_switchbar_page())
    .add(@"split_button", (vs = cogito.ViewSwitcher) => build_split_button_page())
    .add(@"menu_button", (vs = cogito.ViewSwitcher) => build_menu_button_page())
    .add(@"content_list", (vs = cogito.ViewSwitcher) => build_content_list_page())
    .add(@"empty_page", (vs = cogito.ViewSwitcher) => build_empty_page_widget_page())
    .add(@"welcome_screen", (vs = cogito.ViewSwitcher) => build_welcome_screen_page())
    .add(@"settings_window", (vs = cogito.ViewSwitcher) => build_settings_window_page())
    .add(@"view_dual", (vs = cogito.ViewSwitcher) => build_view_dual_page())
    .add(@"view_chooser", (vs = cogito.ViewSwitcher) => build_view_chooser_page())
    .add(@"about_window", (vs = cogito.ViewSwitcher) => build_about_window_page())
    .add(@"typography", (vs = cogito.ViewSwitcher) => build_typography_page())
    .add(@"side_sheet", (vs = cogito.ViewSwitcher) => build_side_sheet_page())
    .add(@"fabmenu", (vs = cogito.ViewSwitcher) => build_fabmenu_page())
    .add(@"ensor", (vs = cogito.ViewSwitcher) => build_ensor_page())

    let selected_idx = 0
    views.set_active(view_id_from_index(selected_idx))
    content_bar.set_title(view_title_from_index(selected_idx))

    let sidebar = cogito.vstack()
    .set_class(@"sidebar")
    .set_vexpand(true)
    .add(sidebar_bar)

    let sidebar_list = cogito.list()
    .set_vexpand(true)
    .set_padding(8, 8, 8, 8)
    .add(cogito.label(@"Button").set_padding(10,16,10,16))
    .add(cogito.label(@"Icon Button").set_padding(10,16,10,16))
    .add(cogito.label(@"TextField").set_padding(10,16,10,16))
    .add(cogito.label(@"SearchField").set_padding(10,16,10,16))
    .add(cogito.label(@"TextView").set_padding(10,16,10,16))
    .add(cogito.label(@"Checkbox").set_padding(10,16,10,16))
    .add(cogito.label(@"Switch").set_padding(10,16,10,16))
    .add(cogito.label(@"Slider").set_padding(10,16,10,16))
    .add(cogito.label(@"Stepper").set_padding(10,16,10,16))
    .add(cogito.label(@"DatePicker").set_padding(10,16,10,16))
    .add(cogito.label(@"ColorPicker").set_padding(10,16,10,16))
    .add(cogito.label(@"TimePicker").set_padding(10,16,10,16))
    .add(cogito.label(@"Dropdown").set_padding(10,16,10,16))
    .add(cogito.label(@"Progress").set_padding(10,16,10,16))
    .add(cogito.label(@"List").set_padding(10,16,10,16))
    .add(cogito.label(@"Grid").set_padding(10,16,10,16))
    .add(cogito.label(@"Tabs").set_padding(10,16,10,16))
    .add(cogito.label(@"ButtonGroup").set_padding(10,16,10,16))
    .add(cogito.label(@"Chip").set_padding(10,16,10,16))
    .add(cogito.label(@"FAB").set_padding(10,16,10,16))
    .add(cogito.label(@"Carousel").set_padding(10,16,10,16))
    .add(cogito.label(@"Nav Rail").set_padding(10,16,10,16))
    .add(cogito.label(@"BottomNav").set_padding(10,16,10,16))
    .add(cogito.label(@"BottomToolbar").set_padding(10,16,10,16))
    .add(cogito.label(@"Dialog").set_padding(10,16,10,16))
    .add(cogito.label(@"Toast").set_padding(10,16,10,16))
    .add(cogito.label(@"TreeView").set_padding(10,16,10,16))
    .add(cogito.label(@"Card").set_padding(10,16,10,16))
    .add(cogito.label(@"Avatar").set_padding(10,16,10,16))
    .add(cogito.label(@"Badge").set_padding(10,16,10,16))
    .add(cogito.label(@"Banner").set_padding(10,16,10,16))
    .add(cogito.label(@"Divider").set_padding(10,16,10,16))
    .add(cogito.label(@"Image").set_padding(10,16,10,16))
    .add(cogito.label(@"ActiveIndicator").set_padding(10,16,10,16))
    .add(cogito.label(@"SwitchBar").set_padding(10,16,10,16))
    .add(cogito.label(@"SplitButton").set_padding(10,16,10,16))
    .add(cogito.label(@"MenuButton").set_padding(10,16,10,16))
    .add(cogito.label(@"ContentList").set_padding(10,16,10,16))
    .add(cogito.label(@"EmptyPage").set_padding(10,16,10,16))
    .add(cogito.label(@"WelcomeScreen").set_padding(10,16,10,16))
    .add(cogito.label(@"SettingsWindow").set_padding(10,16,10,16))
    .add(cogito.label(@"ViewDual").set_padding(10,16,10,16))
    .add(cogito.label(@"ViewChooser").set_padding(10,16,10,16))
    .add(cogito.label(@"AboutWindow").set_padding(10,16,10,16))
    .add(cogito.label(@"Typography").set_padding(10,16,10,16))
    .add(cogito.label(@"SideSheet").set_padding(10,16,10,16))
    .add(cogito.label(@"FAB Menu").set_padding(10,16,10,16))
    .add(cogito.label(@"Ensor").set_padding(10,16,10,16))
    .on_select((idx) => {
        views.set_active(view_id_from_index(idx))
        content_bar.set_title(view_title_from_index(idx))
    })

    let sidebar_scroller = cogito.scroller()
    .set_class(@"sidebar")
    .set_axes(false, true)
    .add(sidebar_list)
    .set_vexpand(true)
    .set_hexpand(false)

    sidebar.add(sidebar_scroller)
    root.add(sidebar)

    let content = cogito.vstack()
    .set_hexpand(true)
    .set_vexpand(true)
    .add(content_bar)

    let content_scroller = cogito.scroller()
    .set_axes(false, true)
    .set_vexpand(true)
    .set_hexpand(true)
    .add(views)
    content.add(content_scroller)

    root.add(content)
    win.add(root)
}

entry () (( -- )) {
    let the_app = app
    the_app.set_appid(@"ergo.cogito.Gallery")
    the_app.set_accent_color(@"#72dec2", false)

    let main_win = cogito.window_size(@"Cogito Gallery", 800, 700)
    .build(build_ui)
    .set_a11y_label(@"Cogito Gallery")
    .set_autosize(false)
    .set_resizable(true)

    app.run(main_win)
}
