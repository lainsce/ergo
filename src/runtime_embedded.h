#ifndef ERGO_RUNTIME_EMBEDDED_H
#define ERGO_RUNTIME_EMBEDDED_H

// Auto-generated snapshot of ergo/src/runtime.inc with // @include expansion.
// Used as a fallback when runtime.inc is not available next to the ergo binary.
// Regenerate with: ergo/tools/gen_runtime_embedded.sh

static const char ergo_runtime_embedded[] =
"// ---- Ergo runtime (minimal) ----\n"
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <string.h>\n"
"#include <stdbool.h>\n"
"#include <stdint.h>\n"
"#include <stdarg.h>\n"
"#include <ctype.h>\n"
"#include <math.h>\n"
"#include <limits.h>\n"
"#include <time.h>\n"
"#include <sys/stat.h>\n"
"#if defined(__APPLE__)\n"
"#include <CoreGraphics/CoreGraphics.h>\n"
"#endif\n"
"\n"
"#if defined(_WIN32)\n"
"#include <windows.h>\n"
"#include <io.h>\n"
"#else\n"
"int isatty(int);\n"
"int fileno(FILE*);\n"
"#endif\n"
"\n"
"static int ergo_stdout_isatty = 0;\n"
"\n"
"static bool cogito_debug_enabled(void);\n"
"static const char* cogito_font_path_active = NULL;\n"
"\n"
"static void ergo_runtime_init(void) {\n"
"#if defined(__APPLE__)\n"
"  if (cogito_debug_enabled()) {\n"
"    fprintf(stderr, \"cogito: runtime_init\\n\");\n"
"    fflush(stderr);\n"
"  }\n"
"#endif\n"
"#if defined(_WIN32)\n"
"  ergo_stdout_isatty = _isatty(_fileno(stdout));\n"
"#else\n"
"  ergo_stdout_isatty = isatty(fileno(stdout));\n"
"#endif\n"
"  if (!ergo_stdout_isatty) {\n"
"    setvbuf(stdout, NULL, _IOFBF, 1 << 16);\n"
"  }\n"
"}\n"
"\n"
"typedef enum {\n"
"  EVT_NULL,\n"
"  EVT_INT,\n"
"  EVT_FLOAT,\n"
"  EVT_BOOL,\n"
"  EVT_STR,\n"
"  EVT_ARR,\n"
"  EVT_OBJ,\n"
"  EVT_FN\n"
"} ErgoTag;\n"
"\n"
"typedef struct ErgoVal ErgoVal;\n"
"\n"
"typedef struct ErgoStr {\n"
"  int ref;\n"
"  size_t len;\n"
"  char* data;\n"
"} ErgoStr;\n"
"\n"
"typedef struct ErgoArr {\n"
"  int ref;\n"
"  size_t len;\n"
"  size_t cap;\n"
"  ErgoVal* items;\n"
"} ErgoArr;\n"
"\n"
"typedef struct ErgoObj {\n"
"  int ref;\n"
"  void (*drop)(struct ErgoObj*);\n"
"} ErgoObj;\n"
"\n"
"typedef struct ErgoFn {\n"
"  int ref;\n"
"  int arity;\n"
"  ErgoVal (*fn)(void* env, int argc, ErgoVal* argv);\n"
"  void* env;\n"
"  int env_size;\n"
"} ErgoFn;\n"
"\n"
"struct ErgoVal {\n"
"  ErgoTag tag;\n"
"  union {\n"
"    int64_t i;\n"
"    double f;\n"
"    bool b;\n"
"    void* p;\n"
"  } as;\n"
"};\n"
"\n"
"#define EV_NULLV ((ErgoVal){.tag=EVT_NULL})\n"
"#define EV_INT(x) ((ErgoVal){.tag=EVT_INT, .as.i=(int64_t)(x)})\n"
"#define EV_FLOAT(x) ((ErgoVal){.tag=EVT_FLOAT, .as.f=(double)(x)})\n"
"#define EV_BOOL(x) ((ErgoVal){.tag=EVT_BOOL, .as.b=(x)?true:false})\n"
"#define EV_STR(x) ((ErgoVal){.tag=EVT_STR, .as.p=(x)})\n"
"#define EV_ARR(x) ((ErgoVal){.tag=EVT_ARR, .as.p=(x)})\n"
"#define EV_OBJ(x) ((ErgoVal){.tag=EVT_OBJ, .as.p=(x)})\n"
"#define EV_FN(x) ((ErgoVal){.tag=EVT_FN, .as.p=(x)})\n"
"\n"
"static void ergo_trap(const char* msg) {\n"
"  fprintf(stderr, \"runtime error: %s\\n\", msg ? msg : \"unknown error\");\n"
"  fprintf(stderr, \"  (run with debugger for stack trace)\\n\");\n"
"  abort();\n"
"}\n"
"\n"
"static void ergo_retain_val(ErgoVal v);\n"
"static void ergo_release_val(ErgoVal v);\n"
"\n"
"// Static constant strings (ref=INT32_MAX means never freed)\n"
"static ErgoStr ergo_static_empty    = { INT32_MAX, 0, \"\" };\n"
"static ErgoStr ergo_static_null     = { INT32_MAX, 4, \"null\" };\n"
"static ErgoStr ergo_static_true     = { INT32_MAX, 4, \"true\" };\n"
"static ErgoStr ergo_static_false    = { INT32_MAX, 5, \"false\" };\n"
"static ErgoStr ergo_static_array    = { INT32_MAX, 7, \"[array]\" };\n"
"static ErgoStr ergo_static_object   = { INT32_MAX, 8, \"[object]\" };\n"
"static ErgoStr ergo_static_function = { INT32_MAX, 10, \"[function]\" };\n"
"static ErgoStr ergo_static_unknown  = { INT32_MAX, 3, \"<?>\" };\n"
"\n"
"static ErgoStr* stdr_str_lit(const char* s) {\n"
"  size_t n = strlen(s);\n"
"  ErgoStr* st = (ErgoStr*)malloc(sizeof(ErgoStr) + n + 1);\n"
"  st->ref = 1;\n"
"  st->len = n;\n"
"  st->data = (char*)(st + 1);\n"
"  memcpy(st->data, s, n + 1);\n"
"  return st;\n"
"}\n"
"\n"
"static ErgoStr* stdr_str_from_parts(int n, ErgoVal* parts);\n"
"static ErgoStr* stdr_to_string(ErgoVal v);\n"
"static ErgoStr* stdr_str_from_slice(const char* s, size_t len);\n"
"static ErgoArr* stdr_arr_new(int n);\n"
"static void ergo_arr_add(ErgoArr* a, ErgoVal v);\n"
"static ErgoVal ergo_arr_get(ErgoArr* a, int64_t idx);\n"
"static void ergo_arr_set(ErgoArr* a, int64_t idx, ErgoVal v);\n"
"static ErgoVal ergo_arr_remove(ErgoArr* a, int64_t idx);\n"
"\n"
"static ErgoVal stdr_str_at(ErgoVal v, int64_t idx) {\n"
"  if (v.tag != EVT_STR) ergo_trap(\"str_at expects string\");\n"
"  ErgoStr* s = (ErgoStr*)v.as.p;\n"
"  if (idx < 0 || (size_t)idx >= s->len) return EV_STR(&ergo_static_empty);\n"
"  return EV_STR(stdr_str_from_slice(s->data + idx, 1));\n"
"}\n"
"\n"
"static int stdr_len(ErgoVal v) {\n"
"  if (v.tag == EVT_STR) return (int)((ErgoStr*)v.as.p)->len;\n"
"  if (v.tag == EVT_ARR) return (int)((ErgoArr*)v.as.p)->len;\n"
"  return 0;\n"
"}\n"
"\n"
"static bool stdr_is_null(ErgoVal v) { return v.tag == EVT_NULL; }\n"
"\n"
"static void stdr_write(ErgoVal v) {\n"
"  ErgoStr* s = stdr_to_string(v);\n"
"  fwrite(s->data, 1, s->len, stdout);\n"
"  if (ergo_stdout_isatty) fflush(stdout);\n"
"  ergo_release_val(EV_STR(s));\n"
"}\n"
"\n"
"static void writef(ErgoVal fmt, int argc, ErgoVal* argv) {\n"
"  if (fmt.tag != EVT_STR) ergo_trap(\"writef expects string\");\n"
"  ErgoStr* s = (ErgoStr*)fmt.as.p;\n"
"  size_t i = 0;\n"
"  size_t seg = 0;\n"
"  int argi = 0;\n"
"  while (i < s->len) {\n"
"    if (i + 1 < s->len && s->data[i] == '{' && s->data[i + 1] == '}') {\n"
"      if (i > seg) fwrite(s->data + seg, 1, i - seg, stdout);\n"
"      if (argi < argc) {\n"
"        ErgoStr* ps = stdr_to_string(argv[argi++]);\n"
"        fwrite(ps->data, 1, ps->len, stdout);\n"
"        ergo_release_val(EV_STR(ps));\n"
"      }\n"
"      i += 2;\n"
"      seg = i;\n"
"      continue;\n"
"    }\n"
"    i++;\n"
"  }\n"
"  if (i > seg) fwrite(s->data + seg, 1, i - seg, stdout);\n"
"  if (ergo_stdout_isatty) fflush(stdout);\n"
"}\n"
"\n"
"static void stdr_writef_args(ErgoVal fmt, ErgoVal args) {\n"
"  if (args.tag != EVT_ARR) ergo_trap(\"writef expects args tuple\");\n"
"  ErgoArr* a = (ErgoArr*)args.as.p;\n"
"  writef(fmt, (int)a->len, a->items);\n"
"}\n"
"\n"
"static ErgoStr* stdr_read_line(void) {\n"
"  size_t cap = 128;\n"
"  size_t len = 0;\n"
"  char* buf = (char*)malloc(cap);\n"
"  if (!buf) ergo_trap(\"out of memory\");\n"
"  int c;\n"
"  while ((c = fgetc(stdin)) != EOF) {\n"
"    if (c == '\\n') break;\n"
"    if (len + 1 >= cap) {\n"
"      cap *= 2;\n"
"      buf = (char*)realloc(buf, cap);\n"
"      if (!buf) ergo_trap(\"out of memory\");\n"
"    }\n"
"    buf[len++] = (char)c;\n"
"  }\n"
"  if (len > 0 && buf[len - 1] == '\\r') len--;\n"
"  ErgoStr* s = (ErgoStr*)malloc(sizeof(ErgoStr) + len + 1);\n"
"  if (!s) ergo_trap(\"out of memory\");\n"
"  s->ref = 1;\n"
"  s->len = len;\n"
"  s->data = (char*)(s + 1);\n"
"  memcpy(s->data, buf, len);\n"
"  s->data[len] = 0;\n"
"  free(buf);\n"
"  return s;\n"
"}\n"
"\n"
"static ErgoVal stdr_read_text_file(ErgoVal pathv) {\n"
"  if (pathv.tag != EVT_STR) ergo_trap(\"read_text_file expects string path\");\n"
"  ErgoStr* path = (ErgoStr*)pathv.as.p;\n"
"  FILE* f = fopen(path->data, \"rb\");\n"
"  if (!f) return EV_NULLV;\n"
"  if (fseek(f, 0, SEEK_END) != 0) {\n"
"    fclose(f);\n"
"    return EV_NULLV;\n"
"  }\n"
"  long sz = ftell(f);\n"
"  if (sz < 0) {\n"
"    fclose(f);\n"
"    return EV_NULLV;\n"
"  }\n"
"  if (fseek(f, 0, SEEK_SET) != 0) {\n"
"    fclose(f);\n"
"    return EV_NULLV;\n"
"  }\n"
"  size_t len = (size_t)sz;\n"
"  ErgoStr* out = (ErgoStr*)malloc(sizeof(ErgoStr) + len + 1);\n"
"  if (!out) {\n"
"    fclose(f);\n"
"    ergo_trap(\"out of memory\");\n"
"  }\n"
"  out->data = (char*)(out + 1);\n"
"  size_t n = 0;\n"
"  if (len > 0) n = fread(out->data, 1, len, f);\n"
"  fclose(f);\n"
"  if (n != len) {\n"
"    free(out);\n"
"    return EV_NULLV;\n"
"  }\n"
"  out->ref = 1;\n"
"  out->len = len;\n"
"  out->data[len] = 0;\n"
"  return EV_STR(out);\n"
"}\n"
"\n"
"static ErgoVal stdr_write_text_file(ErgoVal pathv, ErgoVal textv) {\n"
"  if (pathv.tag != EVT_STR) ergo_trap(\"write_text_file expects string path\");\n"
"  if (textv.tag != EVT_STR) ergo_trap(\"write_text_file expects string text\");\n"
"  ErgoStr* path = (ErgoStr*)pathv.as.p;\n"
"  ErgoStr* text = (ErgoStr*)textv.as.p;\n"
"  FILE* f = fopen(path->data, \"wb\");\n"
"  if (!f) return EV_BOOL(false);\n"
"  size_t n = 0;\n"
"  if (text->len > 0) n = fwrite(text->data, 1, text->len, f);\n"
"  bool ok = (n == text->len) && (fclose(f) == 0);\n"
"  return EV_BOOL(ok);\n"
"}\n"
"\n"
"static ErgoVal stdr_capture_shell_first_line(const char* cmd) {\n"
"  if (!cmd || !cmd[0]) return EV_NULLV;\n"
"#if defined(_WIN32)\n"
"  FILE* p = _popen(cmd, \"r\");\n"
"#else\n"
"  FILE* p = popen(cmd, \"r\");\n"
"#endif\n"
"  if (!p) return EV_NULLV;\n"
"  char buf[4096];\n"
"  if (!fgets(buf, sizeof(buf), p)) {\n"
"#if defined(_WIN32)\n"
"    _pclose(p);\n"
"#else\n"
"    pclose(p);\n"
"#endif\n"
"    return EV_NULLV;\n"
"  }\n"
"#if defined(_WIN32)\n"
"  _pclose(p);\n"
"#else\n"
"  pclose(p);\n"
"#endif\n"
"  size_t len = strlen(buf);\n"
"  while (len > 0 && (buf[len - 1] == '\\n' || buf[len - 1] == '\\r')) len--;\n"
"  if (len == 0) return EV_NULLV;\n"
"  return EV_STR(stdr_str_from_slice(buf, len));\n"
"}\n"
"\n"
"static ErgoVal stdr_open_file_dialog(ErgoVal promptv, ErgoVal extv) {\n"
"  if (promptv.tag != EVT_STR) ergo_trap(\"open_file_dialog expects prompt string\");\n"
"  if (extv.tag != EVT_STR) ergo_trap(\"open_file_dialog expects extension string\");\n"
"  ErgoStr* prompt = (ErgoStr*)promptv.as.p;\n"
"  ErgoStr* ext = (ErgoStr*)extv.as.p;\n"
"#if defined(__APPLE__)\n"
"  char cmd[8192];\n"
"  snprintf(cmd, sizeof(cmd),\n"
"           \"osascript -e 'set _p to POSIX path of (choose file of type {\\\"%s\\\"} with prompt \\\"%s\\\")' -e 'return _p' 2>/dev/null\",\n"
"           ext ? ext->data : \"\", prompt ? prompt->data : \"\");\n"
"  return stdr_capture_shell_first_line(cmd);\n"
"#else\n"
"  (void)prompt;\n"
"  (void)ext;\n"
"  return EV_NULLV;\n"
"#endif\n"
"}\n"
"\n"
"static ErgoVal stdr_save_file_dialog(ErgoVal promptv, ErgoVal default_namev, ErgoVal extv) {\n"
"  if (promptv.tag != EVT_STR) ergo_trap(\"save_file_dialog expects prompt string\");\n"
"  if (default_namev.tag != EVT_STR) ergo_trap(\"save_file_dialog expects default_name string\");\n"
"  if (extv.tag != EVT_STR) ergo_trap(\"save_file_dialog expects extension string\");\n"
"  ErgoStr* prompt = (ErgoStr*)promptv.as.p;\n"
"  ErgoStr* def = (ErgoStr*)default_namev.as.p;\n"
"  ErgoStr* ext = (ErgoStr*)extv.as.p;\n"
"#if defined(__APPLE__)\n"
"  char cmd[8192];\n"
"  snprintf(cmd, sizeof(cmd),\n"
"           \"osascript -e 'set _p to POSIX path of (choose file name with prompt \\\"%s\\\" default name \\\"%s\\\")' -e 'return _p' 2>/dev/null\",\n"
"           prompt ? prompt->data : \"\", def ? def->data : \"\");\n"
"  ErgoVal out = stdr_capture_shell_first_line(cmd);\n"
"  (void)ext;\n"
"  return out;\n"
"#else\n"
"  (void)prompt;\n"
"  (void)def;\n"
"  (void)ext;\n"
"  return EV_NULLV;\n"
"#endif\n"
"}\n"
"\n"
"static size_t stdr_find_sub(const char* s, size_t slen, const char* sub, size_t sublen, size_t start) {\n"
"  if (sublen == 0) return start;\n"
"  if (start > slen) return (size_t)-1;\n"
"  for (size_t i = start; i + sublen <= slen; i++) {\n"
"    if (memcmp(s + i, sub, sublen) == 0) return i;\n"
"  }\n"
"  return (size_t)-1;\n"
"}\n"
"\n"
"static void stdr_trim_span(const char* s, size_t len, size_t* out_start, size_t* out_len) {\n"
"  size_t a = 0;\n"
"  while (a < len && (s[a] == ' ' || s[a] == '\\t')) a++;\n"
"  size_t b = len;\n"
"  while (b > a && (s[b - 1] == ' ' || s[b - 1] == '\\t')) b--;\n"
"  *out_start = a;\n"
"  *out_len = b - a;\n"
"}\n"
"\n"
"static ErgoStr* stdr_str_from_slice(const char* s, size_t len) {\n"
"  ErgoStr* st = (ErgoStr*)malloc(sizeof(ErgoStr) + len + 1);\n"
"  if (!st) ergo_trap(\"out of memory\");\n"
"  st->ref = 1;\n"
"  st->len = len;\n"
"  st->data = (char*)(st + 1);\n"
"  if (len > 0) memcpy(st->data, s, len);\n"
"  st->data[len] = 0;\n"
"  return st;\n"
"}\n"
"\n"
"static int64_t stdr_parse_int_slice(const char* s, size_t len) {\n"
"  if (len == 0) return 0;\n"
"  char stack[64];\n"
"  char* tmp = (len < sizeof(stack)) ? stack : (char*)malloc(len + 1);\n"
"  if (!tmp) ergo_trap(\"out of memory\");\n"
"  memcpy(tmp, s, len);\n"
"  tmp[len] = 0;\n"
"  char* end = NULL;\n"
"  long long v = strtoll(tmp, &end, 10);\n"
"  if (tmp != stack) free(tmp);\n"
"  if (end == tmp) return 0;\n"
"  return (int64_t)v;\n"
"}\n"
"\n"
"static double stdr_parse_float_slice(const char* s, size_t len) {\n"
"  if (len == 0) return 0.0;\n"
"  char stack[64];\n"
"  char* tmp = (len < sizeof(stack)) ? stack : (char*)malloc(len + 1);\n"
"  if (!tmp) ergo_trap(\"out of memory\");\n"
"  memcpy(tmp, s, len);\n"
"  tmp[len] = 0;\n"
"  char* end = NULL;\n"
"  double v = strtod(tmp, &end);\n"
"  if (tmp != stack) free(tmp);\n"
"  if (end == tmp) return 0.0;\n"
"  return v;\n"
"}\n"
"\n"
"static bool stdr_parse_bool_slice(const char* s, size_t len) {\n"
"  if (len == 1) {\n"
"    if (s[0] == '1') return true;\n"
"    if (s[0] == '0') return false;\n"
"  }\n"
"  if (len == 4) {\n"
"    return ((s[0] == 't' || s[0] == 'T') &&\n"
"            (s[1] == 'r' || s[1] == 'R') &&\n"
"            (s[2] == 'u' || s[2] == 'U') &&\n"
"            (s[3] == 'e' || s[3] == 'E'));\n"
"  }\n"
"  return false;\n"
"}\n"
"\n"
"static ErgoVal stdr_readf_parse(ErgoVal fmt, ErgoVal line, ErgoVal args) {\n"
"  if (fmt.tag != EVT_STR) ergo_trap(\"readf expects string format\");\n"
"  if (line.tag != EVT_STR) ergo_trap(\"readf expects string input\");\n"
"  if (args.tag != EVT_ARR) ergo_trap(\"readf expects args tuple\");\n"
"\n"
"  ErgoStr* fs = (ErgoStr*)fmt.as.p;\n"
"  ErgoStr* ls = (ErgoStr*)line.as.p;\n"
"  ErgoArr* a = (ErgoArr*)args.as.p;\n"
"\n"
"  const char* f = fs->data;\n"
"  size_t flen = fs->len;\n"
"  const char* s = ls->data;\n"
"  size_t slen = ls->len;\n"
"\n"
"  int segs = 1;\n"
"  for (size_t i = 0; i + 1 < flen; i++) {\n"
"    if (f[i] == '{' && f[i + 1] == '}') {\n"
"      segs++;\n"
"      i++;\n"
"    }\n"
"  }\n"
"\n"
"  const char* stack_ptrs[16];\n"
"  size_t stack_lens[16];\n"
"  const char** seg_ptrs = (segs <= 16) ? stack_ptrs : (const char**)malloc(sizeof(char*) * segs);\n"
"  size_t* seg_lens = (segs <= 16) ? stack_lens : (size_t*)malloc(sizeof(size_t) * segs);\n"
"  if (!seg_ptrs || !seg_lens) ergo_trap(\"out of memory\");\n"
"\n"
"  size_t seg_start = 0;\n"
"  int seg_idx = 0;\n"
"  for (size_t i = 0; i + 1 < flen; i++) {\n"
"    if (f[i] == '{' && f[i + 1] == '}') {\n"
"      seg_ptrs[seg_idx] = f + seg_start;\n"
"      seg_lens[seg_idx] = i - seg_start;\n"
"      seg_idx++;\n"
"      i++;\n"
"      seg_start = i + 1;\n"
"    }\n"
"  }\n"
"  seg_ptrs[seg_idx] = f + seg_start;\n"
"  seg_lens[seg_idx] = flen - seg_start;\n"
"\n"
"  int placeholders = segs - 1;\n"
"\n"
"  size_t spos = 0;\n"
"  if (seg_lens[0] > 0) {\n"
"    size_t found = stdr_find_sub(s, slen, seg_ptrs[0], seg_lens[0], 0);\n"
"    if (found != (size_t)-1) spos = found + seg_lens[0];\n"
"  }\n"
"\n"
"  ErgoArr* out = stdr_arr_new((int)a->len);\n"
"\n"
"  for (size_t i = 0; i < a->len; i++) {\n"
"    size_t cap_start = spos;\n"
"    size_t cap_len = 0;\n"
"    if ((int)i < placeholders) {\n"
"      size_t found = stdr_find_sub(s, slen, seg_ptrs[i + 1], seg_lens[i + 1], spos);\n"
"      if (found == (size_t)-1) {\n"
"        cap_len = slen - spos;\n"
"        spos = slen;\n"
"      } else {\n"
"        cap_len = found - spos;\n"
"        spos = found + seg_lens[i + 1];\n"
"      }\n"
"    }\n"
"\n"
"    size_t trim_start = 0;\n"
"    size_t trim_len = cap_len;\n"
"    stdr_trim_span(s + cap_start, cap_len, &trim_start, &trim_len);\n"
"    const char* cap = (cap_len > 0) ? (s + cap_start + trim_start) : \"\";\n"
"\n"
"    ErgoVal hint = a->items[i];\n"
"    ErgoVal v;\n"
"    if (hint.tag == EVT_INT) {\n"
"      v = EV_INT(stdr_parse_int_slice(cap, trim_len));\n"
"    } else if (hint.tag == EVT_FLOAT) {\n"
"      v = EV_FLOAT(stdr_parse_float_slice(cap, trim_len));\n"
"    } else if (hint.tag == EVT_BOOL) {\n"
"      v = EV_BOOL(stdr_parse_bool_slice(cap, trim_len));\n"
"    } else if (hint.tag == EVT_STR) {\n"
"      v = EV_STR(stdr_str_from_slice(cap, trim_len));\n"
"    } else {\n"
"      v = EV_STR(stdr_str_from_slice(cap, trim_len));\n"
"    }\n"
"    ergo_arr_add(out, v);\n"
"  }\n"
"\n"
"  if (seg_ptrs != stack_ptrs) free(seg_ptrs);\n"
"  if (seg_lens != stack_lens) free(seg_lens);\n"
"\n"
"  return EV_ARR(out);\n"
"}\n"
"\n"
"static ErgoStr* stdr_to_string(ErgoVal v) {\n"
"  char buf[64];\n"
"  if (v.tag == EVT_NULL) return &ergo_static_null;\n"
"  if (v.tag == EVT_BOOL) return v.as.b ? &ergo_static_true : &ergo_static_false;\n"
"  if (v.tag == EVT_INT) {\n"
"    snprintf(buf, sizeof(buf), \"%lld\", (long long)v.as.i);\n"
"    return stdr_str_lit(buf);\n"
"  }\n"
"  if (v.tag == EVT_FLOAT) {\n"
"    snprintf(buf, sizeof(buf), \"%.6f\", v.as.f);\n"
"    return stdr_str_lit(buf);\n"
"  }\n"
"  if (v.tag == EVT_STR) {\n"
"    ergo_retain_val(v);\n"
"    return (ErgoStr*)v.as.p;\n"
"  }\n"
"  if (v.tag == EVT_ARR) return &ergo_static_array;\n"
"  if (v.tag == EVT_OBJ) return &ergo_static_object;\n"
"  if (v.tag == EVT_FN) return &ergo_static_function;\n"
"  return &ergo_static_unknown;\n"
"}\n"
"\n"
"static ErgoStr* stdr_str_from_parts(int n, ErgoVal* parts) {\n"
"  size_t total = 0;\n"
"  ErgoStr* stack_strs[16];\n"
"  ErgoStr** strs = (n <= 16) ? stack_strs : (ErgoStr**)malloc(sizeof(ErgoStr*) * (size_t)n);\n"
"  for (int i = 0; i < n; i++) {\n"
"    strs[i] = stdr_to_string(parts[i]);\n"
"    total += strs[i]->len;\n"
"  }\n"
"  ErgoStr* out = (ErgoStr*)malloc(sizeof(ErgoStr) + total + 1);\n"
"  out->ref = 1;\n"
"  out->len = total;\n"
"  out->data = (char*)(out + 1);\n"
"  size_t off = 0;\n"
"  for (int i = 0; i < n; i++) {\n"
"    memcpy(out->data + off, strs[i]->data, strs[i]->len);\n"
"    off += strs[i]->len;\n"
"    ergo_release_val(EV_STR(strs[i]));\n"
"  }\n"
"  out->data[total] = 0;\n"
"  if (strs != stack_strs) free(strs);\n"
"  return out;\n"
"}\n"
"\n"
"static void ergo_retain_val(ErgoVal v) {\n"
"  if (v.tag == EVT_STR) { int* r = &((ErgoStr*)v.as.p)->ref; if (*r != INT32_MAX) (*r)++; }\n"
"  else if (v.tag == EVT_ARR) ((ErgoArr*)v.as.p)->ref++;\n"
"  else if (v.tag == EVT_OBJ) ((ErgoObj*)v.as.p)->ref++;\n"
"  else if (v.tag == EVT_FN) ((ErgoFn*)v.as.p)->ref++;\n"
"}\n"
"\n"
"static void ergo_release_val(ErgoVal v) {\n"
"  if (v.tag == EVT_STR) {\n"
"    ErgoStr* s = (ErgoStr*)v.as.p;\n"
"    if (s->ref == INT32_MAX) return;\n"
"    if (--s->ref == 0) {\n"
"      if (s->data != (char*)(s + 1)) free(s->data);\n"
"      free(s);\n"
"    }\n"
"  } else if (v.tag == EVT_ARR) {\n"
"    ErgoArr* a = (ErgoArr*)v.as.p;\n"
"    if (--a->ref == 0) {\n"
"      for (size_t i = 0; i < a->len; i++) ergo_release_val(a->items[i]);\n"
"      free(a->items);\n"
"      free(a);\n"
"    }\n"
"  } else if (v.tag == EVT_OBJ) {\n"
"    ErgoObj* o = (ErgoObj*)v.as.p;\n"
"    if (--o->ref == 0) {\n"
"      if (o->drop) o->drop(o);\n"
"      free(o);\n"
"    }\n"
"  } else if (v.tag == EVT_FN) {\n"
"    ErgoFn* f = (ErgoFn*)v.as.p;\n"
"    if (--f->ref == 0) {\n"
"      if (f->env && f->env_size > 0) {\n"
"        ErgoVal* caps = (ErgoVal*)f->env;\n"
"        for (int i = 0; i < f->env_size; i++) ergo_release_val(caps[i]);\n"
"        free(f->env);\n"
"      }\n"
"      free(f);\n"
"    }\n"
"  }\n"
"}\n"
"\n"
"static ErgoVal ergo_move(ErgoVal* slot) {\n"
"  ErgoVal v = *slot;\n"
"  *slot = EV_NULLV;\n"
"  return v;\n"
"}\n"
"\n"
"static void ergo_move_into(ErgoVal* slot, ErgoVal v) {\n"
"  ergo_release_val(*slot);\n"
"  *slot = v;\n"
"}\n"
"\n"
"static int64_t ergo_as_int(ErgoVal v) {\n"
"  if (v.tag == EVT_INT) return v.as.i;\n"
"  if (v.tag == EVT_BOOL) return v.as.b ? 1 : 0;\n"
"  if (v.tag == EVT_FLOAT) return (int64_t)v.as.f;\n"
"  ergo_trap(\"type mismatch: expected int\");\n"
"  return 0;\n"
"}\n"
"\n"
"static double ergo_as_float(ErgoVal v) {\n"
"  if (v.tag == EVT_FLOAT) return v.as.f;\n"
"  if (v.tag == EVT_INT) return (double)v.as.i;\n"
"  ergo_trap(\"type mismatch: expected float\");\n"
"  return 0.0;\n"
"}\n"
"\n"
"static bool ergo_as_bool(ErgoVal v) {\n"
"  if (v.tag == EVT_BOOL) return v.as.b;\n"
"  if (v.tag == EVT_NULL) return false;\n"
"  if (v.tag == EVT_INT) return v.as.i != 0;\n"
"  if (v.tag == EVT_FLOAT) return v.as.f != 0.0;\n"
"  if (v.tag == EVT_STR) return ((ErgoStr*)v.as.p)->len != 0;\n"
"  if (v.tag == EVT_ARR) return ((ErgoArr*)v.as.p)->len != 0;\n"
"  return true;\n"
"}\n"
"\n"
"static ErgoVal ergo_add(ErgoVal a, ErgoVal b) {\n"
"  if (a.tag == EVT_FLOAT || b.tag == EVT_FLOAT) return EV_FLOAT(ergo_as_float(a) + ergo_as_float(b));\n"
"  return EV_INT(ergo_as_int(a) + ergo_as_int(b));\n"
"}\n"
"\n"
"static ErgoVal ergo_sub(ErgoVal a, ErgoVal b) {\n"
"  if (a.tag == EVT_FLOAT || b.tag == EVT_FLOAT) return EV_FLOAT(ergo_as_float(a) - ergo_as_float(b));\n"
"  return EV_INT(ergo_as_int(a) - ergo_as_int(b));\n"
"}\n"
"\n"
"static ErgoVal ergo_mul(ErgoVal a, ErgoVal b) {\n"
"  if (a.tag == EVT_FLOAT || b.tag == EVT_FLOAT) return EV_FLOAT(ergo_as_float(a) * ergo_as_float(b));\n"
"  return EV_INT(ergo_as_int(a) * ergo_as_int(b));\n"
"}\n"
"\n"
"static ErgoVal ergo_div(ErgoVal a, ErgoVal b) {\n"
"  if (a.tag == EVT_FLOAT || b.tag == EVT_FLOAT) return EV_FLOAT(ergo_as_float(a) / ergo_as_float(b));\n"
"  return EV_INT(ergo_as_int(a) / ergo_as_int(b));\n"
"}\n"
"\n"
"static ErgoVal ergo_mod(ErgoVal a, ErgoVal b) {\n"
"  if (a.tag == EVT_FLOAT || b.tag == EVT_FLOAT) ergo_trap(\"% expects integer\");\n"
"  return EV_INT(ergo_as_int(a) % ergo_as_int(b));\n"
"}\n"
"\n"
"static ErgoVal ergo_neg(ErgoVal a) {\n"
"  if (a.tag == EVT_FLOAT) return EV_FLOAT(-a.as.f);\n"
"  return EV_INT(-ergo_as_int(a));\n"
"}\n"
"\n"
"static ErgoVal ergo_eq(ErgoVal a, ErgoVal b) {\n"
"  if (a.tag != b.tag) return EV_BOOL(false);\n"
"  switch (a.tag) {\n"
"    case EVT_NULL: return EV_BOOL(true);\n"
"    case EVT_BOOL: return EV_BOOL(a.as.b == b.as.b);\n"
"    case EVT_INT: return EV_BOOL(a.as.i == b.as.i);\n"
"    case EVT_FLOAT: return EV_BOOL(a.as.f == b.as.f);\n"
"    case EVT_STR: {\n"
"      ErgoStr* sa = (ErgoStr*)a.as.p;\n"
"      ErgoStr* sb = (ErgoStr*)b.as.p;\n"
"      if (sa->len != sb->len) return EV_BOOL(false);\n"
"      return EV_BOOL(memcmp(sa->data, sb->data, sa->len) == 0);\n"
"    }\n"
"    default: return EV_BOOL(a.as.p == b.as.p);\n"
"  }\n"
"}\n"
"\n"
"static ErgoVal ergo_ne(ErgoVal a, ErgoVal b) {\n"
"  ErgoVal v = ergo_eq(a, b);\n"
"  return EV_BOOL(!v.as.b);\n"
"}\n"
"\n"
"static ErgoVal ergo_lt(ErgoVal a, ErgoVal b) { return EV_BOOL(ergo_as_float(a) < ergo_as_float(b)); }\n"
"static ErgoVal ergo_le(ErgoVal a, ErgoVal b) { return EV_BOOL(ergo_as_float(a) <= ergo_as_float(b)); }\n"
"static ErgoVal ergo_gt(ErgoVal a, ErgoVal b) { return EV_BOOL(ergo_as_float(a) > ergo_as_float(b)); }\n"
"static ErgoVal ergo_ge(ErgoVal a, ErgoVal b) { return EV_BOOL(ergo_as_float(a) >= ergo_as_float(b)); }\n"
"\n"
"static ErgoArr* stdr_arr_new(int n) {\n"
"  ErgoArr* a = (ErgoArr*)malloc(sizeof(ErgoArr));\n"
"  a->ref = 1;\n"
"  a->len = 0;\n"
"  a->cap = (n > 0) ? (size_t)n : 4;\n"
"  a->items = (ErgoVal*)malloc(sizeof(ErgoVal) * a->cap);\n"
"  return a;\n"
"}\n"
"\n"
"static void ergo_arr_add(ErgoArr* a, ErgoVal v) {\n"
"  if (a->len >= a->cap) {\n"
"    a->cap *= 2;\n"
"    a->items = (ErgoVal*)realloc(a->items, sizeof(ErgoVal) * a->cap);\n"
"  }\n"
"  a->items[a->len++] = v;\n"
"}\n"
"\n"
"static ErgoVal ergo_arr_get(ErgoArr* a, int64_t idx) {\n"
"  if (idx < 0 || (size_t)idx >= a->len) return EV_NULLV;\n"
"  ErgoVal v = a->items[idx];\n"
"  ergo_retain_val(v);\n"
"  return v;\n"
"}\n"
"\n"
"static void ergo_arr_set(ErgoArr* a, int64_t idx, ErgoVal v) {\n"
"  if (idx < 0 || (size_t)idx >= a->len) return;\n"
"  ergo_release_val(a->items[idx]);\n"
"  a->items[idx] = v;\n"
"}\n"
"\n"
"static ErgoVal ergo_arr_remove(ErgoArr* a, int64_t idx) {\n"
"  if (idx < 0 || (size_t)idx >= a->len) return EV_NULLV;\n"
"  ErgoVal v = a->items[idx];\n"
"  for (size_t i = (size_t)idx; i + 1 < a->len; i++) {\n"
"    a->items[i] = a->items[i + 1];\n"
"  }\n"
"  a->len--;\n"
"  return v;\n"
"}\n"
"\n"
"static ErgoObj* ergo_obj_new(size_t size, void (*drop)(ErgoObj*)) {\n"
"  ErgoObj* o = (ErgoObj*)malloc(size);\n"
"  o->ref = 1;\n"
"  o->drop = drop;\n"
"  return o;\n"
"}\n"
"\n"
"static ErgoFn* ergo_fn_new(ErgoVal (*fn)(void* env, int argc, ErgoVal* argv), int arity) {\n"
"  ErgoFn* f = (ErgoFn*)malloc(sizeof(ErgoFn));\n"
"  f->ref = 1;\n"
"  f->arity = arity;\n"
"  f->fn = fn;\n"
"  f->env = NULL;\n"
"  f->env_size = 0;\n"
"  return f;\n"
"}\n"
"\n"
"static ErgoFn* ergo_fn_new_with_env(ErgoVal (*fn)(void* env, int argc, ErgoVal* argv), int arity, void* env, int env_size) {\n"
"  ErgoFn* f = (ErgoFn*)malloc(sizeof(ErgoFn));\n"
"  f->ref = 1;\n"
"  f->arity = arity;\n"
"  f->fn = fn;\n"
"  f->env = env;\n"
"  f->env_size = env_size;\n"
"  return f;\n"
"}\n"
"\n"
"static ErgoVal ergo_call(ErgoVal fval, int argc, ErgoVal* argv) {\n"
"  if (fval.tag != EVT_FN) ergo_trap(\"call expects function\");\n"
"  ErgoFn* f = (ErgoFn*)fval.as.p;\n"
"  if (f->arity >= 0 && f->arity != argc) ergo_trap(\"arity mismatch\");\n"
"  return f->fn(f->env, argc, argv);\n"
"}\n"
"\n"
"// ---- Cogito GUI (shared library bindings) ----\n"
"// Injected by codegen when the program imports `cogito`.\n"
;
static const unsigned int ergo_runtime_embedded_len = (unsigned int)(sizeof(ergo_runtime_embedded) - 1);

#endif
