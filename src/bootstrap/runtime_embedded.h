#ifndef YIS_RUNTIME_EMBEDDED_H
#define YIS_RUNTIME_EMBEDDED_H

// Auto-generated snapshot of yis/src/runtime.inc with // @include expansion.
// Used as a fallback when runtime.inc is not available next to the yis binary.
// Regenerate with: yis/tools/gen_runtime_embedded.sh

static const char yis_runtime_embedded[] =
"// ---- Yis runtime (minimal) ----\n"
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <string.h>\n"
"#include <stdbool.h>\n"
"#include <stdint.h>\n"
"#include <stdarg.h>\n"
"#include <ctype.h>\n"
"#include <math.h>\n"
"#include <limits.h>\n"
"#include <time.h>\n"
"#include <sys/stat.h>\n"
"#if defined(__APPLE__)\n"
"#include <CoreGraphics/CoreGraphics.h>\n"
"#endif\n"
"\n"
"#if defined(_WIN32)\n"
"#include <windows.h>\n"
"#include <io.h>\n"
"#else\n"
"int isatty(int);\n"
"int fileno(FILE*);\n"
"#endif\n"
"\n"
"static int yis_stdout_isatty = 0;\n"
"\n"
"static int yis_argc = 0;\n"
"static char **yis_argv = NULL;\n"
"\n"
"void yis_set_args(int argc, char **argv) {\n"
"  yis_argc = argc;\n"
"  yis_argv = argv;\n"
"}\n"
"\n"
"#define COGITO_DEFINED_COGITO_DEBUG_ENABLED\n"
"static bool cogito_debug_enabled(void) { return false; }\n"
"static const char* cogito_font_path_active = NULL;\n"
"\n"
"static void yis_runtime_init(void) {\n"
"#if defined(__APPLE__)\n"
"  if (cogito_debug_enabled()) {\n"
"    fprintf(stderr, \"cogito: runtime_init\\n\");\n"
"    fflush(stderr);\n"
"  }\n"
"#endif\n"
"#if defined(_WIN32)\n"
"  yis_stdout_isatty = _isatty(_fileno(stdout));\n"
"#else\n"
"  yis_stdout_isatty = isatty(fileno(stdout));\n"
"#endif\n"
"  if (!yis_stdout_isatty) {\n"
"    setvbuf(stdout, NULL, _IOFBF, 1 << 16);\n"
"  }\n"
"}\n"
"\n"
"typedef enum {\n"
"  EVT_NULL,\n"
"  EVT_INT,\n"
"  EVT_FLOAT,\n"
"  EVT_BOOL,\n"
"  EVT_STR,\n"
"  EVT_ARR,\n"
"  EVT_DICT,\n"
"  EVT_OBJ,\n"
"  EVT_FN\n"
"} YisTag;\n"
"\n"
"typedef struct YisVal YisVal;\n"
"\n"
"typedef struct YisStr {\n"
"  int ref;\n"
"  size_t len;\n"
"  char* data;\n"
"} YisStr;\n"
"\n"
"typedef struct YisArr {\n"
"  int ref;\n"
"  size_t len;\n"
"  size_t cap;\n"
"  YisVal* items;\n"
"} YisArr;\n"
"\n"
"struct YisVal {\n"
"  YisTag tag;\n"
"  union {\n"
"    int64_t i;\n"
"    double f;\n"
"    bool b;\n"
"    void* p;\n"
"  } as;\n"
"};\n"
"\n"
"typedef struct YisDictEnt {\n"
"  YisStr* key;\n"
"  YisVal val;\n"
"} YisDictEnt;\n"
"\n"
"typedef struct YisDict {\n"
"  int ref;\n"
"  size_t len;\n"
"  size_t cap;\n"
"  YisDictEnt* entries;\n"
"} YisDict;\n"
"\n"
"typedef struct YisObj {\n"
"  int ref;\n"
"  void (*drop)(struct YisObj*);\n"
"} YisObj;\n"
"\n"
"typedef struct YisFn {\n"
"  int ref;\n"
"  int arity;\n"
"  YisVal (*fn)(void* env, int argc, YisVal* argv);\n"
"  void* env;\n"
"  int env_size;\n"
"} YisFn;\n"
"\n"
"static int stdr_len(YisVal v);\n"
"static int64_t stdr_num(YisVal v);\n"
"\n"
"#define YV_NULLV ((YisVal){.tag=EVT_NULL})\n"
"#define YV_INT(x) ((YisVal){.tag=EVT_INT, .as.i=(int64_t)(x)})\n"
"#define YV_FLOAT(x) ((YisVal){.tag=EVT_FLOAT, .as.f=(double)(x)})\n"
"#define YV_BOOL(x) ((YisVal){.tag=EVT_BOOL, .as.b=(x)?true:false})\n"
"#define YV_STR(x) ((YisVal){.tag=EVT_STR, .as.p=(x)})\n"
"#define YV_ARR(x) ((YisVal){.tag=EVT_ARR, .as.p=(x)})\n"
"#define YV_DICT(x) ((YisVal){.tag=EVT_DICT, .as.p=(x)})\n"
"#define YV_OBJ(x) ((YisVal){.tag=EVT_OBJ, .as.p=(x)})\n"
"#define YV_FN(x) ((YisVal){.tag=EVT_FN, .as.p=(x)})\n"
"\n"
"static void yis_trap(const char* msg) {\n"
"  fprintf(stderr, \"runtime error: %s\\n\", msg ? msg : \"unknown error\");\n"
"  fprintf(stderr, \"  (run with debugger for stack trace)\\n\");\n"
"  abort();\n"
"}\n"
"\n"
"static void yis_retain_val(YisVal v);\n"
"static void yis_release_val(YisVal v);\n"
"\n"
"// Static constant strings (ref=INT32_MAX means never freed)\n"
"static YisStr yis_static_empty    = { INT32_MAX, 0, \"\" };\n"
"static YisStr yis_static_null     = { INT32_MAX, 4, \"null\" };\n"
"static YisStr yis_static_true     = { INT32_MAX, 4, \"true\" };\n"
"static YisStr yis_static_false    = { INT32_MAX, 5, \"false\" };\n"
"static YisStr yis_static_array    = { INT32_MAX, 7, \"[array]\" };\n"
"static YisStr yis_static_dict     = { INT32_MAX, 6, \"[dict]\" };\n"
"static YisStr yis_static_object   = { INT32_MAX, 8, \"[object]\" };\n"
"static YisStr yis_static_function = { INT32_MAX, 10, \"[function]\" };\n"
"static YisStr yis_static_unknown  = { INT32_MAX, 3, \"<?>\" };\n"
"\n"
"static YisStr* stdr_str_lit(const char* s) {\n"
"  size_t n = strlen(s);\n"
"  YisStr* st = (YisStr*)malloc(sizeof(YisStr) + n + 1);\n"
"  st->ref = 1;\n"
"  st->len = n;\n"
"  st->data = (char*)(st + 1);\n"
"  memcpy(st->data, s, n + 1);\n"
"  return st;\n"
"}\n"
"\n"
"static YisStr* stdr_str_from_parts(int n, YisVal* parts);\n"
"static YisStr* stdr_to_string(YisVal v);\n"
"static YisStr* stdr_str_from_slice(const char* s, size_t len);\n"
"static YisArr* stdr_arr_new(int n);\n"
"static void yis_arr_add(YisArr* a, YisVal v);\n"
"static YisVal yis_arr_get(YisArr* a, int64_t idx);\n"
"static void yis_arr_set(YisArr* a, int64_t idx, YisVal v);\n"
"static YisVal yis_arr_remove(YisArr* a, int64_t idx);\n"
"\n"
"static YisDict* stdr_dict_new(void);\n"
"static void yis_dict_set(YisDict* d, YisVal key, YisVal val);\n"
"static YisVal yis_dict_get(YisDict* d, YisVal key);\n"
"static int yis_dict_len(YisDict* d);\n"
"\n"
"static YisVal stdr_str_at(YisVal v, int64_t idx) {\n"
"  if (v.tag != EVT_STR) yis_trap(\"str_at expects string\");\n"
"  YisStr* s = (YisStr*)v.as.p;\n"
"  if (idx < 0 || (size_t)idx >= s->len) return YV_STR(&yis_static_empty);\n"
"  return YV_STR(stdr_str_from_slice(s->data + idx, 1));\n"
"}\n"
"\n"
"static YisVal stdr_slice(YisVal sv, int64_t start, int64_t end) {\n"
"  if (sv.tag != EVT_STR) yis_trap(\"slice expects string\");\n"
"  YisStr* s = (YisStr*)sv.as.p;\n"
"  size_t len = s->len;\n"
"  if (start < 0) start = 0;\n"
"  if ((size_t)start > len) start = (int64_t)len;\n"
"  if (end < start) end = start;\n"
"  if ((size_t)end > len) end = (int64_t)len;\n"
"  size_t n = (size_t)(end - start);\n"
"  if (n == 0) return YV_STR(&yis_static_empty);\n"
"  return YV_STR(stdr_str_from_slice(s->data + start, n));\n"
"}\n"
"\n"
"static YisVal stdr_str_concat(YisVal a, YisVal b) {\n"
"  YisVal parts[2] = { a, b };\n"
"  return YV_STR(stdr_str_from_parts(2, parts));\n"
"}\n"
"\n"
"static int64_t stdr_char_code(YisVal cv) {\n"
"  if (cv.tag != EVT_STR) yis_trap(\"char_code expects string\");\n"
"  YisStr* s = (YisStr*)cv.as.p;\n"
"  if (s->len == 0) return 0;\n"
"  return (unsigned char)s->data[0];\n"
"}\n"
"\n"
"static int stdr_len(YisVal v) {\n"
"  if (v.tag == EVT_STR) return (int)((YisStr*)v.as.p)->len;\n"
"  if (v.tag == EVT_ARR) return (int)((YisArr*)v.as.p)->len;\n"
"  if (v.tag == EVT_DICT) return (int)((YisDict*)v.as.p)->len;\n"
"  return 0;\n"
"}\n"
"\n"
"static int64_t stdr_num(YisVal v) {\n"
"  if (v.tag == EVT_INT) return v.as.i;\n"
"  if (v.tag == EVT_BOOL) return v.as.b ? 1 : 0;\n"
"  if (v.tag == EVT_FLOAT) return (int64_t)v.as.f;\n"
"  if (v.tag == EVT_STR) {\n"
"    YisStr* s = (YisStr*)v.as.p;\n"
"    if (!s || !s->data || s->len == 0) return 0;\n"
"    return strtoll(s->data, NULL, 10);\n"
"  }\n"
"  return 0;\n"
"}\n"
"\n"
"static bool stdr_is_null(YisVal v) { return v.tag == EVT_NULL; }\n"
"\n"
"static void stdr_write(YisVal v) {\n"
"  YisStr* s = stdr_to_string(v);\n"
"  fwrite(s->data, 1, s->len, stdout);\n"
"  fflush(stdout);\n"
"  yis_release_val(YV_STR(s));\n"
"}\n"
"\n"
"static void writef(YisVal fmt, int argc, YisVal* argv) {\n"
"  if (fmt.tag != EVT_STR) yis_trap(\"writef expects string\");\n"
"  YisStr* s = (YisStr*)fmt.as.p;\n"
"  size_t i = 0;\n"
"  size_t seg = 0;\n"
"  int argi = 0;\n"
"  while (i < s->len) {\n"
"    if (i + 1 < s->len && s->data[i] == '{' && s->data[i + 1] == '}') {\n"
"      if (i > seg) fwrite(s->data + seg, 1, i - seg, stdout);\n"
"      if (argi < argc) {\n"
"        YisStr* ps = stdr_to_string(argv[argi++]);\n"
"        fwrite(ps->data, 1, ps->len, stdout);\n"
"        yis_release_val(YV_STR(ps));\n"
"      }\n"
"      i += 2;\n"
"      seg = i;\n"
"      continue;\n"
"    }\n"
"    i++;\n"
"  }\n"
"  if (i > seg) fwrite(s->data + seg, 1, i - seg, stdout);\n"
"  if (yis_stdout_isatty) fflush(stdout);\n"
"}\n"
"\n"
"static void stdr_writef_args(YisVal fmt, YisVal args) {\n"
"  if (args.tag != EVT_ARR) yis_trap(\"writef expects args tuple\");\n"
"  YisArr* a = (YisArr*)args.as.p;\n"
"  writef(fmt, (int)a->len, a->items);\n"
"}\n"
"\n"
"static YisStr* stdr_read_line(void) {\n"
"  size_t cap = 128;\n"
"  size_t len = 0;\n"
"  char* buf = (char*)malloc(cap);\n"
"  if (!buf) yis_trap(\"out of memory\");\n"
"  int c;\n"
"  while ((c = fgetc(stdin)) != EOF) {\n"
"    if (c == '\\n') break;\n"
"    if (len + 1 >= cap) {\n"
"      cap *= 2;\n"
"      buf = (char*)realloc(buf, cap);\n"
"      if (!buf) yis_trap(\"out of memory\");\n"
"    }\n"
"    buf[len++] = (char)c;\n"
"  }\n"
"  if (len > 0 && buf[len - 1] == '\\r') len--;\n"
"  YisStr* s = (YisStr*)malloc(sizeof(YisStr) + len + 1);\n"
"  if (!s) yis_trap(\"out of memory\");\n"
"  s->ref = 1;\n"
"  s->len = len;\n"
"  s->data = (char*)(s + 1);\n"
"  memcpy(s->data, buf, len);\n"
"  s->data[len] = 0;\n"
"  free(buf);\n"
"  return s;\n"
"}\n"
"\n"
"static YisVal stdr_read_text_file(YisVal pathv) {\n"
"  if (pathv.tag != EVT_STR) yis_trap(\"read_text_file expects string path\");\n"
"  YisStr* path = (YisStr*)pathv.as.p;\n"
"  FILE* f = fopen(path->data, \"rb\");\n"
"  if (!f) return YV_NULLV;\n"
"  if (fseek(f, 0, SEEK_END) != 0) {\n"
"    fclose(f);\n"
"    return YV_NULLV;\n"
"  }\n"
"  long sz = ftell(f);\n"
"  if (sz < 0) {\n"
"    fclose(f);\n"
"    return YV_NULLV;\n"
"  }\n"
"  if (fseek(f, 0, SEEK_SET) != 0) {\n"
"    fclose(f);\n"
"    return YV_NULLV;\n"
"  }\n"
"  size_t len = (size_t)sz;\n"
"  YisStr* out = (YisStr*)malloc(sizeof(YisStr) + len + 1);\n"
"  if (!out) {\n"
"    fclose(f);\n"
"    yis_trap(\"out of memory\");\n"
"  }\n"
"  out->data = (char*)(out + 1);\n"
"  size_t n = 0;\n"
"  if (len > 0) n = fread(out->data, 1, len, f);\n"
"  fclose(f);\n"
"  if (n != len) {\n"
"    free(out);\n"
"    return YV_NULLV;\n"
"  }\n"
"  out->ref = 1;\n"
"  out->len = len;\n"
"  out->data[len] = 0;\n"
"  return YV_STR(out);\n"
"}\n"
"\n"
"static YisVal stdr_write_text_file(YisVal pathv, YisVal textv) {\n"
"  if (pathv.tag != EVT_STR) yis_trap(\"write_text_file expects string path\");\n"
"  if (textv.tag != EVT_STR) yis_trap(\"write_text_file expects string text\");\n"
"  YisStr* path = (YisStr*)pathv.as.p;\n"
"  YisStr* text = (YisStr*)textv.as.p;\n"
"  FILE* f = fopen(path->data, \"wb\");\n"
"  if (!f) return YV_BOOL(false);\n"
"  size_t n = 0;\n"
"  if (text->len > 0) n = fwrite(text->data, 1, text->len, f);\n"
"  bool ok = (n == text->len) && (fclose(f) == 0);\n"
"  return YV_BOOL(ok);\n"
"}\n"
"\n"
"static YisVal stdr_run_command(YisVal cmdv) {\n"
"  if (cmdv.tag != EVT_STR) yis_trap(\"run_command expects string\");\n"
"  YisStr* cmd = (YisStr*)cmdv.as.p;\n"
"#if defined(_WIN32)\n"
"  FILE* p = _popen(cmd->data, \"r\");\n"
"#else\n"
"  FILE* p = popen(cmd->data, \"r\");\n"
"#endif\n"
"  if (!p) {\n"
"    YisArr* out = stdr_arr_new(2);\n"
"    yis_arr_add(out, YV_INT(-1));\n"
"    yis_arr_add(out, YV_STR(stdr_str_lit(\"\")));\n"
"    return YV_ARR(out);\n"
"  }\n"
"  size_t cap = 4096;\n"
"  size_t len = 0;\n"
"  char* buf = (char*)malloc(cap);\n"
"  if (!buf) {\n"
"#if defined(_WIN32)\n"
"    _pclose(p);\n"
"#else\n"
"    pclose(p);\n"
"#endif\n"
"    yis_trap(\"out of memory\");\n"
"  }\n"
"  int c;\n"
"  while ((c = fgetc(p)) != EOF) {\n"
"    if (len + 1 >= cap) {\n"
"      cap *= 2;\n"
"      char* n = (char*)realloc(buf, cap);\n"
"      if (!n) {\n"
"        free(buf);\n"
"#if defined(_WIN32)\n"
"        _pclose(p);\n"
"#else\n"
"        pclose(p);\n"
"#endif\n"
"        yis_trap(\"out of memory\");\n"
"      }\n"
"      buf = n;\n"
"    }\n"
"    buf[len++] = (char)c;\n"
"  }\n"
"  buf[len] = '\\0';\n"
"#if defined(_WIN32)\n"
"  int status = _pclose(p);\n"
"#else\n"
"  int status = pclose(p);\n"
"#endif\n"
"  YisStr* out_str = stdr_str_from_slice(buf, len);\n"
"  free(buf);\n"
"  YisArr* out = stdr_arr_new(2);\n"
"  yis_arr_add(out, YV_INT(status));\n"
"  yis_arr_add(out, YV_STR(out_str));\n"
"  return YV_ARR(out);\n"
"}\n"
"\n"
"static YisVal stdr_capture_shell_first_line(const char* cmd) {\n"
"  if (!cmd || !cmd[0]) return YV_NULLV;\n"
"#if defined(_WIN32)\n"
"  FILE* p = _popen(cmd, \"r\");\n"
"#else\n"
"  FILE* p = popen(cmd, \"r\");\n"
"#endif\n"
"  if (!p) return YV_NULLV;\n"
"  char buf[4096];\n"
"  if (!fgets(buf, sizeof(buf), p)) {\n"
"#if defined(_WIN32)\n"
"    _pclose(p);\n"
"#else\n"
"    pclose(p);\n"
"#endif\n"
"    return YV_NULLV;\n"
"  }\n"
"#if defined(_WIN32)\n"
"  _pclose(p);\n"
"#else\n"
"  pclose(p);\n"
"#endif\n"
"  size_t len = strlen(buf);\n"
"  while (len > 0 && (buf[len - 1] == '\\n' || buf[len - 1] == '\\r')) len--;\n"
"  if (len == 0) return YV_NULLV;\n"
"  return YV_STR(stdr_str_from_slice(buf, len));\n"
"}\n"
"\n"
"static YisVal stdr_open_file_dialog(YisVal promptv, YisVal extv) {\n"
"  if (promptv.tag != EVT_STR) yis_trap(\"open_file_dialog expects prompt string\");\n"
"  if (extv.tag != EVT_STR) yis_trap(\"open_file_dialog expects extension string\");\n"
"  YisStr* prompt = (YisStr*)promptv.as.p;\n"
"  YisStr* ext = (YisStr*)extv.as.p;\n"
"#if defined(__APPLE__)\n"
"  char cmd[8192];\n"
"  snprintf(cmd, sizeof(cmd),\n"
"           \"osascript -e 'set _p to POSIX path of (choose file of type {\\\"%s\\\"} with prompt \\\"%s\\\")' -e 'return _p' 2>/dev/null\",\n"
"           ext ? ext->data : \"\", prompt ? prompt->data : \"\");\n"
"  return stdr_capture_shell_first_line(cmd);\n"
"#else\n"
"  (void)prompt;\n"
"  (void)ext;\n"
"  return YV_NULLV;\n"
"#endif\n"
"}\n"
"\n"
"static YisVal stdr_save_file_dialog(YisVal promptv, YisVal default_namev, YisVal extv) {\n"
"  if (promptv.tag != EVT_STR) yis_trap(\"save_file_dialog expects prompt string\");\n"
"  if (default_namev.tag != EVT_STR) yis_trap(\"save_file_dialog expects default_name string\");\n"
"  if (extv.tag != EVT_STR) yis_trap(\"save_file_dialog expects extension string\");\n"
"  YisStr* prompt = (YisStr*)promptv.as.p;\n"
"  YisStr* def = (YisStr*)default_namev.as.p;\n"
"  YisStr* ext = (YisStr*)extv.as.p;\n"
"#if defined(__APPLE__)\n"
"  char cmd[8192];\n"
"  snprintf(cmd, sizeof(cmd),\n"
"           \"osascript -e 'set _p to POSIX path of (choose file name with prompt \\\"%s\\\" default name \\\"%s\\\")' -e 'return _p' 2>/dev/null\",\n"
"           prompt ? prompt->data : \"\", def ? def->data : \"\");\n"
"  YisVal out = stdr_capture_shell_first_line(cmd);\n"
"  (void)ext;\n"
"  return out;\n"
"#else\n"
"  (void)prompt;\n"
"  (void)def;\n"
"  (void)ext;\n"
"  return YV_NULLV;\n"
"#endif\n"
"}\n"
"\n"
"static size_t stdr_find_sub(const char* s, size_t slen, const char* sub, size_t sublen, size_t start) {\n"
"  if (sublen == 0) return start;\n"
"  if (start > slen) return (size_t)-1;\n"
"  for (size_t i = start; i + sublen <= slen; i++) {\n"
"    if (memcmp(s + i, sub, sublen) == 0) return i;\n"
"  }\n"
"  return (size_t)-1;\n"
"}\n"
"\n"
"static void stdr_trim_span(const char* s, size_t len, size_t* out_start, size_t* out_len) {\n"
"  size_t a = 0;\n"
"  while (a < len && (s[a] == ' ' || s[a] == '\\t')) a++;\n"
"  size_t b = len;\n"
"  while (b > a && (s[b - 1] == ' ' || s[b - 1] == '\\t')) b--;\n"
"  *out_start = a;\n"
"  *out_len = b - a;\n"
"}\n"
"\n"
"static YisStr* stdr_str_from_slice(const char* s, size_t len) {\n"
"  YisStr* st = (YisStr*)malloc(sizeof(YisStr) + len + 1);\n"
"  if (!st) yis_trap(\"out of memory\");\n"
"  st->ref = 1;\n"
"  st->len = len;\n"
"  st->data = (char*)(st + 1);\n"
"  if (len > 0) memcpy(st->data, s, len);\n"
"  st->data[len] = 0;\n"
"  return st;\n"
"}\n"
"\n"
"static YisVal stdr_args(void) {\n"
"  YisArr* a = stdr_arr_new(yis_argc > 0 ? yis_argc : 1);\n"
"  for (int i = 0; i < yis_argc; i++) {\n"
"    const char* s = yis_argv && yis_argv[i] ? yis_argv[i] : \"\";\n"
"    size_t len = strlen(s);\n"
"    yis_arr_add(a, YV_STR(stdr_str_from_slice(s, len)));\n"
"  }\n"
"  return YV_ARR(a);\n"
"}\n"
"\n"
"static int64_t stdr_parse_int_slice(const char* s, size_t len) {\n"
"  if (len == 0) return 0;\n"
"  char stack[64];\n"
"  char* tmp = (len < sizeof(stack)) ? stack : (char*)malloc(len + 1);\n"
"  if (!tmp) yis_trap(\"out of memory\");\n"
"  memcpy(tmp, s, len);\n"
"  tmp[len] = 0;\n"
"  char* end = NULL;\n"
"  long long v = strtoll(tmp, &end, 10);\n"
"  if (tmp != stack) free(tmp);\n"
"  if (end == tmp) return 0;\n"
"  return (int64_t)v;\n"
"}\n"
"\n"
"static double stdr_parse_float_slice(const char* s, size_t len) {\n"
"  if (len == 0) return 0.0;\n"
"  char stack[64];\n"
"  char* tmp = (len < sizeof(stack)) ? stack : (char*)malloc(len + 1);\n"
"  if (!tmp) yis_trap(\"out of memory\");\n"
"  memcpy(tmp, s, len);\n"
"  tmp[len] = 0;\n"
"  char* end = NULL;\n"
"  double v = strtod(tmp, &end);\n"
"  if (tmp != stack) free(tmp);\n"
"  if (end == tmp) return 0.0;\n"
"  return v;\n"
"}\n"
"\n"
"static bool stdr_parse_bool_slice(const char* s, size_t len) {\n"
"  if (len == 1) {\n"
"    if (s[0] == '1') return true;\n"
"    if (s[0] == '0') return false;\n"
"  }\n"
"  if (len == 4) {\n"
"    return ((s[0] == 't' || s[0] == 'T') &&\n"
"            (s[1] == 'r' || s[1] == 'R') &&\n"
"            (s[2] == 'u' || s[2] == 'U') &&\n"
"            (s[3] == 'e' || s[3] == 'E'));\n"
"  }\n"
"  return false;\n"
"}\n"
"\n"
"static YisVal stdr_readf_parse(YisVal fmt, YisVal line, YisVal args) {\n"
"  if (fmt.tag != EVT_STR) yis_trap(\"readf expects string format\");\n"
"  if (line.tag != EVT_STR) yis_trap(\"readf expects string input\");\n"
"  if (args.tag != EVT_ARR) yis_trap(\"readf expects args tuple\");\n"
"\n"
"  YisStr* fs = (YisStr*)fmt.as.p;\n"
"  YisStr* ls = (YisStr*)line.as.p;\n"
"  YisArr* a = (YisArr*)args.as.p;\n"
"\n"
"  const char* f = fs->data;\n"
"  size_t flen = fs->len;\n"
"  const char* s = ls->data;\n"
"  size_t slen = ls->len;\n"
"\n"
"  int segs = 1;\n"
"  for (size_t i = 0; i + 1 < flen; i++) {\n"
"    if (f[i] == '{' && f[i + 1] == '}') {\n"
"      segs++;\n"
"      i++;\n"
"    }\n"
"  }\n"
"\n"
"  const char* stack_ptrs[16];\n"
"  size_t stack_lens[16];\n"
"  const char** seg_ptrs = (segs <= 16) ? stack_ptrs : (const char**)malloc(sizeof(char*) * segs);\n"
"  size_t* seg_lens = (segs <= 16) ? stack_lens : (size_t*)malloc(sizeof(size_t) * segs);\n"
"  if (!seg_ptrs || !seg_lens) yis_trap(\"out of memory\");\n"
"\n"
"  size_t seg_start = 0;\n"
"  int seg_idx = 0;\n"
"  for (size_t i = 0; i + 1 < flen; i++) {\n"
"    if (f[i] == '{' && f[i + 1] == '}') {\n"
"      seg_ptrs[seg_idx] = f + seg_start;\n"
"      seg_lens[seg_idx] = i - seg_start;\n"
"      seg_idx++;\n"
"      i++;\n"
"      seg_start = i + 1;\n"
"    }\n"
"  }\n"
"  seg_ptrs[seg_idx] = f + seg_start;\n"
"  seg_lens[seg_idx] = flen - seg_start;\n"
"\n"
"  int placeholders = segs - 1;\n"
"\n"
"  size_t spos = 0;\n"
"  if (seg_lens[0] > 0) {\n"
"    size_t found = stdr_find_sub(s, slen, seg_ptrs[0], seg_lens[0], 0);\n"
"    if (found != (size_t)-1) spos = found + seg_lens[0];\n"
"  }\n"
"\n"
"  YisArr* out = stdr_arr_new((int)a->len);\n"
"\n"
"  for (size_t i = 0; i < a->len; i++) {\n"
"    size_t cap_start = spos;\n"
"    size_t cap_len = 0;\n"
"    if ((int)i < placeholders) {\n"
"      size_t found = stdr_find_sub(s, slen, seg_ptrs[i + 1], seg_lens[i + 1], spos);\n"
"      if (found == (size_t)-1) {\n"
"        cap_len = slen - spos;\n"
"        spos = slen;\n"
"      } else {\n"
"        cap_len = found - spos;\n"
"        spos = found + seg_lens[i + 1];\n"
"      }\n"
"    }\n"
"\n"
"    size_t trim_start = 0;\n"
"    size_t trim_len = cap_len;\n"
"    stdr_trim_span(s + cap_start, cap_len, &trim_start, &trim_len);\n"
"    const char* cap = (cap_len > 0) ? (s + cap_start + trim_start) : \"\";\n"
"\n"
"    YisVal hint = a->items[i];\n"
"    YisVal v;\n"
"    if (hint.tag == EVT_INT) {\n"
"      v = YV_INT(stdr_parse_int_slice(cap, trim_len));\n"
"    } else if (hint.tag == EVT_FLOAT) {\n"
"      v = YV_FLOAT(stdr_parse_float_slice(cap, trim_len));\n"
"    } else if (hint.tag == EVT_BOOL) {\n"
"      v = YV_BOOL(stdr_parse_bool_slice(cap, trim_len));\n"
"    } else if (hint.tag == EVT_STR) {\n"
"      v = YV_STR(stdr_str_from_slice(cap, trim_len));\n"
"    } else {\n"
"      v = YV_STR(stdr_str_from_slice(cap, trim_len));\n"
"    }\n"
"    yis_arr_add(out, v);\n"
"  }\n"
"\n"
"  if (seg_ptrs != stack_ptrs) free(seg_ptrs);\n"
"  if (seg_lens != stack_lens) free(seg_lens);\n"
"\n"
"  return YV_ARR(out);\n"
"}\n"
"\n"
"static YisStr* stdr_to_string(YisVal v) {\n"
"  char buf[64];\n"
"  if (v.tag == EVT_NULL) return &yis_static_null;\n"
"  if (v.tag == EVT_BOOL) return v.as.b ? &yis_static_true : &yis_static_false;\n"
"  if (v.tag == EVT_INT) {\n"
"    snprintf(buf, sizeof(buf), \"%lld\", (long long)v.as.i);\n"
"    return stdr_str_lit(buf);\n"
"  }\n"
"  if (v.tag == EVT_FLOAT) {\n"
"    snprintf(buf, sizeof(buf), \"%.6f\", v.as.f);\n"
"    return stdr_str_lit(buf);\n"
"  }\n"
"  if (v.tag == EVT_STR) {\n"
"    yis_retain_val(v);\n"
"    return (YisStr*)v.as.p;\n"
"  }\n"
"  if (v.tag == EVT_ARR) return &yis_static_array;\n"
"  if (v.tag == EVT_DICT) return &yis_static_dict;\n"
"  if (v.tag == EVT_OBJ) return &yis_static_object;\n"
"  if (v.tag == EVT_FN) return &yis_static_function;\n"
"  return &yis_static_unknown;\n"
"}\n"
"\n"
"static YisStr* stdr_str_from_parts(int n, YisVal* parts) {\n"
"  size_t total = 0;\n"
"  YisStr* stack_strs[16];\n"
"  YisStr** strs = (n <= 16) ? stack_strs : (YisStr**)malloc(sizeof(YisStr*) * (size_t)n);\n"
"  for (int i = 0; i < n; i++) {\n"
"    strs[i] = stdr_to_string(parts[i]);\n"
"    total += strs[i]->len;\n"
"  }\n"
"  YisStr* out = (YisStr*)malloc(sizeof(YisStr) + total + 1);\n"
"  out->ref = 1;\n"
"  out->len = total;\n"
"  out->data = (char*)(out + 1);\n"
"  size_t off = 0;\n"
"  for (int i = 0; i < n; i++) {\n"
"    memcpy(out->data + off, strs[i]->data, strs[i]->len);\n"
"    off += strs[i]->len;\n"
"    yis_release_val(YV_STR(strs[i]));\n"
"  }\n"
"  out->data[total] = 0;\n"
"  if (strs != stack_strs) free(strs);\n"
"  return out;\n"
"}\n"
"\n"
"static void yis_retain_val(YisVal v) {\n"
"  if (v.tag == EVT_STR) { int* r = &((YisStr*)v.as.p)->ref; if (*r != INT32_MAX) (*r)++; }\n"
"  else if (v.tag == EVT_ARR) ((YisArr*)v.as.p)->ref++;\n"
"  else if (v.tag == EVT_DICT) ((YisDict*)v.as.p)->ref++;\n"
"  else if (v.tag == EVT_OBJ) ((YisObj*)v.as.p)->ref++;\n"
"  else if (v.tag == EVT_FN) ((YisFn*)v.as.p)->ref++;\n"
"}\n"
"\n"
"static void yis_release_val(YisVal v) {\n"
"  if (v.tag == EVT_STR) {\n"
"    YisStr* s = (YisStr*)v.as.p;\n"
"    if (s->ref == INT32_MAX) return;\n"
"    if (--s->ref == 0) {\n"
"      if (s->data != (char*)(s + 1)) free(s->data);\n"
"      free(s);\n"
"    }\n"
"  } else if (v.tag == EVT_ARR) {\n"
"    YisArr* a = (YisArr*)v.as.p;\n"
"    if (--a->ref == 0) {\n"
"      for (size_t i = 0; i < a->len; i++) yis_release_val(a->items[i]);\n"
"      free(a->items);\n"
"      free(a);\n"
"    }\n"
"  } else if (v.tag == EVT_DICT) {\n"
"    YisDict* d = (YisDict*)v.as.p;\n"
"    if (--d->ref == 0) {\n"
"      for (size_t i = 0; i < d->len; i++) {\n"
"        yis_release_val(YV_STR(d->entries[i].key));\n"
"        yis_release_val(d->entries[i].val);\n"
"      }\n"
"      free(d->entries);\n"
"      free(d);\n"
"    }\n"
"  } else if (v.tag == EVT_OBJ) {\n"
"    YisObj* o = (YisObj*)v.as.p;\n"
"    if (--o->ref == 0) {\n"
"      if (o->drop) o->drop(o);\n"
"      free(o);\n"
"    }\n"
"  } else if (v.tag == EVT_FN) {\n"
"    YisFn* f = (YisFn*)v.as.p;\n"
"    if (--f->ref == 0) {\n"
"      if (f->env && f->env_size > 0) {\n"
"        YisVal* caps = (YisVal*)f->env;\n"
"        for (int i = 0; i < f->env_size; i++) yis_release_val(caps[i]);\n"
"        free(f->env);\n"
"      }\n"
"      free(f);\n"
"    }\n"
"  }\n"
"}\n"
"\n"
"static YisVal yis_move(YisVal* slot) {\n"
"  YisVal v = *slot;\n"
"  *slot = YV_NULLV;\n"
"  return v;\n"
"}\n"
"\n"
"static void yis_move_into(YisVal* slot, YisVal v) {\n"
"  yis_release_val(*slot);\n"
"  *slot = v;\n"
"}\n"
"\n"
"static int64_t yis_as_int(YisVal v) {\n"
"  if (v.tag == EVT_INT) return v.as.i;\n"
"  if (v.tag == EVT_BOOL) return v.as.b ? 1 : 0;\n"
"  if (v.tag == EVT_FLOAT) return (int64_t)v.as.f;\n"
"  if (v.tag == EVT_STR) {\n"
"    /* Coerce string to int when possible; otherwise 0 (avoids trap until codegen is fully audited) */\n"
"    YisStr *s = (YisStr*)v.as.p;\n"
"    if (s && s->len > 0 && s->len < 32) {\n"
"      char buf[32];\n"
"      memcpy(buf, s->data, s->len);\n"
"      buf[s->len] = '\\0';\n"
"      char *end = NULL;\n"
"      long x = strtol(buf, &end, 10);\n"
"      if (end && end == buf + (ptrdiff_t)s->len)\n"
"        return (int64_t)x;\n"
"    }\n"
"    return 0;\n"
"  }\n"
"  {\n"
"    const char *tag_name = \"?\";\n"
"    switch (v.tag) {\n"
"      case EVT_NULL: tag_name = \"null\"; break;\n"
"      case EVT_STR: tag_name = \"string\"; break;\n"
"      case EVT_ARR: tag_name = \"array\"; break;\n"
"      case EVT_DICT: tag_name = \"dict\"; break;\n"
"      case EVT_OBJ: tag_name = \"object\"; break;\n"
"      case EVT_FN: tag_name = \"function\"; break;\n"
"      default: tag_name = \"unknown\"; break;\n"
"    }\n"
"    char buf[80];\n"
"    snprintf(buf, sizeof(buf), \"type mismatch: expected int (got %s)\", tag_name);\n"
"    yis_trap(buf);\n"
"  }\n"
"  return 0;\n"
"}\n"
"\n"
"static double yis_as_float(YisVal v) {\n"
"  if (v.tag == EVT_FLOAT) return v.as.f;\n"
"  if (v.tag == EVT_INT) return (double)v.as.i;\n"
"  yis_trap(\"type mismatch: expected float\");\n"
"  return 0.0;\n"
"}\n"
"\n"
"static bool yis_as_bool(YisVal v) {\n"
"  if (v.tag == EVT_BOOL) return v.as.b;\n"
"  if (v.tag == EVT_NULL) return false;\n"
"  if (v.tag == EVT_INT) return v.as.i != 0;\n"
"  if (v.tag == EVT_FLOAT) return v.as.f != 0.0;\n"
"  if (v.tag == EVT_STR) return ((YisStr*)v.as.p)->len != 0;\n"
"  if (v.tag == EVT_ARR) return ((YisArr*)v.as.p)->len != 0;\n"
"  if (v.tag == EVT_DICT) return ((YisDict*)v.as.p)->len != 0;\n"
"  return true;\n"
"}\n"
"\n"
"static YisVal yis_add(YisVal a, YisVal b) {\n"
"  if (a.tag == EVT_FLOAT || b.tag == EVT_FLOAT) return YV_FLOAT(yis_as_float(a) + yis_as_float(b));\n"
"  return YV_INT(yis_as_int(a) + yis_as_int(b));\n"
"}\n"
"\n"
"static YisVal yis_sub(YisVal a, YisVal b) {\n"
"  if (a.tag == EVT_FLOAT || b.tag == EVT_FLOAT) return YV_FLOAT(yis_as_float(a) - yis_as_float(b));\n"
"  return YV_INT(yis_as_int(a) - yis_as_int(b));\n"
"}\n"
"\n"
"static YisVal yis_mul(YisVal a, YisVal b) {\n"
"  if (a.tag == EVT_FLOAT || b.tag == EVT_FLOAT) return YV_FLOAT(yis_as_float(a) * yis_as_float(b));\n"
"  return YV_INT(yis_as_int(a) * yis_as_int(b));\n"
"}\n"
"\n"
"static YisVal yis_div(YisVal a, YisVal b) {\n"
"  if (a.tag == EVT_FLOAT || b.tag == EVT_FLOAT) return YV_FLOAT(yis_as_float(a) / yis_as_float(b));\n"
"  return YV_INT(yis_as_int(a) / yis_as_int(b));\n"
"}\n"
"\n"
"static YisVal yis_mod(YisVal a, YisVal b) {\n"
"  if (a.tag == EVT_FLOAT || b.tag == EVT_FLOAT) yis_trap(\"% expects integer\");\n"
"  return YV_INT(yis_as_int(a) % yis_as_int(b));\n"
"}\n"
"\n"
"static YisVal yis_neg(YisVal a) {\n"
"  if (a.tag == EVT_FLOAT) return YV_FLOAT(-a.as.f);\n"
"  return YV_INT(-yis_as_int(a));\n"
"}\n"
"\n"
"static YisVal yis_eq(YisVal a, YisVal b) {\n"
"  if (a.tag != b.tag) return YV_BOOL(false);\n"
"  switch (a.tag) {\n"
"    case EVT_NULL: return YV_BOOL(true);\n"
"    case EVT_BOOL: return YV_BOOL(a.as.b == b.as.b);\n"
"    case EVT_INT: return YV_BOOL(a.as.i == b.as.i);\n"
"    case EVT_FLOAT: return YV_BOOL(a.as.f == b.as.f);\n"
"    case EVT_STR: {\n"
"      YisStr* sa = (YisStr*)a.as.p;\n"
"      YisStr* sb = (YisStr*)b.as.p;\n"
"      if (sa->len != sb->len) return YV_BOOL(false);\n"
"      return YV_BOOL(memcmp(sa->data, sb->data, sa->len) == 0);\n"
"    }\n"
"    default: return YV_BOOL(a.as.p == b.as.p);\n"
"  }\n"
"}\n"
"\n"
"static YisVal yis_ne(YisVal a, YisVal b) {\n"
"  YisVal v = yis_eq(a, b);\n"
"  return YV_BOOL(!v.as.b);\n"
"}\n"
"\n"
"static YisVal yis_lt(YisVal a, YisVal b) { return YV_BOOL(yis_as_float(a) < yis_as_float(b)); }\n"
"static YisVal yis_le(YisVal a, YisVal b) { return YV_BOOL(yis_as_float(a) <= yis_as_float(b)); }\n"
"static YisVal yis_gt(YisVal a, YisVal b) { return YV_BOOL(yis_as_float(a) > yis_as_float(b)); }\n"
"static YisVal yis_ge(YisVal a, YisVal b) { return YV_BOOL(yis_as_float(a) >= yis_as_float(b)); }\n"
"\n"
"static YisArr* stdr_arr_new(int n) {\n"
"  YisArr* a = (YisArr*)malloc(sizeof(YisArr));\n"
"  a->ref = 1;\n"
"  a->len = 0;\n"
"  a->cap = (n > 0) ? (size_t)n : 4;\n"
"  a->items = (YisVal*)malloc(sizeof(YisVal) * a->cap);\n"
"  return a;\n"
"}\n"
"\n"
"static void yis_arr_add(YisArr* a, YisVal v) {\n"
"  if (a->len >= a->cap) {\n"
"    a->cap *= 2;\n"
"    a->items = (YisVal*)realloc(a->items, sizeof(YisVal) * a->cap);\n"
"  }\n"
"  a->items[a->len++] = v;\n"
"}\n"
"\n"
"static YisVal stdr_array_concat(YisVal av, YisVal bv) {\n"
"  if (av.tag != EVT_ARR || bv.tag != EVT_ARR) yis_trap(\"concat expects two arrays\");\n"
"  YisArr* a = (YisArr*)av.as.p;\n"
"  YisArr* b = (YisArr*)bv.as.p;\n"
"  YisArr* out = stdr_arr_new((int)(a->len + b->len));\n"
"  for (size_t i = 0; i < a->len; i++) yis_arr_add(out, a->items[i]);\n"
"  for (size_t i = 0; i < b->len; i++) yis_arr_add(out, b->items[i]);\n"
"  return YV_ARR(out);\n"
"}\n"
"\n"
"static YisVal yis_arr_get(YisArr* a, int64_t idx) {\n"
"  if (!a) yis_trap(\"array index on null\");\n"
"  if (idx < 0 || (size_t)idx >= a->len) return YV_NULLV;\n"
"  YisVal v = a->items[idx];\n"
"  yis_retain_val(v);\n"
"  return v;\n"
"}\n"
"\n"
"static void yis_arr_set(YisArr* a, int64_t idx, YisVal v) {\n"
"  if (idx < 0) return;\n"
"  size_t uidx = (size_t)idx;\n"
"  if (uidx >= a->len) {\n"
"    if (uidx >= a->cap) {\n"
"      size_t new_cap = a->cap ? a->cap : 4;\n"
"      while (new_cap <= uidx) new_cap *= 2;\n"
"      a->items = (YisVal*)realloc(a->items, sizeof(YisVal) * new_cap);\n"
"      a->cap = new_cap;\n"
"    }\n"
"    for (size_t i = a->len; i < uidx; i++) a->items[i] = YV_NULLV;\n"
"    a->len = uidx + 1;\n"
"  }\n"
"  yis_release_val(a->items[uidx]);\n"
"  a->items[uidx] = v;\n"
"}\n"
"\n"
"static YisVal yis_arr_remove(YisArr* a, int64_t idx) {\n"
"  if (idx < 0 || (size_t)idx >= a->len) return YV_NULLV;\n"
"  YisVal v = a->items[idx];\n"
"  for (size_t i = (size_t)idx; i + 1 < a->len; i++) {\n"
"    a->items[i] = a->items[i + 1];\n"
"  }\n"
"  a->len--;\n"
"  return v;\n"
"}\n"
"\n"
"static int yis_str_cmp(YisStr* a, YisStr* b) {\n"
"  if (a->len != b->len) return (a->len > b->len) ? 1 : -1;\n"
"  return memcmp(a->data, b->data, a->len);\n"
"}\n"
"\n"
"static YisDict* stdr_dict_new(void) {\n"
"  YisDict* d = (YisDict*)malloc(sizeof(YisDict));\n"
"  d->ref = 1;\n"
"  d->len = 0;\n"
"  d->cap = 8;\n"
"  d->entries = (YisDictEnt*)malloc(sizeof(YisDictEnt) * d->cap);\n"
"  return d;\n"
"}\n"
"\n"
"static void yis_dict_set(YisDict* d, YisVal key, YisVal val) {\n"
"  if (key.tag != EVT_STR) yis_trap(\"dict key must be string\");\n"
"  YisStr* k = (YisStr*)key.as.p;\n"
"  for (size_t i = 0; i < d->len; i++) {\n"
"    if (yis_str_cmp(d->entries[i].key, k) == 0) {\n"
"      yis_release_val(d->entries[i].val);\n"
"      d->entries[i].val = val;\n"
"      return;\n"
"    }\n"
"  }\n"
"  if (d->len >= d->cap) {\n"
"    d->cap *= 2;\n"
"    d->entries = (YisDictEnt*)realloc(d->entries, sizeof(YisDictEnt) * d->cap);\n"
"  }\n"
"  yis_retain_val(key);\n"
"  yis_retain_val(val);\n"
"  d->entries[d->len].key = k;\n"
"  d->entries[d->len].val = val;\n"
"  d->len++;\n"
"}\n"
"\n"
"static YisVal yis_dict_get(YisDict* d, YisVal key) {\n"
"  if (!d) return YV_NULLV;\n"
"  if ((uintptr_t)d < 4096u) return YV_NULLV;\n"
"  if (key.tag != EVT_STR) return YV_NULLV;\n"
"  YisStr* k = (YisStr*)key.as.p;\n"
"  if (!k) return YV_NULLV;\n"
"  if ((uintptr_t)k < 4096u) return YV_NULLV;\n"
"  for (size_t i = 0; i < d->len; i++) {\n"
"    if (yis_str_cmp(d->entries[i].key, k) == 0) {\n"
"      YisVal v = d->entries[i].val;\n"
"      yis_retain_val(v);\n"
"      return v;\n"
"    }\n"
"  }\n"
"  return YV_NULLV;\n"
"}\n"
"\n"
"static int yis_dict_len(YisDict* d) {\n"
"  return (int)d->len;\n"
"}\n"
"\n"
"static YisObj* yis_obj_new(size_t size, void (*drop)(YisObj*)) {\n"
"  YisObj* o = (YisObj*)malloc(size);\n"
"  o->ref = 1;\n"
"  o->drop = drop;\n"
"  return o;\n"
"}\n"
"\n"
"static YisFn* yi_fn_new(YisVal (*fn)(void* env, int argc, YisVal* argv), int arity) {\n"
"  YisFn* f = (YisFn*)malloc(sizeof(YisFn));\n"
"  f->ref = 1;\n"
"  f->arity = arity;\n"
"  f->fn = fn;\n"
"  f->env = NULL;\n"
"  f->env_size = 0;\n"
"  return f;\n"
"}\n"
"\n"
"static YisFn* yi_fn_new_with_env(YisVal (*fn)(void* env, int argc, YisVal* argv), int arity, void* env, int env_size) {\n"
"  YisFn* f = (YisFn*)malloc(sizeof(YisFn));\n"
"  f->ref = 1;\n"
"  f->arity = arity;\n"
"  f->fn = fn;\n"
"  f->env = env;\n"
"  f->env_size = env_size;\n"
"  return f;\n"
"}\n"
"\n"
"static YisVal yis_call(YisVal fval, int argc, YisVal* argv) {\n"
"  if (fval.tag != EVT_FN) yis_trap(\"call expects function\");\n"
"  YisFn* f = (YisFn*)fval.as.p;\n"
"  if (f->arity >= 0 && f->arity != argc) yis_trap(\"arity mismatch\");\n"
"  return f->fn(f->env, argc, argv);\n"
"}\n"
"\n"
"// ---- Cogito GUI (shared library bindings) ----\n"
"// Injected by codegen when the program imports `cogito`.\n"
;
static const unsigned int yis_runtime_embedded_len = (unsigned int)(sizeof(yis_runtime_embedded) - 1);

#endif
