#ifndef ERGO_RUNTIME_EMBEDDED_H
#define ERGO_RUNTIME_EMBEDDED_H

// Auto-generated snapshot of ergo/src/runtime.inc with // @include expansion.
// Used as a fallback when runtime.inc is not available next to the ergo binary.
// Regenerate with: ergo/tools/gen_runtime_embedded.sh

static const char ergo_runtime_embedded[] =
"// ---- Ergo runtime (minimal) ----\n"
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <string.h>\n"
"#include <stdbool.h>\n"
"#include <stdint.h>\n"
"#include <stdarg.h>\n"
"#include <ctype.h>\n"
"#include <math.h>\n"
"#include <limits.h>\n"
"#include <time.h>\n"
"#include <sys/stat.h>\n"
"#if defined(__APPLE__)\n"
"#include <CoreGraphics/CoreGraphics.h>\n"
"#endif\n"
"#if defined(_WIN32)\n"
"#include <windows.h>\n"
"#include <io.h>\n"
"#else\n"
"int isatty(int);\n"
"int fileno(FILE*);\n"
"#endif\n"
"\n"
"static int ergo_stdout_isatty = 0;\n"
"\n"
"static bool cogito_debug_enabled(void);\n"
"static const char* cogito_font_path_active = NULL;\n"
"\n"
"static void ergo_runtime_init(void) {\n"
"#if defined(__APPLE__)\n"
"  if (cogito_debug_enabled()) {\n"
"    fprintf(stderr, \"cogito: runtime_init\\n\");\n"
"    fflush(stderr);\n"
"  }\n"
"#endif\n"
"#if defined(_WIN32)\n"
"  ergo_stdout_isatty = _isatty(_fileno(stdout));\n"
"#else\n"
"  ergo_stdout_isatty = isatty(fileno(stdout));\n"
"#endif\n"
"  if (!ergo_stdout_isatty) {\n"
"    setvbuf(stdout, NULL, _IOFBF, 1 << 16);\n"
"  }\n"
"}\n"
"\n"
"typedef enum {\n"
"  EVT_NULL,\n"
"  EVT_INT,\n"
"  EVT_FLOAT,\n"
"  EVT_BOOL,\n"
"  EVT_STR,\n"
"  EVT_ARR,\n"
"  EVT_OBJ,\n"
"  EVT_FN\n"
"} ErgoTag;\n"
"\n"
"typedef struct ErgoVal ErgoVal;\n"
"\n"
"typedef struct ErgoStr {\n"
"  int ref;\n"
"  size_t len;\n"
"  char* data;\n"
"} ErgoStr;\n"
"\n"
"typedef struct ErgoArr {\n"
"  int ref;\n"
"  size_t len;\n"
"  size_t cap;\n"
"  ErgoVal* items;\n"
"} ErgoArr;\n"
"\n"
"typedef struct ErgoObj {\n"
"  int ref;\n"
"  void (*drop)(struct ErgoObj*);\n"
"} ErgoObj;\n"
"\n"
"typedef struct ErgoFn {\n"
"  int ref;\n"
"  int arity;\n"
"  ErgoVal (*fn)(void* env, int argc, ErgoVal* argv);\n"
"  void* env;\n"
"  int env_size;\n"
"} ErgoFn;\n"
"\n"
"struct ErgoVal {\n"
"  ErgoTag tag;\n"
"  union {\n"
"    int64_t i;\n"
"    double f;\n"
"    bool b;\n"
"    void* p;\n"
"  } as;\n"
"};\n"
"\n"
"#define EV_NULLV ((ErgoVal){.tag=EVT_NULL})\n"
"#define EV_INT(x) ((ErgoVal){.tag=EVT_INT, .as.i=(int64_t)(x)})\n"
"#define EV_FLOAT(x) ((ErgoVal){.tag=EVT_FLOAT, .as.f=(double)(x)})\n"
"#define EV_BOOL(x) ((ErgoVal){.tag=EVT_BOOL, .as.b=(x)?true:false})\n"
"#define EV_STR(x) ((ErgoVal){.tag=EVT_STR, .as.p=(x)})\n"
"#define EV_ARR(x) ((ErgoVal){.tag=EVT_ARR, .as.p=(x)})\n"
"#define EV_OBJ(x) ((ErgoVal){.tag=EVT_OBJ, .as.p=(x)})\n"
"#define EV_FN(x) ((ErgoVal){.tag=EVT_FN, .as.p=(x)})\n"
"\n"
"static void ergo_trap(const char* msg) {\n"
"  fprintf(stderr, \"runtime error: %s\\n\", msg ? msg : \"unknown error\");\n"
"  fprintf(stderr, \"  (run with debugger for stack trace)\\n\");\n"
"  abort();\n"
"}\n"
"\n"
"static void ergo_retain_val(ErgoVal v);\n"
"static void ergo_release_val(ErgoVal v);\n"
"\n"
"// Static constant strings (ref=INT32_MAX means never freed)\n"
"static ErgoStr ergo_static_empty    = { INT32_MAX, 0, \"\" };\n"
"static ErgoStr ergo_static_null     = { INT32_MAX, 4, \"null\" };\n"
"static ErgoStr ergo_static_true     = { INT32_MAX, 4, \"true\" };\n"
"static ErgoStr ergo_static_false    = { INT32_MAX, 5, \"false\" };\n"
"static ErgoStr ergo_static_array    = { INT32_MAX, 7, \"[array]\" };\n"
"static ErgoStr ergo_static_object   = { INT32_MAX, 8, \"[object]\" };\n"
"static ErgoStr ergo_static_function = { INT32_MAX, 10, \"[function]\" };\n"
"static ErgoStr ergo_static_unknown  = { INT32_MAX, 3, \"<?>\" };\n"
"\n"
"static ErgoStr* stdr_str_lit(const char* s) {\n"
"  size_t n = strlen(s);\n"
"  ErgoStr* st = (ErgoStr*)malloc(sizeof(ErgoStr) + n + 1);\n"
"  st->ref = 1;\n"
"  st->len = n;\n"
"  st->data = (char*)(st + 1);\n"
"  memcpy(st->data, s, n + 1);\n"
"  return st;\n"
"}\n"
"\n"
"static ErgoStr* stdr_str_from_parts(int n, ErgoVal* parts);\n"
"static ErgoStr* stdr_to_string(ErgoVal v);\n"
"static ErgoStr* stdr_str_from_slice(const char* s, size_t len);\n"
"static ErgoArr* stdr_arr_new(int n);\n"
"static void ergo_arr_add(ErgoArr* a, ErgoVal v);\n"
"static ErgoVal ergo_arr_get(ErgoArr* a, int64_t idx);\n"
"static void ergo_arr_set(ErgoArr* a, int64_t idx, ErgoVal v);\n"
"static ErgoVal ergo_arr_remove(ErgoArr* a, int64_t idx);\n"
"\n"
"static ErgoVal stdr_str_at(ErgoVal v, int64_t idx) {\n"
"  if (v.tag != EVT_STR) ergo_trap(\"str_at expects string\");\n"
"  ErgoStr* s = (ErgoStr*)v.as.p;\n"
"  if (idx < 0 || (size_t)idx >= s->len) return EV_STR(&ergo_static_empty);\n"
"  return EV_STR(stdr_str_from_slice(s->data + idx, 1));\n"
"}\n"
"\n"
"static int stdr_len(ErgoVal v) {\n"
"  if (v.tag == EVT_STR) return (int)((ErgoStr*)v.as.p)->len;\n"
"  if (v.tag == EVT_ARR) return (int)((ErgoArr*)v.as.p)->len;\n"
"  return 0;\n"
"}\n"
"\n"
"static bool stdr_is_null(ErgoVal v) { return v.tag == EVT_NULL; }\n"
"\n"
"static void stdr_write(ErgoVal v) {\n"
"  ErgoStr* s = stdr_to_string(v);\n"
"  fwrite(s->data, 1, s->len, stdout);\n"
"  if (ergo_stdout_isatty) fflush(stdout);\n"
"  ergo_release_val(EV_STR(s));\n"
"}\n"
"\n"
"static void writef(ErgoVal fmt, int argc, ErgoVal* argv) {\n"
"  if (fmt.tag != EVT_STR) ergo_trap(\"writef expects string\");\n"
"  ErgoStr* s = (ErgoStr*)fmt.as.p;\n"
"  size_t i = 0;\n"
"  size_t seg = 0;\n"
"  int argi = 0;\n"
"  while (i < s->len) {\n"
"    if (i + 1 < s->len && s->data[i] == '{' && s->data[i + 1] == '}') {\n"
"      if (i > seg) fwrite(s->data + seg, 1, i - seg, stdout);\n"
"      if (argi < argc) {\n"
"        ErgoStr* ps = stdr_to_string(argv[argi++]);\n"
"        fwrite(ps->data, 1, ps->len, stdout);\n"
"        ergo_release_val(EV_STR(ps));\n"
"      }\n"
"      i += 2;\n"
"      seg = i;\n"
"      continue;\n"
"    }\n"
"    i++;\n"
"  }\n"
"  if (i > seg) fwrite(s->data + seg, 1, i - seg, stdout);\n"
"  if (ergo_stdout_isatty) fflush(stdout);\n"
"}\n"
"\n"
"static void stdr_writef_args(ErgoVal fmt, ErgoVal args) {\n"
"  if (args.tag != EVT_ARR) ergo_trap(\"writef expects args tuple\");\n"
"  ErgoArr* a = (ErgoArr*)args.as.p;\n"
"  writef(fmt, (int)a->len, a->items);\n"
"}\n"
"\n"
"static ErgoStr* stdr_read_line(void) {\n"
"  size_t cap = 128;\n"
"  size_t len = 0;\n"
"  char* buf = (char*)malloc(cap);\n"
"  if (!buf) ergo_trap(\"out of memory\");\n"
"  int c;\n"
"  while ((c = fgetc(stdin)) != EOF) {\n"
"    if (c == '\\n') break;\n"
"    if (len + 1 >= cap) {\n"
"      cap *= 2;\n"
"      buf = (char*)realloc(buf, cap);\n"
"      if (!buf) ergo_trap(\"out of memory\");\n"
"    }\n"
"    buf[len++] = (char)c;\n"
"  }\n"
"  if (len > 0 && buf[len - 1] == '\\r') len--;\n"
"  ErgoStr* s = (ErgoStr*)malloc(sizeof(ErgoStr) + len + 1);\n"
"  if (!s) ergo_trap(\"out of memory\");\n"
"  s->ref = 1;\n"
"  s->len = len;\n"
"  s->data = (char*)(s + 1);\n"
"  memcpy(s->data, buf, len);\n"
"  s->data[len] = 0;\n"
"  free(buf);\n"
"  return s;\n"
"}\n"
"\n"
"static ErgoVal stdr_read_text_file(ErgoVal pathv) {\n"
"  if (pathv.tag != EVT_STR) ergo_trap(\"read_text_file expects string path\");\n"
"  ErgoStr* path = (ErgoStr*)pathv.as.p;\n"
"  FILE* f = fopen(path->data, \"rb\");\n"
"  if (!f) return EV_NULLV;\n"
"  if (fseek(f, 0, SEEK_END) != 0) {\n"
"    fclose(f);\n"
"    return EV_NULLV;\n"
"  }\n"
"  long sz = ftell(f);\n"
"  if (sz < 0) {\n"
"    fclose(f);\n"
"    return EV_NULLV;\n"
"  }\n"
"  if (fseek(f, 0, SEEK_SET) != 0) {\n"
"    fclose(f);\n"
"    return EV_NULLV;\n"
"  }\n"
"  size_t len = (size_t)sz;\n"
"  ErgoStr* out = (ErgoStr*)malloc(sizeof(ErgoStr) + len + 1);\n"
"  if (!out) {\n"
"    fclose(f);\n"
"    ergo_trap(\"out of memory\");\n"
"  }\n"
"  out->data = (char*)(out + 1);\n"
"  size_t n = 0;\n"
"  if (len > 0) n = fread(out->data, 1, len, f);\n"
"  fclose(f);\n"
"  if (n != len) {\n"
"    free(out);\n"
"    return EV_NULLV;\n"
"  }\n"
"  out->ref = 1;\n"
"  out->len = len;\n"
"  out->data[len] = 0;\n"
"  return EV_STR(out);\n"
"}\n"
"\n"
"static ErgoVal stdr_write_text_file(ErgoVal pathv, ErgoVal textv) {\n"
"  if (pathv.tag != EVT_STR) ergo_trap(\"write_text_file expects string path\");\n"
"  if (textv.tag != EVT_STR) ergo_trap(\"write_text_file expects string text\");\n"
"  ErgoStr* path = (ErgoStr*)pathv.as.p;\n"
"  ErgoStr* text = (ErgoStr*)textv.as.p;\n"
"  FILE* f = fopen(path->data, \"wb\");\n"
"  if (!f) return EV_BOOL(false);\n"
"  size_t n = 0;\n"
"  if (text->len > 0) n = fwrite(text->data, 1, text->len, f);\n"
"  bool ok = (n == text->len) && (fclose(f) == 0);\n"
"  return EV_BOOL(ok);\n"
"}\n"
"\n"
"static ErgoVal stdr_capture_shell_first_line(const char* cmd) {\n"
"  if (!cmd || !cmd[0]) return EV_NULLV;\n"
"#if defined(_WIN32)\n"
"  FILE* p = _popen(cmd, \"r\");\n"
"#else\n"
"  FILE* p = popen(cmd, \"r\");\n"
"#endif\n"
"  if (!p) return EV_NULLV;\n"
"  char buf[4096];\n"
"  if (!fgets(buf, sizeof(buf), p)) {\n"
"#if defined(_WIN32)\n"
"    _pclose(p);\n"
"#else\n"
"    pclose(p);\n"
"#endif\n"
"    return EV_NULLV;\n"
"  }\n"
"#if defined(_WIN32)\n"
"  _pclose(p);\n"
"#else\n"
"  pclose(p);\n"
"#endif\n"
"  size_t len = strlen(buf);\n"
"  while (len > 0 && (buf[len - 1] == '\\n' || buf[len - 1] == '\\r')) len--;\n"
"  if (len == 0) return EV_NULLV;\n"
"  return EV_STR(stdr_str_from_slice(buf, len));\n"
"}\n"
"\n"
"static ErgoVal stdr_open_file_dialog(ErgoVal promptv, ErgoVal extv) {\n"
"  if (promptv.tag != EVT_STR) ergo_trap(\"open_file_dialog expects prompt string\");\n"
"  if (extv.tag != EVT_STR) ergo_trap(\"open_file_dialog expects extension string\");\n"
"  ErgoStr* prompt = (ErgoStr*)promptv.as.p;\n"
"  ErgoStr* ext = (ErgoStr*)extv.as.p;\n"
"#if defined(__APPLE__)\n"
"  char cmd[8192];\n"
"  snprintf(cmd, sizeof(cmd),\n"
"           \"osascript -e 'set _p to POSIX path of (choose file of type {\\\"%s\\\"} with prompt \\\"%s\\\")' -e 'return _p' 2>/dev/null\",\n"
"           ext ? ext->data : \"\", prompt ? prompt->data : \"\");\n"
"  return stdr_capture_shell_first_line(cmd);\n"
"#else\n"
"  (void)prompt;\n"
"  (void)ext;\n"
"  return EV_NULLV;\n"
"#endif\n"
"}\n"
"\n"
"static ErgoVal stdr_save_file_dialog(ErgoVal promptv, ErgoVal default_namev, ErgoVal extv) {\n"
"  if (promptv.tag != EVT_STR) ergo_trap(\"save_file_dialog expects prompt string\");\n"
"  if (default_namev.tag != EVT_STR) ergo_trap(\"save_file_dialog expects default_name string\");\n"
"  if (extv.tag != EVT_STR) ergo_trap(\"save_file_dialog expects extension string\");\n"
"  ErgoStr* prompt = (ErgoStr*)promptv.as.p;\n"
"  ErgoStr* def = (ErgoStr*)default_namev.as.p;\n"
"  ErgoStr* ext = (ErgoStr*)extv.as.p;\n"
"#if defined(__APPLE__)\n"
"  char cmd[8192];\n"
"  snprintf(cmd, sizeof(cmd),\n"
"           \"osascript -e 'set _p to POSIX path of (choose file name with prompt \\\"%s\\\" default name \\\"%s\\\")' -e 'return _p' 2>/dev/null\",\n"
"           prompt ? prompt->data : \"\", def ? def->data : \"\");\n"
"  ErgoVal out = stdr_capture_shell_first_line(cmd);\n"
"  (void)ext;\n"
"  return out;\n"
"#else\n"
"  (void)prompt;\n"
"  (void)def;\n"
"  (void)ext;\n"
"  return EV_NULLV;\n"
"#endif\n"
"}\n"
"\n"
"static size_t stdr_find_sub(const char* s, size_t slen, const char* sub, size_t sublen, size_t start) {\n"
"  if (sublen == 0) return start;\n"
"  if (start > slen) return (size_t)-1;\n"
"  for (size_t i = start; i + sublen <= slen; i++) {\n"
"    if (memcmp(s + i, sub, sublen) == 0) return i;\n"
"  }\n"
"  return (size_t)-1;\n"
"}\n"
"\n"
"static void stdr_trim_span(const char* s, size_t len, size_t* out_start, size_t* out_len) {\n"
"  size_t a = 0;\n"
"  while (a < len && (s[a] == ' ' || s[a] == '\\t')) a++;\n"
"  size_t b = len;\n"
"  while (b > a && (s[b - 1] == ' ' || s[b - 1] == '\\t')) b--;\n"
"  *out_start = a;\n"
"  *out_len = b - a;\n"
"}\n"
"\n"
"static ErgoStr* stdr_str_from_slice(const char* s, size_t len) {\n"
"  ErgoStr* st = (ErgoStr*)malloc(sizeof(ErgoStr) + len + 1);\n"
"  if (!st) ergo_trap(\"out of memory\");\n"
"  st->ref = 1;\n"
"  st->len = len;\n"
"  st->data = (char*)(st + 1);\n"
"  if (len > 0) memcpy(st->data, s, len);\n"
"  st->data[len] = 0;\n"
"  return st;\n"
"}\n"
"\n"
"static int64_t stdr_parse_int_slice(const char* s, size_t len) {\n"
"  if (len == 0) return 0;\n"
"  char stack[64];\n"
"  char* tmp = (len < sizeof(stack)) ? stack : (char*)malloc(len + 1);\n"
"  if (!tmp) ergo_trap(\"out of memory\");\n"
"  memcpy(tmp, s, len);\n"
"  tmp[len] = 0;\n"
"  char* end = NULL;\n"
"  long long v = strtoll(tmp, &end, 10);\n"
"  if (tmp != stack) free(tmp);\n"
"  if (end == tmp) return 0;\n"
"  return (int64_t)v;\n"
"}\n"
"\n"
"static double stdr_parse_float_slice(const char* s, size_t len) {\n"
"  if (len == 0) return 0.0;\n"
"  char stack[64];\n"
"  char* tmp = (len < sizeof(stack)) ? stack : (char*)malloc(len + 1);\n"
"  if (!tmp) ergo_trap(\"out of memory\");\n"
"  memcpy(tmp, s, len);\n"
"  tmp[len] = 0;\n"
"  char* end = NULL;\n"
"  double v = strtod(tmp, &end);\n"
"  if (tmp != stack) free(tmp);\n"
"  if (end == tmp) return 0.0;\n"
"  return v;\n"
"}\n"
"\n"
"static bool stdr_parse_bool_slice(const char* s, size_t len) {\n"
"  if (len == 1) {\n"
"    if (s[0] == '1') return true;\n"
"    if (s[0] == '0') return false;\n"
"  }\n"
"  if (len == 4) {\n"
"    return ((s[0] == 't' || s[0] == 'T') &&\n"
"            (s[1] == 'r' || s[1] == 'R') &&\n"
"            (s[2] == 'u' || s[2] == 'U') &&\n"
"            (s[3] == 'e' || s[3] == 'E'));\n"
"  }\n"
"  return false;\n"
"}\n"
"\n"
"static ErgoVal stdr_readf_parse(ErgoVal fmt, ErgoVal line, ErgoVal args) {\n"
"  if (fmt.tag != EVT_STR) ergo_trap(\"readf expects string format\");\n"
"  if (line.tag != EVT_STR) ergo_trap(\"readf expects string input\");\n"
"  if (args.tag != EVT_ARR) ergo_trap(\"readf expects args tuple\");\n"
"\n"
"  ErgoStr* fs = (ErgoStr*)fmt.as.p;\n"
"  ErgoStr* ls = (ErgoStr*)line.as.p;\n"
"  ErgoArr* a = (ErgoArr*)args.as.p;\n"
"\n"
"  const char* f = fs->data;\n"
"  size_t flen = fs->len;\n"
"  const char* s = ls->data;\n"
"  size_t slen = ls->len;\n"
"\n"
"  int segs = 1;\n"
"  for (size_t i = 0; i + 1 < flen; i++) {\n"
"    if (f[i] == '{' && f[i + 1] == '}') {\n"
"      segs++;\n"
"      i++;\n"
"    }\n"
"  }\n"
"\n"
"  const char* stack_ptrs[16];\n"
"  size_t stack_lens[16];\n"
"  const char** seg_ptrs = (segs <= 16) ? stack_ptrs : (const char**)malloc(sizeof(char*) * segs);\n"
"  size_t* seg_lens = (segs <= 16) ? stack_lens : (size_t*)malloc(sizeof(size_t) * segs);\n"
"  if (!seg_ptrs || !seg_lens) ergo_trap(\"out of memory\");\n"
"\n"
"  size_t seg_start = 0;\n"
"  int seg_idx = 0;\n"
"  for (size_t i = 0; i + 1 < flen; i++) {\n"
"    if (f[i] == '{' && f[i + 1] == '}') {\n"
"      seg_ptrs[seg_idx] = f + seg_start;\n"
"      seg_lens[seg_idx] = i - seg_start;\n"
"      seg_idx++;\n"
"      i++;\n"
"      seg_start = i + 1;\n"
"    }\n"
"  }\n"
"  seg_ptrs[seg_idx] = f + seg_start;\n"
"  seg_lens[seg_idx] = flen - seg_start;\n"
"\n"
"  int placeholders = segs - 1;\n"
"\n"
"  size_t spos = 0;\n"
"  if (seg_lens[0] > 0) {\n"
"    size_t found = stdr_find_sub(s, slen, seg_ptrs[0], seg_lens[0], 0);\n"
"    if (found != (size_t)-1) spos = found + seg_lens[0];\n"
"  }\n"
"\n"
"  ErgoArr* out = stdr_arr_new((int)a->len);\n"
"\n"
"  for (size_t i = 0; i < a->len; i++) {\n"
"    size_t cap_start = spos;\n"
"    size_t cap_len = 0;\n"
"    if ((int)i < placeholders) {\n"
"      size_t found = stdr_find_sub(s, slen, seg_ptrs[i + 1], seg_lens[i + 1], spos);\n"
"      if (found == (size_t)-1) {\n"
"        cap_len = slen - spos;\n"
"        spos = slen;\n"
"      } else {\n"
"        cap_len = found - spos;\n"
"        spos = found + seg_lens[i + 1];\n"
"      }\n"
"    }\n"
"\n"
"    size_t trim_start = 0;\n"
"    size_t trim_len = cap_len;\n"
"    stdr_trim_span(s + cap_start, cap_len, &trim_start, &trim_len);\n"
"    const char* cap = (cap_len > 0) ? (s + cap_start + trim_start) : \"\";\n"
"\n"
"    ErgoVal hint = a->items[i];\n"
"    ErgoVal v;\n"
"    if (hint.tag == EVT_INT) {\n"
"      v = EV_INT(stdr_parse_int_slice(cap, trim_len));\n"
"    } else if (hint.tag == EVT_FLOAT) {\n"
"      v = EV_FLOAT(stdr_parse_float_slice(cap, trim_len));\n"
"    } else if (hint.tag == EVT_BOOL) {\n"
"      v = EV_BOOL(stdr_parse_bool_slice(cap, trim_len));\n"
"    } else if (hint.tag == EVT_STR) {\n"
"      v = EV_STR(stdr_str_from_slice(cap, trim_len));\n"
"    } else {\n"
"      v = EV_STR(stdr_str_from_slice(cap, trim_len));\n"
"    }\n"
"    ergo_arr_add(out, v);\n"
"  }\n"
"\n"
"  if (seg_ptrs != stack_ptrs) free(seg_ptrs);\n"
"  if (seg_lens != stack_lens) free(seg_lens);\n"
"\n"
"  return EV_ARR(out);\n"
"}\n"
"\n"
"static ErgoStr* stdr_to_string(ErgoVal v) {\n"
"  char buf[64];\n"
"  if (v.tag == EVT_NULL) return &ergo_static_null;\n"
"  if (v.tag == EVT_BOOL) return v.as.b ? &ergo_static_true : &ergo_static_false;\n"
"  if (v.tag == EVT_INT) {\n"
"    snprintf(buf, sizeof(buf), \"%lld\", (long long)v.as.i);\n"
"    return stdr_str_lit(buf);\n"
"  }\n"
"  if (v.tag == EVT_FLOAT) {\n"
"    snprintf(buf, sizeof(buf), \"%.6f\", v.as.f);\n"
"    return stdr_str_lit(buf);\n"
"  }\n"
"  if (v.tag == EVT_STR) {\n"
"    ergo_retain_val(v);\n"
"    return (ErgoStr*)v.as.p;\n"
"  }\n"
"  if (v.tag == EVT_ARR) return &ergo_static_array;\n"
"  if (v.tag == EVT_OBJ) return &ergo_static_object;\n"
"  if (v.tag == EVT_FN) return &ergo_static_function;\n"
"  return &ergo_static_unknown;\n"
"}\n"
"\n"
"static ErgoStr* stdr_str_from_parts(int n, ErgoVal* parts) {\n"
"  size_t total = 0;\n"
"  ErgoStr* stack_strs[16];\n"
"  ErgoStr** strs = (n <= 16) ? stack_strs : (ErgoStr**)malloc(sizeof(ErgoStr*) * (size_t)n);\n"
"  for (int i = 0; i < n; i++) {\n"
"    strs[i] = stdr_to_string(parts[i]);\n"
"    total += strs[i]->len;\n"
"  }\n"
"  ErgoStr* out = (ErgoStr*)malloc(sizeof(ErgoStr) + total + 1);\n"
"  out->ref = 1;\n"
"  out->len = total;\n"
"  out->data = (char*)(out + 1);\n"
"  size_t off = 0;\n"
"  for (int i = 0; i < n; i++) {\n"
"    memcpy(out->data + off, strs[i]->data, strs[i]->len);\n"
"    off += strs[i]->len;\n"
"    ergo_release_val(EV_STR(strs[i]));\n"
"  }\n"
"  out->data[total] = 0;\n"
"  if (strs != stack_strs) free(strs);\n"
"  return out;\n"
"}\n"
"\n"
"static void ergo_retain_val(ErgoVal v) {\n"
"  if (v.tag == EVT_STR) { int* r = &((ErgoStr*)v.as.p)->ref; if (*r != INT32_MAX) (*r)++; }\n"
"  else if (v.tag == EVT_ARR) ((ErgoArr*)v.as.p)->ref++;\n"
"  else if (v.tag == EVT_OBJ) ((ErgoObj*)v.as.p)->ref++;\n"
"  else if (v.tag == EVT_FN) ((ErgoFn*)v.as.p)->ref++;\n"
"}\n"
"\n"
"static void ergo_release_val(ErgoVal v) {\n"
"  if (v.tag == EVT_STR) {\n"
"    ErgoStr* s = (ErgoStr*)v.as.p;\n"
"    if (s->ref == INT32_MAX) return;\n"
"    if (--s->ref == 0) {\n"
"      if (s->data != (char*)(s + 1)) free(s->data);\n"
"      free(s);\n"
"    }\n"
"  } else if (v.tag == EVT_ARR) {\n"
"    ErgoArr* a = (ErgoArr*)v.as.p;\n"
"    if (--a->ref == 0) {\n"
"      for (size_t i = 0; i < a->len; i++) ergo_release_val(a->items[i]);\n"
"      free(a->items);\n"
"      free(a);\n"
"    }\n"
"  } else if (v.tag == EVT_OBJ) {\n"
"    ErgoObj* o = (ErgoObj*)v.as.p;\n"
"    if (--o->ref == 0) {\n"
"      if (o->drop) o->drop(o);\n"
"      free(o);\n"
"    }\n"
"  } else if (v.tag == EVT_FN) {\n"
"    ErgoFn* f = (ErgoFn*)v.as.p;\n"
"    if (--f->ref == 0) {\n"
"      if (f->env && f->env_size > 0) {\n"
"        ErgoVal* caps = (ErgoVal*)f->env;\n"
"        for (int i = 0; i < f->env_size; i++) ergo_release_val(caps[i]);\n"
"        free(f->env);\n"
"      }\n"
"      free(f);\n"
"    }\n"
"  }\n"
"}\n"
"\n"
"static ErgoVal ergo_move(ErgoVal* slot) {\n"
"  ErgoVal v = *slot;\n"
"  *slot = EV_NULLV;\n"
"  return v;\n"
"}\n"
"\n"
"static void ergo_move_into(ErgoVal* slot, ErgoVal v) {\n"
"  ergo_release_val(*slot);\n"
"  *slot = v;\n"
"}\n"
"\n"
"static int64_t ergo_as_int(ErgoVal v) {\n"
"  if (v.tag == EVT_INT) return v.as.i;\n"
"  if (v.tag == EVT_BOOL) return v.as.b ? 1 : 0;\n"
"  if (v.tag == EVT_FLOAT) return (int64_t)v.as.f;\n"
"  ergo_trap(\"type mismatch: expected int\");\n"
"  return 0;\n"
"}\n"
"\n"
"static double ergo_as_float(ErgoVal v) {\n"
"  if (v.tag == EVT_FLOAT) return v.as.f;\n"
"  if (v.tag == EVT_INT) return (double)v.as.i;\n"
"  ergo_trap(\"type mismatch: expected float\");\n"
"  return 0.0;\n"
"}\n"
"\n"
"static bool ergo_as_bool(ErgoVal v) {\n"
"  if (v.tag == EVT_BOOL) return v.as.b;\n"
"  if (v.tag == EVT_NULL) return false;\n"
"  if (v.tag == EVT_INT) return v.as.i != 0;\n"
"  if (v.tag == EVT_FLOAT) return v.as.f != 0.0;\n"
"  if (v.tag == EVT_STR) return ((ErgoStr*)v.as.p)->len != 0;\n"
"  if (v.tag == EVT_ARR) return ((ErgoArr*)v.as.p)->len != 0;\n"
"  return true;\n"
"}\n"
"\n"
"static ErgoVal ergo_add(ErgoVal a, ErgoVal b) {\n"
"  if (a.tag == EVT_FLOAT || b.tag == EVT_FLOAT) return EV_FLOAT(ergo_as_float(a) + ergo_as_float(b));\n"
"  return EV_INT(ergo_as_int(a) + ergo_as_int(b));\n"
"}\n"
"\n"
"static ErgoVal ergo_sub(ErgoVal a, ErgoVal b) {\n"
"  if (a.tag == EVT_FLOAT || b.tag == EVT_FLOAT) return EV_FLOAT(ergo_as_float(a) - ergo_as_float(b));\n"
"  return EV_INT(ergo_as_int(a) - ergo_as_int(b));\n"
"}\n"
"\n"
"static ErgoVal ergo_mul(ErgoVal a, ErgoVal b) {\n"
"  if (a.tag == EVT_FLOAT || b.tag == EVT_FLOAT) return EV_FLOAT(ergo_as_float(a) * ergo_as_float(b));\n"
"  return EV_INT(ergo_as_int(a) * ergo_as_int(b));\n"
"}\n"
"\n"
"static ErgoVal ergo_div(ErgoVal a, ErgoVal b) {\n"
"  if (a.tag == EVT_FLOAT || b.tag == EVT_FLOAT) return EV_FLOAT(ergo_as_float(a) / ergo_as_float(b));\n"
"  return EV_INT(ergo_as_int(a) / ergo_as_int(b));\n"
"}\n"
"\n"
"static ErgoVal ergo_mod(ErgoVal a, ErgoVal b) {\n"
"  if (a.tag == EVT_FLOAT || b.tag == EVT_FLOAT) ergo_trap(\"% expects integer\");\n"
"  return EV_INT(ergo_as_int(a) % ergo_as_int(b));\n"
"}\n"
"\n"
"static ErgoVal ergo_neg(ErgoVal a) {\n"
"  if (a.tag == EVT_FLOAT) return EV_FLOAT(-a.as.f);\n"
"  return EV_INT(-ergo_as_int(a));\n"
"}\n"
"\n"
"static ErgoVal ergo_eq(ErgoVal a, ErgoVal b) {\n"
"  if (a.tag != b.tag) return EV_BOOL(false);\n"
"  switch (a.tag) {\n"
"    case EVT_NULL: return EV_BOOL(true);\n"
"    case EVT_BOOL: return EV_BOOL(a.as.b == b.as.b);\n"
"    case EVT_INT: return EV_BOOL(a.as.i == b.as.i);\n"
"    case EVT_FLOAT: return EV_BOOL(a.as.f == b.as.f);\n"
"    case EVT_STR: {\n"
"      ErgoStr* sa = (ErgoStr*)a.as.p;\n"
"      ErgoStr* sb = (ErgoStr*)b.as.p;\n"
"      if (sa->len != sb->len) return EV_BOOL(false);\n"
"      return EV_BOOL(memcmp(sa->data, sb->data, sa->len) == 0);\n"
"    }\n"
"    default: return EV_BOOL(a.as.p == b.as.p);\n"
"  }\n"
"}\n"
"\n"
"static ErgoVal ergo_ne(ErgoVal a, ErgoVal b) {\n"
"  ErgoVal v = ergo_eq(a, b);\n"
"  return EV_BOOL(!v.as.b);\n"
"}\n"
"\n"
"static ErgoVal ergo_lt(ErgoVal a, ErgoVal b) { return EV_BOOL(ergo_as_float(a) < ergo_as_float(b)); }\n"
"static ErgoVal ergo_le(ErgoVal a, ErgoVal b) { return EV_BOOL(ergo_as_float(a) <= ergo_as_float(b)); }\n"
"static ErgoVal ergo_gt(ErgoVal a, ErgoVal b) { return EV_BOOL(ergo_as_float(a) > ergo_as_float(b)); }\n"
"static ErgoVal ergo_ge(ErgoVal a, ErgoVal b) { return EV_BOOL(ergo_as_float(a) >= ergo_as_float(b)); }\n"
"\n"
"static ErgoArr* stdr_arr_new(int n) {\n"
"  ErgoArr* a = (ErgoArr*)malloc(sizeof(ErgoArr));\n"
"  a->ref = 1;\n"
"  a->len = 0;\n"
"  a->cap = (n > 0) ? (size_t)n : 4;\n"
"  a->items = (ErgoVal*)malloc(sizeof(ErgoVal) * a->cap);\n"
"  return a;\n"
"}\n"
"\n"
"static void ergo_arr_add(ErgoArr* a, ErgoVal v) {\n"
"  if (a->len >= a->cap) {\n"
"    a->cap *= 2;\n"
"    a->items = (ErgoVal*)realloc(a->items, sizeof(ErgoVal) * a->cap);\n"
"  }\n"
"  a->items[a->len++] = v;\n"
"}\n"
"\n"
"static ErgoVal ergo_arr_get(ErgoArr* a, int64_t idx) {\n"
"  if (idx < 0 || (size_t)idx >= a->len) return EV_NULLV;\n"
"  ErgoVal v = a->items[idx];\n"
"  ergo_retain_val(v);\n"
"  return v;\n"
"}\n"
"\n"
"static void ergo_arr_set(ErgoArr* a, int64_t idx, ErgoVal v) {\n"
"  if (idx < 0 || (size_t)idx >= a->len) return;\n"
"  ergo_release_val(a->items[idx]);\n"
"  a->items[idx] = v;\n"
"}\n"
"\n"
"static ErgoVal ergo_arr_remove(ErgoArr* a, int64_t idx) {\n"
"  if (idx < 0 || (size_t)idx >= a->len) return EV_NULLV;\n"
"  ErgoVal v = a->items[idx];\n"
"  for (size_t i = (size_t)idx; i + 1 < a->len; i++) {\n"
"    a->items[i] = a->items[i + 1];\n"
"  }\n"
"  a->len--;\n"
"  return v;\n"
"}\n"
"\n"
"static ErgoObj* ergo_obj_new(size_t size, void (*drop)(ErgoObj*)) {\n"
"  ErgoObj* o = (ErgoObj*)malloc(size);\n"
"  o->ref = 1;\n"
"  o->drop = drop;\n"
"  return o;\n"
"}\n"
"\n"
"static ErgoFn* ergo_fn_new(ErgoVal (*fn)(void* env, int argc, ErgoVal* argv), int arity) {\n"
"  ErgoFn* f = (ErgoFn*)malloc(sizeof(ErgoFn));\n"
"  f->ref = 1;\n"
"  f->arity = arity;\n"
"  f->fn = fn;\n"
"  f->env = NULL;\n"
"  f->env_size = 0;\n"
"  return f;\n"
"}\n"
"\n"
"static ErgoFn* ergo_fn_new_with_env(ErgoVal (*fn)(void* env, int argc, ErgoVal* argv), int arity, void* env, int env_size) {\n"
"  ErgoFn* f = (ErgoFn*)malloc(sizeof(ErgoFn));\n"
"  f->ref = 1;\n"
"  f->arity = arity;\n"
"  f->fn = fn;\n"
"  f->env = env;\n"
"  f->env_size = env_size;\n"
"  return f;\n"
"}\n"
"\n"
"static ErgoVal ergo_call(ErgoVal fval, int argc, ErgoVal* argv) {\n"
"  if (fval.tag != EVT_FN) ergo_trap(\"call expects function\");\n"
"  ErgoFn* f = (ErgoFn*)fval.as.p;\n"
"  if (f->arity >= 0 && f->arity != argc) ergo_trap(\"arity mismatch\");\n"
"  return f->fn(f->env, argc, argv);\n"
"}\n"
"\n"
"// ---- Cogito GUI (shared library bindings) ----\n"
"// ---- Cogito bindings (shared library) ----\n"
"#include <cogito.h>\n"
"\n"
"#undef cogito_app_new\n"
"#undef cogito_app_free\n"
"#undef cogito_app_run\n"
"#undef cogito_app_set_appid\n"
"#undef cogito_app_set_app_name\n"
"#undef cogito_app_set_accent_color\n"
"#undef cogito_app_set_icon\n"
"#undef cogito_app_get_icon\n"
"#undef cogito_open_url\n"
"#undef cogito_window_new\n"
"#undef cogito_window_free\n"
"#undef cogito_window_set_resizable\n"
"#undef cogito_window_set_autosize\n"
"#undef cogito_window_set_a11y_label\n"
"#undef cogito_window_set_builder\n"
"#undef cogito_rebuild_active_window\n"
"#undef cogito_node_new\n"
"#undef cogito_grid_new_with_cols\n"
"#undef cogito_label_new\n"
"#undef cogito_button_new\n"
"#undef cogito_iconbtn_new\n"
"#undef cogito_checkbox_new\n"
"#undef cogito_switch_new\n"
"#undef cogito_textfield_new\n"
"#undef cogito_textview_new\n"
"#undef cogito_searchfield_new\n"
"#undef cogito_dropdown_new\n"
"#undef cogito_slider_new\n"
"#undef cogito_slider_range_new\n"
"#undef cogito_tabs_new\n"
"#undef cogito_view_switcher_new\n"
"#undef cogito_progress_new\n"
"#undef cogito_datepicker_new\n"
"#undef cogito_colorpicker_new\n"
"#undef cogito_stepper_new\n"
"#undef cogito_segmented_new\n"
"#undef cogito_treeview_new\n"
"#undef cogito_toasts_new\n"
"#undef cogito_toast_new\n"
"#undef cogito_bottom_toolbar_new\n"
"#undef cogito_dialog_new\n"
"#undef cogito_dialog_slot_new\n"
"#undef cogito_appbar_new\n"
"#undef cogito_image_new\n"
"#undef cogito_node_add\n"
"#undef cogito_node_remove\n"
"#undef cogito_node_free\n"
"#undef cogito_node_set_margins\n"
"#undef cogito_node_set_padding\n"
"#undef cogito_node_set_align\n"
"#undef cogito_node_set_halign\n"
"#undef cogito_node_set_valign\n"
"#undef cogito_node_set_id\n"
"#undef cogito_node_set_text\n"
"#undef cogito_node_get_text\n"
"#undef cogito_node_set_disabled\n"
"#undef cogito_node_set_editable\n"
"#undef cogito_node_get_editable\n"
"#undef cogito_node_set_class\n"
"#undef cogito_node_set_a11y_label\n"
"#undef cogito_node_set_a11y_role\n"
"#undef cogito_node_set_tooltip\n"
"#undef cogito_node_build\n"
"#undef cogito_node_on_click\n"
"#undef cogito_node_on_change\n"
"#undef cogito_node_on_select\n"
"#undef cogito_node_on_activate\n"
"#undef cogito_pointer_capture\n"
"#undef cogito_pointer_release\n"
"#undef cogito_dropdown_set_items\n"
"#undef cogito_dropdown_get_selected\n"
"#undef cogito_dropdown_set_selected\n"
"#undef cogito_tabs_set_items\n"
"#undef cogito_tabs_set_ids\n"
"#undef cogito_tabs_get_selected\n"
"#undef cogito_tabs_set_selected\n"
"#undef cogito_tabs_bind\n"
"#undef cogito_slider_get_value\n"
"#undef cogito_slider_set_value\n"
"#undef cogito_slider_set_size\n"
"#undef cogito_slider_get_size\n"
"#undef cogito_slider_set_icon\n"
"#undef cogito_slider_get_centered\n"
"#undef cogito_slider_set_centered\n"
"#undef cogito_slider_set_range\n"
"#undef cogito_slider_set_range_start\n"
"#undef cogito_slider_set_range_end\n"
"#undef cogito_slider_get_range_start\n"
"#undef cogito_slider_get_range_end\n"
"#undef cogito_checkbox_get_checked\n"
"#undef cogito_checkbox_set_checked\n"
"#undef cogito_switch_get_checked\n"
"#undef cogito_switch_set_checked\n"
"#undef cogito_textfield_set_text\n"
"#undef cogito_textfield_get_text\n"
"#undef cogito_textfield_set_hint\n"
"#undef cogito_textfield_get_hint\n"
"#undef cogito_textview_set_text\n"
"#undef cogito_textview_get_text\n"
"#undef cogito_searchfield_set_text\n"
"#undef cogito_searchfield_get_text\n"
"#undef cogito_progress_set_value\n"
"#undef cogito_progress_get_value\n"
"#undef cogito_progress_set_indeterminate\n"
"#undef cogito_progress_get_indeterminate\n"
"#undef cogito_progress_set_thickness\n"
"#undef cogito_progress_get_thickness\n"
"#undef cogito_progress_set_wavy\n"
"#undef cogito_progress_get_wavy\n"
"#undef cogito_progress_set_circular\n"
"#undef cogito_progress_get_circular\n"
"#undef cogito_stepper_set_value\n"
"#undef cogito_stepper_get_value\n"
"#undef cogito_stepper_on_change\n"
"#undef cogito_segmented_on_select\n"
"#undef cogito_load_sum_file\n"
"#undef cogito_label_set_text\n"
"#undef cogito_label_set_wrap\n"
"#undef cogito_label_set_ellipsis\n"
"#undef cogito_label_set_align\n"
"#undef cogito_image_set_icon\n"
"#undef cogito_appbar_add_button\n"
"#undef cogito_appbar_set_controls\n"
"#undef cogito_appbar_set_title\n"
"#undef cogito_appbar_set_subtitle\n"
"#undef cogito_dialog_slot_show\n"
"#undef cogito_dialog_slot_clear\n"
"#undef cogito_window_set_dialog\n"
"#undef cogito_window_clear_dialog\n"
"#undef cogito_fixed_set_pos\n"
"#undef cogito_scroller_set_axes\n"
"#undef cogito_grid_set_gap\n"
"#undef cogito_grid_set_span\n"
"#undef cogito_grid_set_align\n"
"#undef cogito_button_set_text\n"
"#undef cogito_button_set_size\n"
"#undef cogito_button_get_size\n"
"#undef cogito_button_add_menu\n"
"#undef cogito_iconbtn_add_menu\n"
"#undef cogito_checkbox_on_change\n"
"#undef cogito_switch_on_change\n"
"#undef cogito_textfield_on_change\n"
"#undef cogito_textview_on_change\n"
"#undef cogito_searchfield_on_change\n"
"#undef cogito_dropdown_on_change\n"
"#undef cogito_slider_on_change\n"
"#undef cogito_tabs_on_change\n"
"#undef cogito_datepicker_on_change\n"
"#undef cogito_colorpicker_on_change\n"
"#undef cogito_list_on_select\n"
"#undef cogito_list_on_activate\n"
"#undef cogito_grid_on_select\n"
"#undef cogito_grid_on_activate\n"
"#undef cogito_view_switcher_set_active\n"
"#undef cogito_toast_on_click\n"
"#undef cogito_toast_set_action\n"
"#undef cogito_node_window\n"
"#undef cogito_find_parent\n"
"#undef cogito_find_children\n"
"#undef cogito_carousel_item_set_text\n"
"#undef cogito_carousel_item_set_halign\n"
"#undef cogito_carousel_item_set_valign\n"
"#undef cogito_active_indicator_new\n"
"#undef cogito_switchbar_new\n"
"#undef cogito_switchbar_get_checked\n"
"#undef cogito_switchbar_set_checked\n"
"#undef cogito_switchbar_on_change\n"
"#undef cogito_content_list_new\n"
"#undef cogito_empty_page_new\n"
"#undef cogito_empty_page_set_description\n"
"#undef cogito_empty_page_set_icon\n"
"#undef cogito_empty_page_set_action\n"
"#undef cogito_tip_view_new\n"
"#undef cogito_tip_view_set_title\n"
"#undef cogito_settings_window_new\n"
"#undef cogito_settings_page_new\n"
"#undef cogito_settings_list_new\n"
"#undef cogito_settings_row_new\n"
"#undef cogito_welcome_screen_new\n"
"#undef cogito_welcome_screen_set_description\n"
"#undef cogito_welcome_screen_set_icon\n"
"#undef cogito_welcome_screen_set_action\n"
"#undef cogito_view_dual_new\n"
"#undef cogito_view_dual_set_ratio\n"
"#undef cogito_view_chooser_new\n"
"#undef cogito_view_chooser_set_items\n"
"#undef cogito_view_chooser_bind\n"
"#undef cogito_about_window_new\n"
"#undef cogito_about_window_set_icon\n"
"#undef cogito_about_window_set_description\n"
"#undef cogito_about_window_set_website\n"
"#undef cogito_about_window_set_issue_url\n"
"#undef cogito_menu_button_new\n"
"#undef cogito_split_button_new\n"
"#undef cogito_split_button_add_menu\n"
"\n"
"static bool cogito_debug_enabled(void) {\n"
"  const char* env = getenv(\"COGITO_DEBUG\");\n"
"  return env && env[0] && env[0] != '0';\n"
"}\n"
"\n"
"typedef enum {\n"
"  COGITO_HANDLE_APP = 1,\n"
"  COGITO_HANDLE_WINDOW,\n"
"  COGITO_HANDLE_NODE,\n"
"  COGITO_HANDLE_STATE\n"
"} CogitoHandleKind;\n"
"\n"
"typedef struct CogitoHandle {\n"
"  ErgoObj base;\n"
"  void* ptr;\n"
"  int kind;\n"
"  ErgoVal on_click;\n"
"  ErgoVal on_change;\n"
"  ErgoVal on_select;\n"
"  ErgoVal on_activate;\n"
"  ErgoVal on_action;\n"
"  ErgoVal builder;\n"
"} CogitoHandle;\n"
"\n"
"typedef struct CogitoHandleEntry {\n"
"  cogito_node* node;\n"
"  CogitoHandle* handle;\n"
"  struct CogitoHandleEntry* next;\n"
"} CogitoHandleEntry;\n"
"\n"
"typedef struct CogitoMenuHandler {\n"
"  ErgoVal fn;\n"
"} CogitoMenuHandler;\n"
"\n"
"static void __cogito_button_on_click(ErgoVal btnv, ErgoVal handler);\n"
"\n"
"// Forward declaration for internal ErgoVal-based function\n"
"extern void cogito_view_switcher_add_lazy_ergo(cogito_node* view_switcher, ErgoVal id, ErgoVal builder);\n"
"\n"
"typedef struct CogitoState {\n"
"  ErgoObj base;\n"
"  ErgoVal value;\n"
"} CogitoState;\n"
"\n"
"static CogitoHandleEntry* cogito_handle_entries = NULL;\n"
"\n"
"static CogitoHandle* cogito_handle_lookup(cogito_node* node) {\n"
"  for (CogitoHandleEntry* e = cogito_handle_entries; e; e = e->next) {\n"
"    if (e->node == node) return e->handle;\n"
"  }\n"
"  return NULL;\n"
"}\n"
"\n"
"static void cogito_handle_register(cogito_node* node, CogitoHandle* handle) {\n"
"  CogitoHandleEntry* e = (CogitoHandleEntry*)malloc(sizeof(*e));\n"
"  e->node = node;\n"
"  e->handle = handle;\n"
"  e->next = cogito_handle_entries;\n"
"  cogito_handle_entries = e;\n"
"}\n"
"\n"
"static void cogito_handle_unregister(cogito_node* node) {\n"
"  CogitoHandleEntry** cur = &cogito_handle_entries;\n"
"  while (*cur) {\n"
"    CogitoHandleEntry* e = *cur;\n"
"    if (e->node == node) {\n"
"      *cur = e->next;\n"
"      free(e);\n"
"      return;\n"
"    }\n"
"    cur = &e->next;\n"
"  }\n"
"}\n"
"\n"
"static void cogito_handle_drop(ErgoObj* o) {\n"
"  CogitoHandle* h = (CogitoHandle*)o;\n"
"  if (!h) return;\n"
"  if (h->on_click.tag != EVT_NULL) ergo_release_val(h->on_click);\n"
"  if (h->on_change.tag != EVT_NULL) ergo_release_val(h->on_change);\n"
"  if (h->on_select.tag != EVT_NULL) ergo_release_val(h->on_select);\n"
"  if (h->on_activate.tag != EVT_NULL) ergo_release_val(h->on_activate);\n"
"  if (h->builder.tag != EVT_NULL) ergo_release_val(h->builder);\n"
"  if (h->kind == COGITO_HANDLE_WINDOW || h->kind == COGITO_HANDLE_NODE) {\n"
"    cogito_handle_unregister((cogito_node*)h->ptr);\n"
"  }\n"
"  h->ptr = NULL;\n"
"}\n"
"\n"
"static CogitoHandle* cogito_handle_new(void* ptr, int kind) {\n"
"  CogitoHandle* h = (CogitoHandle*)ergo_obj_new(sizeof(CogitoHandle), cogito_handle_drop);\n"
"  h->ptr = ptr;\n"
"  h->kind = kind;\n"
"  h->on_click = EV_NULLV;\n"
"  h->on_change = EV_NULLV;\n"
"  h->on_select = EV_NULLV;\n"
"  h->on_activate = EV_NULLV;\n"
"  h->builder = EV_NULLV;\n"
"  return h;\n"
"}\n"
"\n"
"static ErgoVal cogito_wrap_node(cogito_node* node, int kind) {\n"
"  if (!node) return EV_NULLV;\n"
"  CogitoHandle* h = cogito_handle_lookup(node);\n"
"  if (!h) {\n"
"    h = cogito_handle_new(node, kind);\n"
"    cogito_handle_register(node, h);\n"
"  }\n"
"  return EV_OBJ(h);\n"
"}\n"
"\n"
"static CogitoHandle* cogito_handle_from_val(ErgoVal v, const char* what) {\n"
"  if (v.tag != EVT_OBJ) ergo_trap(what);\n"
"  return (CogitoHandle*)v.as.p;\n"
"}\n"
"\n"
"static cogito_app* cogito_app_from_val(ErgoVal v) {\n"
"  CogitoHandle* h = cogito_handle_from_val(v, \"cogito.app expects app\");\n"
"  return (cogito_app*)h->ptr;\n"
"}\n"
"\n"
"static cogito_window* cogito_window_from_val(ErgoVal v) {\n"
"  CogitoHandle* h = cogito_handle_from_val(v, \"cogito.window expects window\");\n"
"  return (cogito_window*)h->ptr;\n"
"}\n"
"\n"
"static cogito_node* cogito_node_from_val(ErgoVal v) {\n"
"  CogitoHandle* h = cogito_handle_from_val(v, \"cogito.node expects node\");\n"
"  return (cogito_node*)h->ptr;\n"
"}\n"
"\n"
"// Non-static version for use by view_switcher.inc\n"
"cogito_node* cogito_unwrap_handle(ErgoVal v) {\n"
"  if (v.tag != EVT_OBJ) return NULL;\n"
"  CogitoHandle* h = (CogitoHandle*)v.as.p;\n"
"  return (cogito_node*)h->ptr;\n"
"}\n"
"\n"
"static const char* cogito_required_cstr(ErgoVal v, ErgoStr** tmp) {\n"
"  if (v.tag == EVT_NULL) return \"\";\n"
"  if (v.tag == EVT_STR) return ((ErgoStr*)v.as.p)->data;\n"
"  ErgoStr* s = stdr_to_string(v);\n"
"  if (tmp) *tmp = s;\n"
"  return s ? s->data : \"\";\n"
"}\n"
"\n"
"static const char* cogito_optional_cstr(ErgoVal v, ErgoStr** tmp) {\n"
"  if (v.tag == EVT_NULL) return NULL;\n"
"  if (v.tag == EVT_STR) return ((ErgoStr*)v.as.p)->data;\n"
"  ErgoStr* s = stdr_to_string(v);\n"
"  if (tmp) *tmp = s;\n"
"  return s ? s->data : NULL;\n"
"}\n"
"\n"
"static void cogito_set_handler(CogitoHandle* h, ErgoVal* slot, ErgoVal handler) {\n"
"  bool had = slot->tag != EVT_NULL;\n"
"  if (had) ergo_release_val(*slot);\n"
"  *slot = handler;\n"
"  bool has = handler.tag != EVT_NULL;\n"
"  if (has) ergo_retain_val(handler);\n"
"  if (h) {\n"
"    if (!had && has) ergo_retain_val(EV_OBJ(h));\n"
"    if (had && !has) ergo_release_val(EV_OBJ(h));\n"
"  }\n"
"}\n"
"\n"
"static void cogito_invoke_node_handler(ErgoVal handler, cogito_node* node) {\n"
"  if (handler.tag != EVT_FN) return;\n"
"  ErgoVal arg = cogito_wrap_node(node, COGITO_HANDLE_NODE);\n"
"  ergo_retain_val(arg);\n"
"  ErgoVal ret = ergo_call(handler, 1, &arg);\n"
"  ergo_release_val(arg);\n"
"  ergo_release_val(ret);\n"
"}\n"
"\n"
"static void cogito_invoke_index_handler(ErgoVal handler, int idx) {\n"
"  if (handler.tag != EVT_FN) return;\n"
"  ErgoVal arg = EV_INT(idx);\n"
"  ErgoVal ret = ergo_call(handler, 1, &arg);\n"
"  ergo_release_val(ret);\n"
"}\n"
"\n"
"static void cogito_cb_click(cogito_node* node, void* user) {\n"
"  CogitoHandle* h = (CogitoHandle*)user;\n"
"  if (!h) return;\n"
"  cogito_invoke_node_handler(h->on_click, node);\n"
"}\n"
"\n"
"static void cogito_cb_change(cogito_node* node, void* user) {\n"
"  CogitoHandle* h = (CogitoHandle*)user;\n"
"  if (!h) return;\n"
"  cogito_invoke_node_handler(h->on_change, node);\n"
"}\n"
"\n"
"static void cogito_cb_action(cogito_node* node, void* user) {\n"
"  CogitoHandle* h = (CogitoHandle*)user;\n"
"  if (!h) return;\n"
"  cogito_invoke_node_handler(h->on_action, node);\n"
"}\n"
"\n"
"static void cogito_cb_select(cogito_node* node, int idx, void* user) {\n"
"  (void)node;\n"
"  CogitoHandle* h = (CogitoHandle*)user;\n"
"  if (!h) return;\n"
"  cogito_invoke_index_handler(h->on_select, idx);\n"
"}\n"
"\n"
"static void cogito_cb_activate(cogito_node* node, int idx, void* user) {\n"
"  (void)node;\n"
"  CogitoHandle* h = (CogitoHandle*)user;\n"
"  if (!h) return;\n"
"  cogito_invoke_index_handler(h->on_activate, idx);\n"
"}\n"
"\n"
"static void cogito_cb_builder(cogito_node* node, void* user) {\n"
"  CogitoHandle* h = (CogitoHandle*)user;\n"
"  if (!h) return;\n"
"  cogito_invoke_node_handler(h->builder, node);\n"
"}\n"
"\n"
"static CogitoMenuHandler* cogito_menu_handler_new(ErgoVal handler) {\n"
"  CogitoMenuHandler* mh = (CogitoMenuHandler*)calloc(1, sizeof(*mh));\n"
"  mh->fn = handler;\n"
"  if (handler.tag != EVT_NULL) ergo_retain_val(handler);\n"
"  return mh;\n"
"}\n"
"\n"
"static void cogito_cb_menu(cogito_node* node, void* user) {\n"
"  CogitoMenuHandler* mh = (CogitoMenuHandler*)user;\n"
"  if (!mh) return;\n"
"  cogito_invoke_node_handler(mh->fn, node);\n"
"}\n"
"\n"
"static void cogito_state_drop(ErgoObj* o) {\n"
"  CogitoState* s = (CogitoState*)o;\n"
"  if (s->value.tag != EVT_NULL) {\n"
"    ergo_release_val(s->value);\n"
"    s->value = EV_NULLV;\n"
"  }\n"
"}\n"
"\n"
"static ErgoVal cogito_state_new_val(ErgoVal initial) {\n"
"  CogitoState* s = (CogitoState*)ergo_obj_new(sizeof(CogitoState), cogito_state_drop);\n"
"  s->value = initial;\n"
"  if (initial.tag != EVT_NULL) ergo_retain_val(initial);\n"
"  return EV_OBJ(s);\n"
"}\n"
"\n"
"static ErgoVal cogito_state_get_val(ErgoVal sv) {\n"
"  if (sv.tag != EVT_OBJ) ergo_trap(\"cogito.state_get expects state\");\n"
"  CogitoState* s = (CogitoState*)sv.as.p;\n"
"  ErgoVal v = s->value;\n"
"  if (v.tag != EVT_NULL) ergo_retain_val(v);\n"
"  return v;\n"
"}\n"
"\n"
"static void cogito_state_set_val(ErgoVal sv, ErgoVal nv) {\n"
"  if (sv.tag != EVT_OBJ) ergo_trap(\"cogito.state_set expects state\");\n"
"  CogitoState* s = (CogitoState*)sv.as.p;\n"
"  if (s->value.tag != EVT_NULL) ergo_release_val(s->value);\n"
"  s->value = nv;\n"
"  if (nv.tag != EVT_NULL) ergo_retain_val(nv);\n"
"  cogito_rebuild_active_window();\n"
"}\n"
"\n"
"static ErgoVal __cogito_app(void) {\n"
"  cogito_app* app = cogito_app_new();\n"
"  CogitoHandle* h = cogito_handle_new(app, COGITO_HANDLE_APP);\n"
"  return EV_OBJ(h);\n"
"}\n"
"\n"
"static void __cogito_app_set_appid(ErgoVal appv, ErgoVal idv) {\n"
"  cogito_app* app = cogito_app_from_val(appv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* id = cogito_optional_cstr(idv, &tmp);\n"
"  if (id) cogito_app_set_appid(app, id);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"static void __cogito_app_set_app_name(ErgoVal appv, ErgoVal namev) {\n"
"  cogito_app* app = cogito_app_from_val(appv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* name = cogito_optional_cstr(namev, &tmp);\n"
"  if (name) cogito_app_set_app_name(app, name);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"static void __cogito_app_set_accent_color(ErgoVal appv, ErgoVal colorv, ErgoVal overridev) {\n"
"  cogito_app* app = cogito_app_from_val(appv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* color = cogito_optional_cstr(colorv, &tmp);\n"
"  bool ov = overridev.tag == EVT_BOOL ? overridev.as.b : false;\n"
"  if (color) cogito_app_set_accent_color(app, color, ov);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"static void __cogito_app_set_icon(ErgoVal appv, ErgoVal pathv) {\n"
"  cogito_app* app = cogito_app_from_val(appv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* path = cogito_optional_cstr(pathv, &tmp);\n"
"  if (path) cogito_app_set_icon(app, path);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"static ErgoVal __cogito_app_get_icon(ErgoVal appv) {\n"
"  cogito_app* app = cogito_app_from_val(appv);\n"
"  const char* path = cogito_app_get_icon(app);\n"
"  return EV_STR(stdr_str_lit(path ? path : \"\"));\n"
"}\n"
"\n"
"static ErgoVal __cogito_window(ErgoVal titlev, ErgoVal wv, ErgoVal hv) {\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* title = cogito_required_cstr(titlev, &tmp);\n"
"  int w = (int)ergo_as_int(wv);\n"
"  int h = (int)ergo_as_int(hv);\n"
"  cogito_window* win = cogito_window_new(title, w, h);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"  return cogito_wrap_node((cogito_node*)win, COGITO_HANDLE_WINDOW);\n"
"}\n"
"\n"
"static void __cogito_window_set_resizable(ErgoVal winv, ErgoVal onv) {\n"
"  cogito_window* win = cogito_window_from_val(winv);\n"
"  cogito_window_set_resizable(win, onv.tag == EVT_BOOL ? onv.as.b : false);\n"
"}\n"
"\n"
"static void __cogito_window_set_autosize(ErgoVal winv, ErgoVal onv) {\n"
"  cogito_window* win = cogito_window_from_val(winv);\n"
"  cogito_window_set_autosize(win, onv.tag == EVT_BOOL ? onv.as.b : false);\n"
"}\n"
"\n"
"static void __cogito_window_set_a11y_label(ErgoVal winv, ErgoVal labelv) {\n"
"  cogito_window* win = cogito_window_from_val(winv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* label = cogito_optional_cstr(labelv, &tmp);\n"
"  if (label) cogito_window_set_a11y_label(win, label);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"static void __cogito_window_set_builder(ErgoVal winv, ErgoVal builder) {\n"
"  cogito_window* win = cogito_window_from_val(winv);\n"
"  CogitoHandle* h = (CogitoHandle*)winv.as.p;\n"
"  if (builder.tag != EVT_FN) {\n"
"    cogito_set_handler(h, &h->builder, builder);\n"
"    cogito_window_set_builder(win, NULL, NULL);\n"
"    return;\n"
"  }\n"
"  cogito_set_handler(h, &h->builder, builder);\n"
"  cogito_window_set_builder(win, cogito_cb_builder, h);\n"
"}\n"
"\n"
"static ErgoVal __cogito_label(ErgoVal textv) {\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* text = cogito_required_cstr(textv, &tmp);\n"
"  cogito_node* n = cogito_label_new(text);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static ErgoVal __cogito_button(ErgoVal textv) {\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* text = cogito_required_cstr(textv, &tmp);\n"
"  cogito_node* n = cogito_button_new(text);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static ErgoVal __cogito_iconbtn(ErgoVal textv) {\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* text = cogito_required_cstr(textv, &tmp);\n"
"  cogito_node* n = cogito_iconbtn_new(text);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static ErgoVal __cogito_fab(ErgoVal iconv) {\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* icon = cogito_required_cstr(iconv, &tmp);\n"
"  cogito_node* n = cogito_fab_new(icon);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static void __cogito_fab_set_extended(ErgoVal fabv, ErgoVal extendedv, ErgoVal labelv) {\n"
"  cogito_node* fab = cogito_node_from_val(fabv);\n"
"  bool extended = ergo_as_bool(extendedv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* label = cogito_optional_cstr(labelv, &tmp);\n"
"  cogito_fab_set_extended(fab, extended, label ? label : \"\");\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"static void __cogito_fab_on_click(ErgoVal fabv, ErgoVal handler) {\n"
"  cogito_node* fab = cogito_node_from_val(fabv);\n"
"  CogitoHandle* h = (CogitoHandle*)fabv.as.p;\n"
"  if (handler.tag != EVT_FN) {\n"
"    cogito_set_handler(h, &h->on_click, handler);\n"
"    cogito_fab_on_click(fab, NULL, NULL);\n"
"    return;\n"
"  }\n"
"  cogito_set_handler(h, &h->on_click, handler);\n"
"  cogito_fab_on_click(fab, cogito_cb_click, h);\n"
"}\n"
"\n"
"static ErgoVal __cogito_chip(ErgoVal textv) {\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* text = cogito_required_cstr(textv, &tmp);\n"
"  cogito_node* n = cogito_chip_new(text);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static void __cogito_chip_set_selected(ErgoVal chipv, ErgoVal sel) {\n"
"  cogito_node* n = cogito_node_from_val(chipv);\n"
"  cogito_chip_set_selected(n, ergo_as_bool(sel));\n"
"}\n"
"\n"
"static ErgoVal __cogito_chip_get_selected(ErgoVal chipv) {\n"
"  cogito_node* n = cogito_node_from_val(chipv);\n"
"  return EV_BOOL(cogito_chip_get_selected(n));\n"
"}\n"
"\n"
"static void __cogito_chip_set_closable(ErgoVal chipv, ErgoVal closable) {\n"
"  cogito_node* n = cogito_node_from_val(chipv);\n"
"  cogito_chip_set_closable(n, ergo_as_bool(closable));\n"
"}\n"
"\n"
"static void __cogito_chip_on_click(ErgoVal chipv, ErgoVal handler) {\n"
"  cogito_node* chip = cogito_node_from_val(chipv);\n"
"  CogitoHandle* h = (CogitoHandle*)chipv.as.p;\n"
"  if (handler.tag != EVT_FN) {\n"
"    cogito_set_handler(h, &h->on_click, handler);\n"
"    cogito_chip_on_click(chip, NULL, NULL);\n"
"    return;\n"
"  }\n"
"  cogito_set_handler(h, &h->on_click, handler);\n"
"  cogito_chip_on_click(chip, cogito_cb_click, h);\n"
"}\n"
"\n"
"static void __cogito_chip_on_close(ErgoVal chipv, ErgoVal handler) {\n"
"  cogito_node* chip = cogito_node_from_val(chipv);\n"
"  CogitoHandle* h = (CogitoHandle*)chipv.as.p;\n"
"  if (handler.tag != EVT_FN) {\n"
"    cogito_set_handler(h, &h->on_action, handler);\n"
"    cogito_chip_on_close(chip, NULL, NULL);\n"
"    return;\n"
"  }\n"
"  cogito_set_handler(h, &h->on_action, handler);\n"
"  cogito_chip_on_close(chip, cogito_cb_action, h);\n"
"}\n"
"\n"
"// --- Divider ---\n"
"static ErgoVal __cogito_divider(ErgoVal orientationv, ErgoVal insetv) {\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* orientation = NULL;\n"
"  if (orientationv.tag != EVT_NULL) {\n"
"    orientation = cogito_required_cstr(orientationv, &tmp);\n"
"  }\n"
"  bool inset = ergo_as_bool(insetv);\n"
"  cogito_node* n = cogito_divider_new(orientation, inset);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"// --- Card ---\n"
"static ErgoVal __cogito_card(ErgoVal titlev) {\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* title = NULL;\n"
"  if (titlev.tag != EVT_NULL) {\n"
"    title = cogito_required_cstr(titlev, &tmp);\n"
"  }\n"
"  cogito_node* n = cogito_card_new(title);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"// --- Avatar ---\n"
"static ErgoVal __cogito_avatar(ErgoVal textv) {\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* text = NULL;\n"
"  if (textv.tag != EVT_NULL) {\n"
"    text = cogito_required_cstr(textv, &tmp);\n"
"  }\n"
"  cogito_node* n = cogito_avatar_new(text);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static void __cogito_avatar_set_image(ErgoVal avatarv, ErgoVal pathv) {\n"
"  cogito_node* n = cogito_node_from_val(avatarv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* path = cogito_required_cstr(pathv, &tmp);\n"
"  cogito_avatar_set_image(n, path);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"// --- Badge ---\n"
"static ErgoVal __cogito_badge(ErgoVal countv) {\n"
"  int count = 0;\n"
"  if (countv.tag == EVT_INT) count = (int)countv.as.i;\n"
"  else if (countv.tag == EVT_FLOAT) count = (int)countv.as.f;\n"
"  cogito_node* n = cogito_badge_new(count);\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static void __cogito_badge_set_count(ErgoVal badgev, ErgoVal countv) {\n"
"  cogito_node* n = cogito_node_from_val(badgev);\n"
"  int count = 0;\n"
"  if (countv.tag == EVT_INT) count = (int)countv.as.i;\n"
"  else if (countv.tag == EVT_FLOAT) count = (int)countv.as.f;\n"
"  cogito_badge_set_count(n, count);\n"
"}\n"
"\n"
"static ErgoVal __cogito_badge_get_count(ErgoVal badgev) {\n"
"  cogito_node* n = cogito_node_from_val(badgev);\n"
"  return EV_INT(cogito_badge_get_count(n));\n"
"}\n"
"\n"
"// --- Banner ---\n"
"static ErgoVal __cogito_banner(ErgoVal textv) {\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* text = cogito_required_cstr(textv, &tmp);\n"
"  cogito_node* n = cogito_banner_new(text);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static void __cogito_banner_set_action(ErgoVal bannerv, ErgoVal textv, ErgoVal handlerv) {\n"
"  cogito_node* banner = cogito_node_from_val(bannerv);\n"
"  CogitoHandle* h = (CogitoHandle*)bannerv.as.p;\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* text = cogito_required_cstr(textv, &tmp);\n"
"  if (handlerv.tag != EVT_FN) {\n"
"    cogito_set_handler(h, &h->on_action, handlerv);\n"
"    cogito_banner_set_action(banner, text, NULL, NULL);\n"
"  } else {\n"
"    cogito_set_handler(h, &h->on_action, handlerv);\n"
"    cogito_banner_set_action(banner, text, cogito_cb_action, h);\n"
"  }\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"static void __cogito_banner_set_icon(ErgoVal bannerv, ErgoVal iconv) {\n"
"  cogito_node* banner = cogito_node_from_val(bannerv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* icon = cogito_required_cstr(iconv, &tmp);\n"
"  cogito_banner_set_icon(banner, icon);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"// --- BottomSheet ---\n"
"static ErgoVal __cogito_bottom_sheet(ErgoVal titlev) {\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* title = NULL;\n"
"  if (titlev.tag != EVT_NULL) {\n"
"    title = cogito_required_cstr(titlev, &tmp);\n"
"  }\n"
"  cogito_node* n = cogito_bottom_sheet_new(title);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"// --- TimePicker ---\n"
"static ErgoVal __cogito_timepicker(void) {\n"
"  cogito_node* n = cogito_timepicker_new();\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static void __cogito_timepicker_on_change(ErgoVal tpv, ErgoVal handler) {\n"
"  cogito_node* tp = cogito_node_from_val(tpv);\n"
"  CogitoHandle* h = (CogitoHandle*)tpv.as.p;\n"
"  if (handler.tag != EVT_FN) {\n"
"    cogito_set_handler(h, &h->on_change, handler);\n"
"    cogito_timepicker_on_change(tp, NULL, NULL);\n"
"    return;\n"
"  }\n"
"  cogito_set_handler(h, &h->on_change, handler);\n"
"  cogito_timepicker_on_change(tp, cogito_cb_change, h);\n"
"}\n"
"\n"
"static ErgoVal __cogito_timepicker_get_hour(ErgoVal tpv) {\n"
"  cogito_node* n = cogito_node_from_val(tpv);\n"
"  return EV_INT(cogito_timepicker_get_hour(n));\n"
"}\n"
"\n"
"static ErgoVal __cogito_timepicker_get_minute(ErgoVal tpv) {\n"
"  cogito_node* n = cogito_node_from_val(tpv);\n"
"  return EV_INT(cogito_timepicker_get_minute(n));\n"
"}\n"
"\n"
"static void __cogito_timepicker_set_time(ErgoVal tpv, ErgoVal hourv, ErgoVal minv) {\n"
"  cogito_node* n = cogito_node_from_val(tpv);\n"
"  int hour = 0, minute = 0;\n"
"  if (hourv.tag == EVT_INT) hour = (int)hourv.as.i;\n"
"  else if (hourv.tag == EVT_FLOAT) hour = (int)hourv.as.f;\n"
"  if (minv.tag == EVT_INT) minute = (int)minv.as.i;\n"
"  else if (minv.tag == EVT_FLOAT) minute = (int)minv.as.f;\n"
"  cogito_timepicker_set_time(n, hour, minute);\n"
"}\n"
"\n"
"// --- ActiveIndicator ---\n"
"static ErgoVal __cogito_active_indicator(void) {\n"
"  cogito_node* n = cogito_active_indicator_new();\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"// --- SwitchBar ---\n"
"static ErgoVal __cogito_switchbar(ErgoVal textv) {\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* text = cogito_required_cstr(textv, &tmp);\n"
"  cogito_node* n = cogito_switchbar_new(text);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"static ErgoVal __cogito_switchbar_get_checked(ErgoVal sbv) {\n"
"  cogito_node* n = cogito_node_from_val(sbv);\n"
"  return EV_BOOL(cogito_switchbar_get_checked(n));\n"
"}\n"
"static void __cogito_switchbar_set_checked(ErgoVal sbv, ErgoVal val) {\n"
"  cogito_node* n = cogito_node_from_val(sbv);\n"
"  cogito_switchbar_set_checked(n, ergo_as_bool(val));\n"
"}\n"
"static void __cogito_switchbar_on_change(ErgoVal sbv, ErgoVal handler) {\n"
"  cogito_node* sb = cogito_node_from_val(sbv);\n"
"  CogitoHandle* h = (CogitoHandle*)sbv.as.p;\n"
"  if (handler.tag != EVT_FN) {\n"
"    cogito_set_handler(h, &h->on_change, handler);\n"
"    cogito_switchbar_on_change(sb, NULL, NULL);\n"
"    return;\n"
"  }\n"
"  cogito_set_handler(h, &h->on_change, handler);\n"
"  cogito_switchbar_on_change(sb, cogito_cb_change, h);\n"
"}\n"
"\n"
"// --- ContentList ---\n"
"static ErgoVal __cogito_content_list(void) {\n"
"  cogito_node* n = cogito_content_list_new();\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"// --- EmptyPage ---\n"
"static ErgoVal __cogito_empty_page(ErgoVal titlev) {\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* title = cogito_required_cstr(titlev, &tmp);\n"
"  cogito_node* n = cogito_empty_page_new(title);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"static void __cogito_empty_page_set_description(ErgoVal epv, ErgoVal descv) {\n"
"  cogito_node* n = cogito_node_from_val(epv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* desc = cogito_required_cstr(descv, &tmp);\n"
"  cogito_empty_page_set_description(n, desc);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"static void __cogito_empty_page_set_icon(ErgoVal epv, ErgoVal iconv) {\n"
"  cogito_node* n = cogito_node_from_val(epv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* icon = cogito_required_cstr(iconv, &tmp);\n"
"  cogito_empty_page_set_icon(n, icon);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"static void __cogito_empty_page_set_action(ErgoVal epv, ErgoVal textv, ErgoVal handlerv) {\n"
"  cogito_node* ep = cogito_node_from_val(epv);\n"
"  CogitoHandle* h = (CogitoHandle*)epv.as.p;\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* text = cogito_required_cstr(textv, &tmp);\n"
"  if (handlerv.tag != EVT_FN) {\n"
"    cogito_set_handler(h, &h->on_action, handlerv);\n"
"    cogito_empty_page_set_action(ep, text, NULL, NULL);\n"
"  } else {\n"
"    cogito_set_handler(h, &h->on_action, handlerv);\n"
"    cogito_empty_page_set_action(ep, text, cogito_cb_action, h);\n"
"  }\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"// --- TipView ---\n"
"static ErgoVal __cogito_tip_view(ErgoVal textv) {\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* text = cogito_required_cstr(textv, &tmp);\n"
"  cogito_node* n = cogito_tip_view_new(text);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"static void __cogito_tip_view_set_title(ErgoVal tvv, ErgoVal titlev) {\n"
"  cogito_node* n = cogito_node_from_val(tvv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* title = cogito_required_cstr(titlev, &tmp);\n"
"  cogito_tip_view_set_title(n, title);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"// --- SettingsWindow ---\n"
"static ErgoVal __cogito_settings_window(ErgoVal titlev) {\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* title = cogito_required_cstr(titlev, &tmp);\n"
"  cogito_node* n = cogito_settings_window_new(title);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"// --- SettingsPage ---\n"
"static ErgoVal __cogito_settings_page(ErgoVal titlev) {\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* title = cogito_required_cstr(titlev, &tmp);\n"
"  cogito_node* n = cogito_settings_page_new(title);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"// --- SettingsList ---\n"
"static ErgoVal __cogito_settings_list(ErgoVal titlev) {\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* title = cogito_required_cstr(titlev, &tmp);\n"
"  cogito_node* n = cogito_settings_list_new(title);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"// --- SettingsRow ---\n"
"static ErgoVal __cogito_settings_row(ErgoVal labelv) {\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* label = cogito_required_cstr(labelv, &tmp);\n"
"  cogito_node* n = cogito_settings_row_new(label);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"// --- WelcomeScreen ---\n"
"static ErgoVal __cogito_welcome_screen(ErgoVal titlev) {\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* title = cogito_required_cstr(titlev, &tmp);\n"
"  cogito_node* n = cogito_welcome_screen_new(title);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"static void __cogito_welcome_screen_set_description(ErgoVal wsv, ErgoVal descv) {\n"
"  cogito_node* n = cogito_node_from_val(wsv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* desc = cogito_required_cstr(descv, &tmp);\n"
"  cogito_welcome_screen_set_description(n, desc);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"static void __cogito_welcome_screen_set_icon(ErgoVal wsv, ErgoVal iconv) {\n"
"  cogito_node* n = cogito_node_from_val(wsv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* icon = cogito_required_cstr(iconv, &tmp);\n"
"  cogito_welcome_screen_set_icon(n, icon);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"static void __cogito_welcome_screen_set_action(ErgoVal wsv, ErgoVal textv, ErgoVal handlerv) {\n"
"  cogito_node* ws = cogito_node_from_val(wsv);\n"
"  CogitoHandle* h = (CogitoHandle*)wsv.as.p;\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* text = cogito_required_cstr(textv, &tmp);\n"
"  if (handlerv.tag != EVT_FN) {\n"
"    cogito_set_handler(h, &h->on_action, handlerv);\n"
"    cogito_welcome_screen_set_action(ws, text, NULL, NULL);\n"
"  } else {\n"
"    cogito_set_handler(h, &h->on_action, handlerv);\n"
"    cogito_welcome_screen_set_action(ws, text, cogito_cb_action, h);\n"
"  }\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"// --- ViewDual ---\n"
"static ErgoVal __cogito_view_dual(void) {\n"
"  cogito_node* n = cogito_view_dual_new();\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"static void __cogito_view_dual_set_ratio(ErgoVal vdv, ErgoVal ratiov) {\n"
"  cogito_node* n = cogito_node_from_val(vdv);\n"
"  double ratio = ergo_as_float(ratiov);\n"
"  cogito_view_dual_set_ratio(n, ratio);\n"
"}\n"
"\n"
"// --- ViewChooser ---\n"
"static ErgoVal __cogito_view_chooser(void) {\n"
"  cogito_node* n = cogito_view_chooser_new();\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"static void __cogito_view_chooser_set_items(ErgoVal vcv, ErgoVal arrv) {\n"
"  cogito_node* n = cogito_node_from_val(vcv);\n"
"  if (arrv.tag != EVT_ARR) ergo_trap(\"view_chooser_set_items expects array\");\n"
"  ErgoArr* a = (ErgoArr*)arrv.as.p;\n"
"  size_t len = (size_t)a->len;\n"
"  const char** items = (const char**)malloc(sizeof(const char*) * len);\n"
"  ErgoStr** tmps = (ErgoStr**)malloc(sizeof(ErgoStr*) * len);\n"
"  for (size_t i = 0; i < len; i++) {\n"
"    ErgoVal v = ergo_arr_get(a, (int64_t)i);\n"
"    tmps[i] = NULL;\n"
"    items[i] = cogito_required_cstr(v, &tmps[i]);\n"
"  }\n"
"  cogito_view_chooser_set_items(n, items, len);\n"
"  for (size_t i = 0; i < len; i++) {\n"
"    if (tmps[i]) ergo_release_val(EV_STR(tmps[i]));\n"
"  }\n"
"  free(items);\n"
"  free(tmps);\n"
"}\n"
"static void __cogito_view_chooser_bind(ErgoVal vcv, ErgoVal vsv) {\n"
"  cogito_node* vc = cogito_node_from_val(vcv);\n"
"  cogito_node* vs = cogito_node_from_val(vsv);\n"
"  cogito_view_chooser_bind(vc, vs);\n"
"}\n"
"\n"
"// --- AboutWindow ---\n"
"static ErgoVal __cogito_about_window(ErgoVal namev, ErgoVal versionv) {\n"
"  ErgoStr* tmp1 = NULL;\n"
"  ErgoStr* tmp2 = NULL;\n"
"  const char* name = cogito_required_cstr(namev, &tmp1);\n"
"  const char* version = cogito_required_cstr(versionv, &tmp2);\n"
"  cogito_node* n = cogito_about_window_new(name, version);\n"
"  if (tmp1) ergo_release_val(EV_STR(tmp1));\n"
"  if (tmp2) ergo_release_val(EV_STR(tmp2));\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"static void __cogito_about_window_set_icon(ErgoVal awv, ErgoVal iconv) {\n"
"  cogito_node* n = cogito_node_from_val(awv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* icon = cogito_required_cstr(iconv, &tmp);\n"
"  cogito_about_window_set_icon(n, icon);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"static void __cogito_about_window_set_description(ErgoVal awv, ErgoVal descv) {\n"
"  cogito_node* n = cogito_node_from_val(awv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* desc = cogito_required_cstr(descv, &tmp);\n"
"  cogito_about_window_set_description(n, desc);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"static void __cogito_about_window_set_website(ErgoVal awv, ErgoVal urlv) {\n"
"  cogito_node* n = cogito_node_from_val(awv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* url = cogito_required_cstr(urlv, &tmp);\n"
"  cogito_about_window_set_website(n, url);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"static void __cogito_about_window_set_issue_url(ErgoVal awv, ErgoVal urlv) {\n"
"  cogito_node* n = cogito_node_from_val(awv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* url = cogito_required_cstr(urlv, &tmp);\n"
"  cogito_about_window_set_issue_url(n, url);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"// --- MenuButton ---\n"
"static ErgoVal __cogito_menu_button(ErgoVal iconv) {\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* icon = cogito_required_cstr(iconv, &tmp);\n"
"  cogito_node* n = cogito_menu_button_new(icon);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"// --- SplitButton ---\n"
"static ErgoVal __cogito_split_button(ErgoVal textv) {\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* text = cogito_required_cstr(textv, &tmp);\n"
"  cogito_node* n = cogito_split_button_new(text);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"static void __cogito_split_button_add_menu(ErgoVal btnv, ErgoVal labelv, ErgoVal handlerv) {\n"
"  cogito_node* btn = cogito_node_from_val(btnv);\n"
"  CogitoHandle* h = (CogitoHandle*)btnv.as.p;\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* label = cogito_required_cstr(labelv, &tmp);\n"
"  if (handlerv.tag == EVT_FN) {\n"
"    cogito_set_handler(h, &h->on_action, handlerv);\n"
"    cogito_split_button_add_menu(btn, label, cogito_cb_action, h);\n"
"  } else {\n"
"    cogito_split_button_add_menu(btn, label, NULL, NULL);\n"
"  }\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"static ErgoVal __cogito_image(ErgoVal iconv) {\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* icon = cogito_required_cstr(iconv, &tmp);\n"
"  cogito_node* n = cogito_image_new(icon);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static void __cogito_image_set_icon(ErgoVal imgv, ErgoVal iconv) {\n"
"  cogito_node* n = cogito_node_from_val(imgv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* icon = cogito_required_cstr(iconv, &tmp);\n"
"  cogito_image_set_icon(n, icon);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"static void __cogito_image_set_source(ErgoVal imgv, ErgoVal sourcev) {\n"
"  cogito_node* n = cogito_node_from_val(imgv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* source = cogito_required_cstr(sourcev, &tmp);\n"
"  cogito_image_set_source(n, source);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"static void __cogito_image_set_size(ErgoVal imgv, ErgoVal wv, ErgoVal hv) {\n"
"  cogito_node* n = cogito_node_from_val(imgv);\n"
"  int w = (int)ergo_as_int(wv);\n"
"  int h = (int)ergo_as_int(hv);\n"
"  cogito_image_set_size(n, w, h);\n"
"}\n"
"\n"
"static void __cogito_image_set_radius(ErgoVal imgv, ErgoVal rv) {\n"
"  cogito_node* n = cogito_node_from_val(imgv);\n"
"  int r = (int)ergo_as_int(rv);\n"
"  cogito_image_set_radius(n, r);\n"
"}\n"
"\n"
"static ErgoVal __cogito_appbar(ErgoVal titlev, ErgoVal subtitlev) {\n"
"  ErgoStr* ttmp = NULL;\n"
"  ErgoStr* stmp = NULL;\n"
"  const char* title = cogito_required_cstr(titlev, &ttmp);\n"
"  const char* subtitle = cogito_required_cstr(subtitlev, &stmp);\n"
"  cogito_node* n = cogito_appbar_new(title, subtitle);\n"
"  if (ttmp) ergo_release_val(EV_STR(ttmp));\n"
"  if (stmp) ergo_release_val(EV_STR(stmp));\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static ErgoVal __cogito_appbar_add_button(ErgoVal appbarv, ErgoVal iconv, ErgoVal handler) {\n"
"  cogito_node* appbar = cogito_node_from_val(appbarv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* icon = cogito_required_cstr(iconv, &tmp);\n"
"  cogito_node* btn = cogito_appbar_add_button(appbar, icon, NULL, NULL);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"  ErgoVal btnv = cogito_wrap_node(btn, COGITO_HANDLE_NODE);\n"
"  if (handler.tag == EVT_FN) __cogito_button_on_click(btnv, handler);\n"
"  return btnv;\n"
"}\n"
"\n"
"static void __cogito_appbar_set_controls(ErgoVal appbarv, ErgoVal layoutv) {\n"
"  cogito_node* appbar = cogito_node_from_val(appbarv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* layout = cogito_optional_cstr(layoutv, &tmp);\n"
"  if (layout) cogito_appbar_set_controls(appbar, layout);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"static void __cogito_appbar_set_title(ErgoVal appbarv, ErgoVal titlev) {\n"
"  cogito_node* appbar = cogito_node_from_val(appbarv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* title = cogito_optional_cstr(titlev, &tmp);\n"
"  cogito_appbar_set_title(appbar, title ? title : \"\");\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"static void __cogito_appbar_set_subtitle(ErgoVal appbarv, ErgoVal subtitlev) {\n"
"  cogito_node* appbar = cogito_node_from_val(appbarv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* subtitle = cogito_optional_cstr(subtitlev, &tmp);\n"
"  cogito_appbar_set_subtitle(appbar, subtitle ? subtitle : \"\");\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"static ErgoVal __cogito_dialog(ErgoVal titlev) {\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* title = cogito_required_cstr(titlev, &tmp);\n"
"  cogito_node* n = cogito_dialog_new(title);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static void __cogito_dialog_close(ErgoVal dialogv) {\n"
"  cogito_node* dialog = cogito_node_from_val(dialogv);\n"
"  cogito_dialog_close(dialog);\n"
"}\n"
"\n"
"static void __cogito_dialog_remove(ErgoVal dialogv) {\n"
"  cogito_node* dialog = cogito_node_from_val(dialogv);\n"
"  cogito_dialog_remove(dialog);\n"
"}\n"
"\n"
"static ErgoVal __cogito_dialog_slot(void) {\n"
"  cogito_node* n = cogito_dialog_slot_new();\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static void __cogito_dialog_slot_show(ErgoVal slotv, ErgoVal dialogv) {\n"
"  cogito_node* slot = cogito_node_from_val(slotv);\n"
"  cogito_node* dialog = cogito_node_from_val(dialogv);\n"
"  cogito_dialog_slot_show(slot, dialog);\n"
"}\n"
"\n"
"static void __cogito_dialog_slot_clear(ErgoVal slotv) {\n"
"  cogito_node* slot = cogito_node_from_val(slotv);\n"
"  cogito_dialog_slot_clear(slot);\n"
"}\n"
"\n"
"static void __cogito_window_set_dialog(ErgoVal winv, ErgoVal dialogv) {\n"
"  cogito_window* win = cogito_window_from_val(winv);\n"
"  cogito_node* dialog = cogito_node_from_val(dialogv);\n"
"  cogito_window_set_dialog(win, dialog);\n"
"}\n"
"\n"
"static void __cogito_window_clear_dialog(ErgoVal winv) {\n"
"  cogito_window* win = cogito_window_from_val(winv);\n"
"  cogito_window_clear_dialog(win);\n"
"}\n"
"\n"
"static ErgoVal __cogito_node_window(ErgoVal nodev) {\n"
"  cogito_node* n = cogito_node_from_val(nodev);\n"
"  cogito_window* win = cogito_node_window(n);\n"
"  return cogito_wrap_node((cogito_node*)win, COGITO_HANDLE_WINDOW);\n"
"}\n"
"\n"
"static ErgoVal __cogito_find_parent(ErgoVal nodev) {\n"
"  cogito_node* n = cogito_node_from_val(nodev);\n"
"  cogito_node* p = cogito_node_get_parent(n);\n"
"  if (!p) return EV_NULLV;\n"
"  return cogito_wrap_node(p, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static ErgoVal __cogito_find_children(ErgoVal nodev) {\n"
"  cogito_node* n = cogito_node_from_val(nodev);\n"
"  size_t count = cogito_node_get_child_count(n);\n"
"  ErgoArr* arr = stdr_arr_new((int)count);\n"
"  for (size_t i = 0; i < count; i++) {\n"
"    cogito_node* child = cogito_node_get_child(n, i);\n"
"    ergo_arr_add(arr, cogito_wrap_node(child, COGITO_HANDLE_NODE));\n"
"  }\n"
"  return EV_ARR(arr);\n"
"}\n"
"\n"
"static void __cogito_label_set_class(ErgoVal labelv, ErgoVal classv) {\n"
"  cogito_node* n = cogito_node_from_val(labelv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* cls = cogito_optional_cstr(classv, &tmp);\n"
"  if (cls) cogito_node_set_class(n, cls);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"static void __cogito_label_set_text(ErgoVal labelv, ErgoVal textv) {\n"
"  cogito_node* n = cogito_node_from_val(labelv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* text = cogito_optional_cstr(textv, &tmp);\n"
"  if (text) cogito_node_set_text(n, text);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"static void __cogito_node_set_class(ErgoVal nodev, ErgoVal classv) {\n"
"  cogito_node* n = cogito_node_from_val(nodev);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* cls = cogito_optional_cstr(classv, &tmp);\n"
"  if (cls) cogito_node_set_class(n, cls);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"static void __cogito_node_set_a11y_label(ErgoVal nodev, ErgoVal labelv) {\n"
"  cogito_node* n = cogito_node_from_val(nodev);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* label = cogito_optional_cstr(labelv, &tmp);\n"
"  if (label) cogito_node_set_a11y_label(n, label);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"static void __cogito_node_set_a11y_role(ErgoVal nodev, ErgoVal rolev) {\n"
"  cogito_node* n = cogito_node_from_val(nodev);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* role = cogito_optional_cstr(rolev, &tmp);\n"
"  if (role) cogito_node_set_a11y_role(n, role);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"static void __cogito_node_set_tooltip(ErgoVal nodev, ErgoVal textv) {\n"
"  cogito_node* n = cogito_node_from_val(nodev);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* text = cogito_optional_cstr(textv, &tmp);\n"
"  if (text) cogito_node_set_tooltip(n, text);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"static void __cogito_pointer_capture(ErgoVal nodev) {\n"
"  if (nodev.tag == EVT_NULL) {\n"
"    cogito_pointer_release();\n"
"    return;\n"
"  }\n"
"  cogito_node* n = cogito_node_from_val(nodev);\n"
"  cogito_pointer_capture(n);\n"
"}\n"
"\n"
"static void __cogito_pointer_release(void) {\n"
"  cogito_pointer_release();\n"
"}\n"
"\n"
"static void __cogito_label_set_wrap(ErgoVal labelv, ErgoVal onv) {\n"
"  cogito_node* n = cogito_node_from_val(labelv);\n"
"  cogito_label_set_wrap(n, onv.tag == EVT_BOOL ? onv.as.b : false);\n"
"}\n"
"\n"
"static void __cogito_label_set_ellipsis(ErgoVal labelv, ErgoVal onv) {\n"
"  cogito_node* n = cogito_node_from_val(labelv);\n"
"  cogito_label_set_ellipsis(n, onv.tag == EVT_BOOL ? onv.as.b : false);\n"
"}\n"
"\n"
"static void __cogito_label_set_align(ErgoVal labelv, ErgoVal alignv) {\n"
"  cogito_node* n = cogito_node_from_val(labelv);\n"
"  cogito_label_set_align(n, (int)ergo_as_int(alignv));\n"
"}\n"
"\n"
"static ErgoVal __cogito_checkbox(ErgoVal textv, ErgoVal groupv) {\n"
"  ErgoStr* ttmp = NULL;\n"
"  ErgoStr* gtmp = NULL;\n"
"  const char* text = cogito_required_cstr(textv, &ttmp);\n"
"  const char* group = cogito_optional_cstr(groupv, &gtmp);\n"
"  cogito_node* n = cogito_checkbox_new(text, group);\n"
"  if (ttmp) ergo_release_val(EV_STR(ttmp));\n"
"  if (gtmp) ergo_release_val(EV_STR(gtmp));\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static ErgoVal __cogito_switch(ErgoVal textv) {\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* text = cogito_required_cstr(textv, &tmp);\n"
"  cogito_node* n = cogito_switch_new(text);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static ErgoVal __cogito_textfield(ErgoVal textv) {\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* text = cogito_required_cstr(textv, &tmp);\n"
"  cogito_node* n = cogito_textfield_new(text);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static ErgoVal __cogito_textview(ErgoVal textv) {\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* text = cogito_required_cstr(textv, &tmp);\n"
"  cogito_node* n = cogito_textview_new(text);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static ErgoVal __cogito_searchfield(ErgoVal textv) {\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* text = cogito_required_cstr(textv, &tmp);\n"
"  cogito_node* n = cogito_searchfield_new(text);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static void __cogito_searchfield_set_text(ErgoVal sfv, ErgoVal textv) {\n"
"  cogito_node* sf = cogito_node_from_val(sfv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* text = cogito_required_cstr(textv, &tmp);\n"
"  cogito_searchfield_set_text(sf, text);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"static ErgoVal __cogito_searchfield_get_text(ErgoVal sfv) {\n"
"  cogito_node* sf = cogito_node_from_val(sfv);\n"
"  const char* text = cogito_searchfield_get_text(sf);\n"
"  return EV_STR(stdr_str_lit(text ? text : \"\"));\n"
"}\n"
"\n"
"static void __cogito_searchfield_on_change(ErgoVal sfv, ErgoVal handler) {\n"
"  cogito_node* sf = cogito_node_from_val(sfv);\n"
"  CogitoHandle* h = (CogitoHandle*)sfv.as.p;\n"
"  if (handler.tag != EVT_FN) {\n"
"    cogito_set_handler(h, &h->on_change, handler);\n"
"    cogito_searchfield_on_change(sf, NULL, NULL);\n"
"    return;\n"
"  }\n"
"  cogito_set_handler(h, &h->on_change, handler);\n"
"  cogito_searchfield_on_change(sf, cogito_cb_change, h);\n"
"}\n"
"\n"
"static ErgoVal __cogito_dropdown(void) {\n"
"  cogito_node* n = cogito_dropdown_new();\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static ErgoVal __cogito_datepicker(void) {\n"
"  cogito_node* n = cogito_datepicker_new();\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static void __cogito_datepicker_on_change(ErgoVal dpv, ErgoVal handler) {\n"
"  cogito_node* dp = cogito_node_from_val(dpv);\n"
"  CogitoHandle* h = (CogitoHandle*)dpv.as.p;\n"
"  if (handler.tag != EVT_FN) {\n"
"    cogito_set_handler(h, &h->on_change, handler);\n"
"    cogito_datepicker_on_change(dp, NULL, NULL);\n"
"    return;\n"
"  }\n"
"  cogito_set_handler(h, &h->on_change, handler);\n"
"  cogito_datepicker_on_change(dp, cogito_cb_change, h);\n"
"}\n"
"\n"
"static ErgoVal __cogito_stepper(ErgoVal minv, ErgoVal maxv, ErgoVal valuev, ErgoVal stepv) {\n"
"  cogito_node* n = cogito_stepper_new(ergo_as_float(minv), ergo_as_float(maxv), ergo_as_float(valuev), ergo_as_float(stepv));\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static ErgoVal __cogito_slider(ErgoVal minv, ErgoVal maxv, ErgoVal valuev) {\n"
"  cogito_node* n = cogito_slider_new(ergo_as_float(minv), ergo_as_float(maxv), ergo_as_float(valuev));\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static ErgoVal __cogito_slider_range(ErgoVal minv, ErgoVal maxv, ErgoVal startv, ErgoVal endv) {\n"
"  cogito_node* n = cogito_slider_range_new(ergo_as_float(minv), ergo_as_float(maxv), ergo_as_float(startv), ergo_as_float(endv));\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static ErgoVal __cogito_tabs(void) {\n"
"  cogito_node* n = cogito_tabs_new();\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static ErgoVal __cogito_nav_rail(void) {\n"
"  cogito_node* n = cogito_nav_rail_new();\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static ErgoVal __cogito_segmented(void) {\n"
"  cogito_node* n = cogito_segmented_new();\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static ErgoVal __cogito_view_switcher(void) {\n"
"  cogito_node* n = cogito_view_switcher_new();\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static ErgoVal __cogito_progress(ErgoVal valuev) {\n"
"  cogito_node* n = cogito_progress_new(ergo_as_float(valuev));\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static ErgoVal __cogito_treeview(void) {\n"
"  cogito_node* n = cogito_treeview_new();\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static ErgoVal __cogito_colorpicker(void) {\n"
"  cogito_node* n = cogito_colorpicker_new();\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static void __cogito_colorpicker_on_change(ErgoVal cpv, ErgoVal handler) {\n"
"  cogito_node* cp = cogito_node_from_val(cpv);\n"
"  CogitoHandle* h = (CogitoHandle*)cpv.as.p;\n"
"  if (handler.tag != EVT_FN) {\n"
"    cogito_set_handler(h, &h->on_change, handler);\n"
"    cogito_colorpicker_on_change(cp, NULL, NULL);\n"
"    return;\n"
"  }\n"
"  cogito_set_handler(h, &h->on_change, handler);\n"
"  cogito_colorpicker_on_change(cp, cogito_cb_change, h);\n"
"}\n"
"\n"
"static ErgoVal __cogito_toasts(void) {\n"
"  cogito_node* n = cogito_toasts_new();\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static ErgoVal __cogito_toast(ErgoVal textv) {\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* text = cogito_required_cstr(textv, &tmp);\n"
"  cogito_node* n = cogito_toast_new(text);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static ErgoVal __cogito_toolbar(void) {\n"
"  cogito_node* n = cogito_bottom_toolbar_new();\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static ErgoVal __cogito_vstack(void) {\n"
"  return cogito_wrap_node(cogito_node_new(COGITO_NODE_VSTACK), COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static ErgoVal __cogito_hstack(void) {\n"
"  return cogito_wrap_node(cogito_node_new(COGITO_NODE_HSTACK), COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static ErgoVal __cogito_zstack(void) {\n"
"  return cogito_wrap_node(cogito_node_new(COGITO_NODE_ZSTACK), COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static ErgoVal __cogito_fixed(void) {\n"
"  return cogito_wrap_node(cogito_node_new(COGITO_NODE_FIXED), COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static ErgoVal __cogito_scroller(void) {\n"
"  return cogito_wrap_node(cogito_node_new(COGITO_NODE_SCROLLER), COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static ErgoVal __cogito_carousel(void) {\n"
"  return cogito_wrap_node(cogito_node_new(COGITO_NODE_CAROUSEL), COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static void __cogito_carousel_set_active_index(ErgoVal carouselv, ErgoVal idxv) {\n"
"  cogito_node* carousel = cogito_node_from_val(carouselv);\n"
"  cogito_carousel_set_active_index(carousel, (int)ergo_as_int(idxv));\n"
"}\n"
"\n"
"static ErgoVal __cogito_carousel_get_active_index(ErgoVal carouselv) {\n"
"  cogito_node* carousel = cogito_node_from_val(carouselv);\n"
"  int idx = cogito_carousel_get_active_index(carousel);\n"
"  return EV_INT(idx);\n"
"}\n"
"\n"
"static ErgoVal __cogito_carousel_item(void) {\n"
"  return cogito_wrap_node(cogito_carousel_item_new(), COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static void __cogito_carousel_item_set_text(ErgoVal itemv, ErgoVal textv) {\n"
"  cogito_node* item = cogito_node_from_val(itemv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* text = cogito_required_cstr(textv, &tmp);\n"
"  cogito_carousel_item_set_text(item, text);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"static void __cogito_carousel_item_set_halign(ErgoVal itemv, ErgoVal alignv) {\n"
"  cogito_node* item = cogito_node_from_val(itemv);\n"
"  cogito_carousel_item_set_halign(item, (int)ergo_as_int(alignv));\n"
"}\n"
"\n"
"static void __cogito_carousel_item_set_valign(ErgoVal itemv, ErgoVal alignv) {\n"
"  cogito_node* item = cogito_node_from_val(itemv);\n"
"  cogito_carousel_item_set_valign(item, (int)ergo_as_int(alignv));\n"
"}\n"
"\n"
"static ErgoVal __cogito_list(void) {\n"
"  return cogito_wrap_node(cogito_node_new(COGITO_NODE_LIST), COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static ErgoVal __cogito_grid(ErgoVal cols) {\n"
"  return cogito_wrap_node(cogito_grid_new_with_cols((int)ergo_as_int(cols)), COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static void __cogito_container_add(ErgoVal parentv, ErgoVal childv) {\n"
"  cogito_node* parent = cogito_node_from_val(parentv);\n"
"  cogito_node* child = cogito_node_from_val(childv);\n"
"  cogito_node_add(parent, child);\n"
"}\n"
"\n"
"static void __cogito_container_set_margins(ErgoVal nodev, ErgoVal left, ErgoVal top, ErgoVal right, ErgoVal bottom) {\n"
"  cogito_node* node = cogito_node_from_val(nodev);\n"
"  cogito_node_set_margins(node, (int)ergo_as_int(left), (int)ergo_as_int(top), (int)ergo_as_int(right), (int)ergo_as_int(bottom));\n"
"}\n"
"\n"
"static void __cogito_container_set_align(ErgoVal nodev, ErgoVal align) {\n"
"  cogito_node* node = cogito_node_from_val(nodev);\n"
"  cogito_node_set_align(node, (int)ergo_as_int(align));\n"
"}\n"
"\n"
"static void __cogito_container_set_halign(ErgoVal nodev, ErgoVal align) {\n"
"  cogito_node* node = cogito_node_from_val(nodev);\n"
"  cogito_node_set_halign(node, (int)ergo_as_int(align));\n"
"}\n"
"\n"
"static void __cogito_container_set_valign(ErgoVal nodev, ErgoVal align) {\n"
"  cogito_node* node = cogito_node_from_val(nodev);\n"
"  cogito_node_set_valign(node, (int)ergo_as_int(align));\n"
"}\n"
"\n"
"static void __cogito_container_set_hexpand(ErgoVal nodev, ErgoVal expand) {\n"
"  cogito_node* node = cogito_node_from_val(nodev);\n"
"  cogito_node_set_hexpand(node, ergo_as_bool(expand));\n"
"}\n"
"\n"
"static void __cogito_container_set_vexpand(ErgoVal nodev, ErgoVal expand) {\n"
"  cogito_node* node = cogito_node_from_val(nodev);\n"
"  bool expand_bool = ergo_as_bool(expand);\n"
"  cogito_node_set_vexpand(node, expand_bool);\n"
"}\n"
"\n"
"static void __cogito_container_set_gap(ErgoVal nodev, ErgoVal gap) {\n"
"  cogito_node* node = cogito_node_from_val(nodev);\n"
"  cogito_node_set_gap(node, (int)ergo_as_int(gap));\n"
"}\n"
"\n"
"static void __cogito_container_set_padding(ErgoVal nodev, ErgoVal left, ErgoVal top, ErgoVal right, ErgoVal bottom) {\n"
"  cogito_node* node = cogito_node_from_val(nodev);\n"
"  cogito_node_set_padding(node, (int)ergo_as_int(left), (int)ergo_as_int(top), (int)ergo_as_int(right), (int)ergo_as_int(bottom));\n"
"}\n"
"\n"
"static void __cogito_fixed_set_pos(ErgoVal fixedv, ErgoVal childv, ErgoVal xv, ErgoVal yv) {\n"
"  cogito_node* fixed = cogito_node_from_val(fixedv);\n"
"  cogito_node* child = cogito_node_from_val(childv);\n"
"  cogito_fixed_set_pos(fixed, child, (int)ergo_as_int(xv), (int)ergo_as_int(yv));\n"
"}\n"
"\n"
"static void __cogito_scroller_set_axes(ErgoVal scv, ErgoVal hv, ErgoVal vv) {\n"
"  cogito_node* sc = cogito_node_from_val(scv);\n"
"  bool h = hv.tag == EVT_BOOL ? hv.as.b : false;\n"
"  bool v = vv.tag == EVT_BOOL ? vv.as.b : false;\n"
"  cogito_scroller_set_axes(sc, h, v);\n"
"}\n"
"\n"
"static void __cogito_grid_set_gap(ErgoVal gridv, ErgoVal xv, ErgoVal yv) {\n"
"  cogito_node* grid = cogito_node_from_val(gridv);\n"
"  cogito_grid_set_gap(grid, (int)ergo_as_int(xv), (int)ergo_as_int(yv));\n"
"}\n"
"\n"
"static void __cogito_grid_set_span(ErgoVal childv, ErgoVal col_span, ErgoVal row_span) {\n"
"  cogito_node* child = cogito_node_from_val(childv);\n"
"  cogito_grid_set_span(child, (int)ergo_as_int(col_span), (int)ergo_as_int(row_span));\n"
"}\n"
"\n"
"static void __cogito_grid_set_align(ErgoVal childv, ErgoVal halign, ErgoVal valign) {\n"
"  cogito_node* child = cogito_node_from_val(childv);\n"
"  cogito_grid_set_align(child, (int)ergo_as_int(halign), (int)ergo_as_int(valign));\n"
"}\n"
"\n"
"static void __cogito_node_set_disabled(ErgoVal nodev, ErgoVal onv) {\n"
"  cogito_node* node = cogito_node_from_val(nodev);\n"
"  cogito_node_set_disabled(node, onv.tag == EVT_BOOL ? onv.as.b : false);\n"
"}\n"
"\n"
"static void __cogito_node_set_editable(ErgoVal nodev, ErgoVal onv) {\n"
"  cogito_node* node = cogito_node_from_val(nodev);\n"
"  cogito_node_set_editable(node, onv.tag == EVT_BOOL ? onv.as.b : false);\n"
"}\n"
"\n"
"static ErgoVal __cogito_node_get_editable(ErgoVal nodev) {\n"
"  cogito_node* node = cogito_node_from_val(nodev);\n"
"  return EV_BOOL(cogito_node_get_editable(node));\n"
"}\n"
"\n"
"static void __cogito_node_set_id(ErgoVal nodev, ErgoVal idv) {\n"
"  cogito_node* node = cogito_node_from_val(nodev);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* id = cogito_optional_cstr(idv, &tmp);\n"
"  if (id) cogito_node_set_id(node, id);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"static void __cogito_button_set_text(ErgoVal btnv, ErgoVal textv) {\n"
"  cogito_node* btn = cogito_node_from_val(btnv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* text = cogito_required_cstr(textv, &tmp);\n"
"  cogito_button_set_text(btn, text);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"static void __cogito_button_set_size(ErgoVal btnv, ErgoVal sizev) {\n"
"  cogito_node* btn = cogito_node_from_val(btnv);\n"
"  cogito_button_set_size(btn, (int)ergo_as_int(sizev));\n"
"}\n"
"\n"
"static ErgoVal __cogito_button_get_size(ErgoVal btnv) {\n"
"  cogito_node* btn = cogito_node_from_val(btnv);\n"
"  return EV_INT(cogito_button_get_size(btn));\n"
"}\n"
"\n"
"static void __cogito_button_on_click(ErgoVal btnv, ErgoVal handler) {\n"
"  cogito_node* btn = cogito_node_from_val(btnv);\n"
"  CogitoHandle* h = (CogitoHandle*)btnv.as.p;\n"
"  if (handler.tag != EVT_FN) {\n"
"    cogito_set_handler(h, &h->on_click, handler);\n"
"    cogito_node_on_click(btn, NULL, NULL);\n"
"    return;\n"
"  }\n"
"  cogito_set_handler(h, &h->on_click, handler);\n"
"  cogito_node_on_click(btn, cogito_cb_click, h);\n"
"}\n"
"\n"
"static void __cogito_button_add_menu(ErgoVal btnv, ErgoVal labelv, ErgoVal handler) {\n"
"  cogito_node* btn = cogito_node_from_val(btnv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* label = cogito_required_cstr(labelv, &tmp);\n"
"  CogitoMenuHandler* mh = handler.tag == EVT_FN ? cogito_menu_handler_new(handler) : NULL;\n"
"  cogito_button_add_menu(btn, label, mh ? cogito_cb_menu : NULL, mh);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"static void __cogito_iconbtn_add_menu(ErgoVal btnv, ErgoVal labelv, ErgoVal handler) {\n"
"  cogito_node* btn = cogito_node_from_val(btnv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* label = cogito_required_cstr(labelv, &tmp);\n"
"  CogitoMenuHandler* mh = handler.tag == EVT_FN ? cogito_menu_handler_new(handler) : NULL;\n"
"  cogito_iconbtn_add_menu(btn, label, mh ? cogito_cb_menu : NULL, mh);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"// Icon button setters/getters\n"
"static void __cogito_iconbtn_set_shape(ErgoVal btnv, ErgoVal shapev) {\n"
"  cogito_node* btn = cogito_node_from_val(btnv);\n"
"  cogito_iconbtn_set_shape(btn, (int)ergo_as_int(shapev));\n"
"}\n"
"\n"
"static ErgoVal __cogito_iconbtn_get_shape(ErgoVal btnv) {\n"
"  cogito_node* btn = cogito_node_from_val(btnv);\n"
"  return EV_INT(cogito_iconbtn_get_shape(btn));\n"
"}\n"
"\n"
"static void __cogito_iconbtn_set_color_style(ErgoVal btnv, ErgoVal stylev) {\n"
"  cogito_node* btn = cogito_node_from_val(btnv);\n"
"  cogito_iconbtn_set_color_style(btn, (int)ergo_as_int(stylev));\n"
"}\n"
"\n"
"static ErgoVal __cogito_iconbtn_get_color_style(ErgoVal btnv) {\n"
"  cogito_node* btn = cogito_node_from_val(btnv);\n"
"  return EV_INT(cogito_iconbtn_get_color_style(btn));\n"
"}\n"
"\n"
"static void __cogito_iconbtn_set_width(ErgoVal btnv, ErgoVal widthv) {\n"
"  cogito_node* btn = cogito_node_from_val(btnv);\n"
"  cogito_iconbtn_set_width(btn, (int)ergo_as_int(widthv));\n"
"}\n"
"\n"
"static ErgoVal __cogito_iconbtn_get_width(ErgoVal btnv) {\n"
"  cogito_node* btn = cogito_node_from_val(btnv);\n"
"  return EV_INT(cogito_iconbtn_get_width(btn));\n"
"}\n"
"\n"
"static void __cogito_iconbtn_set_toggle(ErgoVal btnv, ErgoVal togglev) {\n"
"  cogito_node* btn = cogito_node_from_val(btnv);\n"
"  cogito_iconbtn_set_toggle(btn, ergo_as_bool(togglev));\n"
"}\n"
"\n"
"static ErgoVal __cogito_iconbtn_get_toggle(ErgoVal btnv) {\n"
"  cogito_node* btn = cogito_node_from_val(btnv);\n"
"  return EV_BOOL(cogito_iconbtn_get_toggle(btn));\n"
"}\n"
"\n"
"static void __cogito_iconbtn_set_checked(ErgoVal btnv, ErgoVal checkedv) {\n"
"  cogito_node* btn = cogito_node_from_val(btnv);\n"
"  cogito_iconbtn_set_checked(btn, ergo_as_bool(checkedv));\n"
"}\n"
"\n"
"static ErgoVal __cogito_iconbtn_get_checked(ErgoVal btnv) {\n"
"  cogito_node* btn = cogito_node_from_val(btnv);\n"
"  return EV_BOOL(cogito_iconbtn_get_checked(btn));\n"
"}\n"
"\n"
"static void __cogito_checkbox_set_checked(ErgoVal cbv, ErgoVal checkedv) {\n"
"  cogito_node* cb = cogito_node_from_val(cbv);\n"
"  cogito_checkbox_set_checked(cb, checkedv.tag == EVT_BOOL ? checkedv.as.b : false);\n"
"}\n"
"\n"
"static ErgoVal __cogito_checkbox_get_checked(ErgoVal cbv) {\n"
"  cogito_node* cb = cogito_node_from_val(cbv);\n"
"  return EV_BOOL(cogito_checkbox_get_checked(cb));\n"
"}\n"
"\n"
"static void __cogito_switch_set_checked(ErgoVal swv, ErgoVal checkedv) {\n"
"  cogito_node* sw = cogito_node_from_val(swv);\n"
"  cogito_switch_set_checked(sw, checkedv.tag == EVT_BOOL ? checkedv.as.b : false);\n"
"}\n"
"\n"
"static ErgoVal __cogito_switch_get_checked(ErgoVal swv) {\n"
"  cogito_node* sw = cogito_node_from_val(swv);\n"
"  return EV_BOOL(cogito_switch_get_checked(sw));\n"
"}\n"
"\n"
"static void __cogito_checkbox_on_change(ErgoVal cbv, ErgoVal handler) {\n"
"  cogito_node* cb = cogito_node_from_val(cbv);\n"
"  CogitoHandle* h = (CogitoHandle*)cbv.as.p;\n"
"  if (handler.tag != EVT_FN) {\n"
"    cogito_set_handler(h, &h->on_change, handler);\n"
"    cogito_checkbox_on_change(cb, NULL, NULL);\n"
"    return;\n"
"  }\n"
"  cogito_set_handler(h, &h->on_change, handler);\n"
"  cogito_checkbox_on_change(cb, cogito_cb_change, h);\n"
"}\n"
"\n"
"static void __cogito_switch_on_change(ErgoVal swv, ErgoVal handler) {\n"
"  cogito_node* sw = cogito_node_from_val(swv);\n"
"  CogitoHandle* h = (CogitoHandle*)swv.as.p;\n"
"  if (handler.tag != EVT_FN) {\n"
"    cogito_set_handler(h, &h->on_change, handler);\n"
"    cogito_switch_on_change(sw, NULL, NULL);\n"
"    return;\n"
"  }\n"
"  cogito_set_handler(h, &h->on_change, handler);\n"
"  cogito_switch_on_change(sw, cogito_cb_change, h);\n"
"}\n"
"\n"
"static void __cogito_textfield_set_text(ErgoVal tfv, ErgoVal textv) {\n"
"  cogito_node* tf = cogito_node_from_val(tfv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* text = cogito_required_cstr(textv, &tmp);\n"
"  cogito_textfield_set_text(tf, text);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"static ErgoVal __cogito_textfield_get_text(ErgoVal tfv) {\n"
"  cogito_node* tf = cogito_node_from_val(tfv);\n"
"  const char* text = cogito_textfield_get_text(tf);\n"
"  return EV_STR(stdr_str_lit(text ? text : \"\"));\n"
"}\n"
"\n"
"static void __cogito_textfield_set_hint(ErgoVal tfv, ErgoVal hintv) {\n"
"  cogito_node* tf = cogito_node_from_val(tfv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* hint = cogito_required_cstr(hintv, &tmp);\n"
"  cogito_textfield_set_hint(tf, hint);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"static ErgoVal __cogito_textfield_get_hint(ErgoVal tfv) {\n"
"  cogito_node* tf = cogito_node_from_val(tfv);\n"
"  const char* hint = cogito_textfield_get_hint(tf);\n"
"  return EV_STR(stdr_str_lit(hint ? hint : \"\"));\n"
"}\n"
"\n"
"static void __cogito_textfield_on_change(ErgoVal tfv, ErgoVal handler) {\n"
"  cogito_node* tf = cogito_node_from_val(tfv);\n"
"  CogitoHandle* h = (CogitoHandle*)tfv.as.p;\n"
"  if (handler.tag != EVT_FN) {\n"
"    cogito_set_handler(h, &h->on_change, handler);\n"
"    cogito_textfield_on_change(tf, NULL, NULL);\n"
"    return;\n"
"  }\n"
"  cogito_set_handler(h, &h->on_change, handler);\n"
"  cogito_textfield_on_change(tf, cogito_cb_change, h);\n"
"}\n"
"\n"
"static void __cogito_textview_set_text(ErgoVal tvv, ErgoVal textv) {\n"
"  cogito_node* tv = cogito_node_from_val(tvv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* text = cogito_required_cstr(textv, &tmp);\n"
"  cogito_textview_set_text(tv, text);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"static ErgoVal __cogito_textview_get_text(ErgoVal tvv) {\n"
"  cogito_node* tv = cogito_node_from_val(tvv);\n"
"  const char* text = cogito_textview_get_text(tv);\n"
"  return EV_STR(stdr_str_lit(text ? text : \"\"));\n"
"}\n"
"\n"
"static void __cogito_textview_on_change(ErgoVal tvv, ErgoVal handler) {\n"
"  cogito_node* tv = cogito_node_from_val(tvv);\n"
"  CogitoHandle* h = (CogitoHandle*)tvv.as.p;\n"
"  if (handler.tag != EVT_FN) {\n"
"    cogito_set_handler(h, &h->on_change, handler);\n"
"    cogito_textview_on_change(tv, NULL, NULL);\n"
"    return;\n"
"  }\n"
"  cogito_set_handler(h, &h->on_change, handler);\n"
"  cogito_textview_on_change(tv, cogito_cb_change, h);\n"
"}\n"
"\n"
"static void __cogito_dropdown_set_items(ErgoVal ddv, ErgoVal itemsv) {\n"
"  cogito_node* dd = cogito_node_from_val(ddv);\n"
"  if (itemsv.tag != EVT_ARR) ergo_trap(\"cogito.dropdown_set_items expects array\");\n"
"  ErgoArr* arr = (ErgoArr*)itemsv.as.p;\n"
"  size_t count = arr->len;\n"
"  const char** items = (const char**)calloc(count, sizeof(char*));\n"
"  ErgoStr** temps = (ErgoStr**)calloc(count, sizeof(ErgoStr*));\n"
"  for (size_t i = 0; i < count; i++) {\n"
"    items[i] = cogito_required_cstr(arr->items[i], &temps[i]);\n"
"  }\n"
"  cogito_dropdown_set_items(dd, items, count);\n"
"  for (size_t i = 0; i < count; i++) {\n"
"    if (temps[i]) ergo_release_val(EV_STR(temps[i]));\n"
"  }\n"
"  free(temps);\n"
"  free(items);\n"
"}\n"
"\n"
"static void __cogito_dropdown_set_selected(ErgoVal ddv, ErgoVal idxv) {\n"
"  cogito_node* dd = cogito_node_from_val(ddv);\n"
"  cogito_dropdown_set_selected(dd, (int)ergo_as_int(idxv));\n"
"}\n"
"\n"
"static ErgoVal __cogito_dropdown_get_selected(ErgoVal ddv) {\n"
"  cogito_node* dd = cogito_node_from_val(ddv);\n"
"  return EV_INT(cogito_dropdown_get_selected(dd));\n"
"}\n"
"\n"
"static void __cogito_dropdown_on_change(ErgoVal ddv, ErgoVal handler) {\n"
"  cogito_node* dd = cogito_node_from_val(ddv);\n"
"  CogitoHandle* h = (CogitoHandle*)ddv.as.p;\n"
"  if (handler.tag != EVT_FN) {\n"
"    cogito_set_handler(h, &h->on_change, handler);\n"
"    cogito_dropdown_on_change(dd, NULL, NULL);\n"
"    return;\n"
"  }\n"
"  cogito_set_handler(h, &h->on_change, handler);\n"
"  cogito_dropdown_on_change(dd, cogito_cb_change, h);\n"
"}\n"
"\n"
"static void __cogito_slider_set_value(ErgoVal slv, ErgoVal valuev) {\n"
"  cogito_node* sl = cogito_node_from_val(slv);\n"
"  cogito_slider_set_value(sl, ergo_as_float(valuev));\n"
"}\n"
"\n"
"static ErgoVal __cogito_slider_get_value(ErgoVal slv) {\n"
"  cogito_node* sl = cogito_node_from_val(slv);\n"
"  return EV_FLOAT(cogito_slider_get_value(sl));\n"
"}\n"
"\n"
"static void __cogito_slider_set_size(ErgoVal slv, ErgoVal sizev) {\n"
"  cogito_node* sl = cogito_node_from_val(slv);\n"
"  cogito_slider_set_size(sl, (int)ergo_as_int(sizev));\n"
"}\n"
"\n"
"static ErgoVal __cogito_slider_get_size(ErgoVal slv) {\n"
"  cogito_node* sl = cogito_node_from_val(slv);\n"
"  return EV_INT(cogito_slider_get_size(sl));\n"
"}\n"
"\n"
"static void __cogito_slider_set_icon(ErgoVal slv, ErgoVal iconv) {\n"
"  cogito_node* sl = cogito_node_from_val(slv);\n"
"  if (iconv.tag == EVT_NULL) {\n"
"    cogito_slider_set_icon(sl, NULL);\n"
"    return;\n"
"  }\n"
"  if (iconv.tag == EVT_STR) {\n"
"    ErgoStr* s = (ErgoStr*)iconv.as.p;\n"
"    cogito_slider_set_icon(sl, s ? s->data : NULL);\n"
"    return;\n"
"  }\n"
"  ErgoStr* s = stdr_to_string(iconv);\n"
"  cogito_slider_set_icon(sl, s ? s->data : NULL);\n"
"  if (s) ergo_release_val(EV_STR(s));\n"
"}\n"
"\n"
"static void __cogito_slider_set_centered(ErgoVal slv, ErgoVal onv) {\n"
"  cogito_node* sl = cogito_node_from_val(slv);\n"
"  cogito_slider_set_centered(sl, ergo_as_bool(onv));\n"
"}\n"
"\n"
"static ErgoVal __cogito_slider_get_centered(ErgoVal slv) {\n"
"  cogito_node* sl = cogito_node_from_val(slv);\n"
"  return EV_BOOL(cogito_slider_get_centered(sl));\n"
"}\n"
"\n"
"static void __cogito_slider_set_range(ErgoVal slv, ErgoVal startv, ErgoVal endv) {\n"
"  cogito_node* sl = cogito_node_from_val(slv);\n"
"  cogito_slider_set_range(sl, ergo_as_float(startv), ergo_as_float(endv));\n"
"}\n"
"\n"
"static void __cogito_slider_set_range_start(ErgoVal slv, ErgoVal startv) {\n"
"  cogito_node* sl = cogito_node_from_val(slv);\n"
"  cogito_slider_set_range_start(sl, ergo_as_float(startv));\n"
"}\n"
"\n"
"static void __cogito_slider_set_range_end(ErgoVal slv, ErgoVal endv) {\n"
"  cogito_node* sl = cogito_node_from_val(slv);\n"
"  cogito_slider_set_range_end(sl, ergo_as_float(endv));\n"
"}\n"
"\n"
"static ErgoVal __cogito_slider_get_range_start(ErgoVal slv) {\n"
"  cogito_node* sl = cogito_node_from_val(slv);\n"
"  return EV_FLOAT(cogito_slider_get_range_start(sl));\n"
"}\n"
"\n"
"static ErgoVal __cogito_slider_get_range_end(ErgoVal slv) {\n"
"  cogito_node* sl = cogito_node_from_val(slv);\n"
"  return EV_FLOAT(cogito_slider_get_range_end(sl));\n"
"}\n"
"\n"
"static void __cogito_slider_on_change(ErgoVal slv, ErgoVal handler) {\n"
"  cogito_node* sl = cogito_node_from_val(slv);\n"
"  CogitoHandle* h = (CogitoHandle*)slv.as.p;\n"
"  if (handler.tag != EVT_FN) {\n"
"    cogito_set_handler(h, &h->on_change, handler);\n"
"    cogito_slider_on_change(sl, NULL, NULL);\n"
"    return;\n"
"  }\n"
"  cogito_set_handler(h, &h->on_change, handler);\n"
"  cogito_slider_on_change(sl, cogito_cb_change, h);\n"
"}\n"
"\n"
"static void __cogito_stepper_set_value(ErgoVal stv, ErgoVal valuev) {\n"
"  cogito_node* st = cogito_node_from_val(stv);\n"
"  cogito_stepper_set_value(st, ergo_as_float(valuev));\n"
"}\n"
"\n"
"static ErgoVal __cogito_stepper_get_value(ErgoVal stv) {\n"
"  cogito_node* st = cogito_node_from_val(stv);\n"
"  return EV_FLOAT(cogito_stepper_get_value(st));\n"
"}\n"
"\n"
"static void __cogito_stepper_on_change(ErgoVal stv, ErgoVal handler) {\n"
"  cogito_node* st = cogito_node_from_val(stv);\n"
"  CogitoHandle* h = (CogitoHandle*)stv.as.p;\n"
"  if (handler.tag != EVT_FN) {\n"
"    cogito_set_handler(h, &h->on_change, handler);\n"
"    cogito_stepper_on_change(st, NULL, NULL);\n"
"    return;\n"
"  }\n"
"  cogito_set_handler(h, &h->on_change, handler);\n"
"  cogito_stepper_on_change(st, cogito_cb_change, h);\n"
"}\n"
"\n"
"static void __cogito_segmented_on_select(ErgoVal segv, ErgoVal handler) {\n"
"  cogito_node* seg = cogito_node_from_val(segv);\n"
"  CogitoHandle* h = (CogitoHandle*)segv.as.p;\n"
"  if (handler.tag != EVT_FN) {\n"
"    cogito_set_handler(h, &h->on_change, handler);\n"
"    cogito_segmented_on_select(seg, NULL, NULL);\n"
"    return;\n"
"  }\n"
"  cogito_set_handler(h, &h->on_change, handler);\n"
"  cogito_segmented_on_select(seg, cogito_cb_change, h);\n"
"}\n"
"\n"
"static void __cogito_tabs_set_items(ErgoVal tabsv, ErgoVal itemsv) {\n"
"  cogito_node* tabs = cogito_node_from_val(tabsv);\n"
"  if (itemsv.tag != EVT_ARR) ergo_trap(\"cogito.tabs_set_items expects array\");\n"
"  ErgoArr* arr = (ErgoArr*)itemsv.as.p;\n"
"  size_t count = arr->len;\n"
"  const char** items = (const char**)calloc(count, sizeof(char*));\n"
"  ErgoStr** temps = (ErgoStr**)calloc(count, sizeof(ErgoStr*));\n"
"  for (size_t i = 0; i < count; i++) {\n"
"    items[i] = cogito_required_cstr(arr->items[i], &temps[i]);\n"
"  }\n"
"  cogito_tabs_set_items(tabs, items, count);\n"
"  for (size_t i = 0; i < count; i++) {\n"
"    if (temps[i]) ergo_release_val(EV_STR(temps[i]));\n"
"  }\n"
"  free(temps);\n"
"  free(items);\n"
"}\n"
"\n"
"static void __cogito_tabs_set_ids(ErgoVal tabsv, ErgoVal itemsv) {\n"
"  cogito_node* tabs = cogito_node_from_val(tabsv);\n"
"  if (itemsv.tag != EVT_ARR) ergo_trap(\"cogito.tabs_set_ids expects array\");\n"
"  ErgoArr* arr = (ErgoArr*)itemsv.as.p;\n"
"  size_t count = arr->len;\n"
"  const char** items = (const char**)calloc(count, sizeof(char*));\n"
"  ErgoStr** temps = (ErgoStr**)calloc(count, sizeof(ErgoStr*));\n"
"  for (size_t i = 0; i < count; i++) {\n"
"    items[i] = cogito_required_cstr(arr->items[i], &temps[i]);\n"
"  }\n"
"  cogito_tabs_set_ids(tabs, items, count);\n"
"  for (size_t i = 0; i < count; i++) {\n"
"    if (temps[i]) ergo_release_val(EV_STR(temps[i]));\n"
"  }\n"
"  free(temps);\n"
"  free(items);\n"
"}\n"
"\n"
"static void __cogito_tabs_set_selected(ErgoVal tabsv, ErgoVal idxv) {\n"
"  cogito_node* tabs = cogito_node_from_val(tabsv);\n"
"  cogito_tabs_set_selected(tabs, (int)ergo_as_int(idxv));\n"
"}\n"
"\n"
"static ErgoVal __cogito_tabs_get_selected(ErgoVal tabsv) {\n"
"  cogito_node* tabs = cogito_node_from_val(tabsv);\n"
"  return EV_INT(cogito_tabs_get_selected(tabs));\n"
"}\n"
"\n"
"static void __cogito_tabs_on_change(ErgoVal tabsv, ErgoVal handler) {\n"
"  cogito_node* tabs = cogito_node_from_val(tabsv);\n"
"  CogitoHandle* h = (CogitoHandle*)tabsv.as.p;\n"
"  if (handler.tag != EVT_FN) {\n"
"    cogito_set_handler(h, &h->on_change, handler);\n"
"    cogito_tabs_on_change(tabs, NULL, NULL);\n"
"    return;\n"
"  }\n"
"  cogito_set_handler(h, &h->on_change, handler);\n"
"  cogito_tabs_on_change(tabs, cogito_cb_change, h);\n"
"}\n"
"\n"
"static void __cogito_tabs_bind(ErgoVal tabsv, ErgoVal viewv) {\n"
"  cogito_node* tabs = cogito_node_from_val(tabsv);\n"
"  cogito_node* view = cogito_node_from_val(viewv);\n"
"  cogito_tabs_bind(tabs, view);\n"
"}\n"
"\n"
"static void __cogito_nav_rail_set_items(ErgoVal railv, ErgoVal labelsv, ErgoVal iconsv) {\n"
"  cogito_node* rail = cogito_node_from_val(railv);\n"
"  if (labelsv.tag != EVT_ARR) ergo_trap(\"cogito.nav_rail_set_items expects array of labels\");\n"
"  ErgoArr* labels = (ErgoArr*)labelsv.as.p;\n"
"  size_t count = labels->len;\n"
"\n"
"  const char** label_strs = (const char**)calloc(count, sizeof(char*));\n"
"  ErgoStr** label_temps = (ErgoStr**)calloc(count, sizeof(ErgoStr*));\n"
"  for (size_t i = 0; i < count; i++) {\n"
"    label_strs[i] = cogito_required_cstr(labels->items[i], &label_temps[i]);\n"
"  }\n"
"\n"
"  const char** icon_strs = NULL;\n"
"  ErgoStr** icon_temps = NULL;\n"
"  if (iconsv.tag == EVT_ARR) {\n"
"    ErgoArr* icons = (ErgoArr*)iconsv.as.p;\n"
"    size_t icon_count = icons->len;\n"
"    icon_strs = (const char**)calloc(icon_count, sizeof(char*));\n"
"    icon_temps = (ErgoStr**)calloc(icon_count, sizeof(ErgoStr*));\n"
"    for (size_t i = 0; i < icon_count; i++) {\n"
"      icon_strs[i] = cogito_required_cstr(icons->items[i], &icon_temps[i]);\n"
"    }\n"
"    cogito_nav_rail_set_items(rail, label_strs, icon_strs, icon_count < count ? icon_count : count);\n"
"    for (size_t i = 0; i < icon_count; i++) {\n"
"      if (icon_temps[i]) ergo_release_val(EV_STR(icon_temps[i]));\n"
"    }\n"
"    free(icon_temps);\n"
"    free(icon_strs);\n"
"  } else {\n"
"    cogito_nav_rail_set_items(rail, label_strs, NULL, count);\n"
"  }\n"
"\n"
"  for (size_t i = 0; i < count; i++) {\n"
"    if (label_temps[i]) ergo_release_val(EV_STR(label_temps[i]));\n"
"  }\n"
"  free(label_temps);\n"
"  free(label_strs);\n"
"}\n"
"\n"
"static void __cogito_nav_rail_set_badges(ErgoVal railv, ErgoVal badgesv) {\n"
"  cogito_node* rail = cogito_node_from_val(railv);\n"
"  if (badgesv.tag == EVT_NULL) {\n"
"    cogito_nav_rail_set_badges(rail, NULL, 0);\n"
"    return;\n"
"  }\n"
"  if (badgesv.tag != EVT_ARR) ergo_trap(\"cogito.nav_rail_set_badges expects array\");\n"
"  ErgoArr* badges = (ErgoArr*)badgesv.as.p;\n"
"  size_t count = badges->len;\n"
"  int* vals = (int*)calloc(count, sizeof(int));\n"
"  for (size_t i = 0; i < count; i++) {\n"
"    ErgoVal bv = badges->items[i];\n"
"    int v = 0;\n"
"    switch (bv.tag) {\n"
"      case EVT_NULL:\n"
"        v = 0;\n"
"        break;\n"
"      case EVT_BOOL:\n"
"        v = bv.as.b ? -1 : 0;\n"
"        break;\n"
"      case EVT_INT:\n"
"        v = (int)bv.as.i;\n"
"        if (v < 0) v = -1;\n"
"        break;\n"
"      case EVT_FLOAT: {\n"
"        int rounded = (int)(bv.as.f >= 0.0 ? bv.as.f + 0.5 : bv.as.f - 0.5);\n"
"        v = rounded < 0 ? -1 : rounded;\n"
"        break;\n"
"      }\n"
"      default:\n"
"        free(vals);\n"
"        ergo_trap(\"cogito.nav_rail_set_badges expects int/bool/null entries\");\n"
"    }\n"
"    vals[i] = v;\n"
"  }\n"
"  cogito_nav_rail_set_badges(rail, vals, count);\n"
"  free(vals);\n"
"}\n"
"\n"
"static void __cogito_nav_rail_set_toggle(ErgoVal railv, ErgoVal onv) {\n"
"  cogito_node* rail = cogito_node_from_val(railv);\n"
"  cogito_nav_rail_set_toggle(rail, ergo_as_bool(onv));\n"
"}\n"
"\n"
"static void __cogito_nav_rail_set_selected(ErgoVal railv, ErgoVal idxv) {\n"
"  cogito_node* rail = cogito_node_from_val(railv);\n"
"  cogito_nav_rail_set_selected(rail, (int)ergo_as_int(idxv));\n"
"}\n"
"\n"
"static ErgoVal __cogito_nav_rail_get_selected(ErgoVal railv) {\n"
"  cogito_node* rail = cogito_node_from_val(railv);\n"
"  return EV_INT(cogito_nav_rail_get_selected(rail));\n"
"}\n"
"\n"
"static ErgoVal __cogito_bottom_nav(void) {\n"
"  cogito_node* n = cogito_bottom_nav_new();\n"
"  return cogito_wrap_node(n, COGITO_HANDLE_NODE);\n"
"}\n"
"\n"
"static void __cogito_nav_rail_on_change(ErgoVal railv, ErgoVal handler) {\n"
"  cogito_node* rail = cogito_node_from_val(railv);\n"
"  CogitoHandle* h = (CogitoHandle*)railv.as.p;\n"
"  if (handler.tag != EVT_FN) {\n"
"    cogito_set_handler(h, &h->on_select, handler);\n"
"    cogito_nav_rail_on_change(rail, NULL, NULL);\n"
"    return;\n"
"  }\n"
"  cogito_set_handler(h, &h->on_select, handler);\n"
"  cogito_nav_rail_on_change(rail, cogito_cb_select, h);\n"
"}\n"
"\n"
"static void __cogito_bottom_nav_set_items(ErgoVal navv, ErgoVal labelsv, ErgoVal iconsv) {\n"
"  cogito_node* nav = cogito_node_from_val(navv);\n"
"  if (labelsv.tag != EVT_ARR) ergo_trap(\"cogito.bottom_nav_set_items expects array of labels\");\n"
"  ErgoArr* labels = (ErgoArr*)labelsv.as.p;\n"
"  size_t count = labels->len;\n"
"  const char** label_strs = (const char**)calloc(count, sizeof(char*));\n"
"  ErgoStr** label_temps = (ErgoStr**)calloc(count, sizeof(ErgoStr*));\n"
"  for (size_t i = 0; i < count; i++) {\n"
"    label_strs[i] = cogito_required_cstr(labels->items[i], &label_temps[i]);\n"
"  }\n"
"  const char** icon_strs = NULL;\n"
"  ErgoStr** icon_temps = NULL;\n"
"  if (iconsv.tag == EVT_ARR) {\n"
"    ErgoArr* icons = (ErgoArr*)iconsv.as.p;\n"
"    size_t icon_count = icons->len;\n"
"    icon_strs = (const char**)calloc(icon_count, sizeof(char*));\n"
"    icon_temps = (ErgoStr**)calloc(icon_count, sizeof(ErgoStr*));\n"
"    for (size_t i = 0; i < icon_count; i++) {\n"
"      icon_strs[i] = cogito_required_cstr(icons->items[i], &icon_temps[i]);\n"
"    }\n"
"    cogito_bottom_nav_set_items(nav, label_strs, icon_strs, icon_count < count ? icon_count : count);\n"
"    for (size_t i = 0; i < icon_count; i++) {\n"
"      if (icon_temps[i]) ergo_release_val(EV_STR(icon_temps[i]));\n"
"    }\n"
"    free(icon_temps);\n"
"    free(icon_strs);\n"
"  } else {\n"
"    cogito_bottom_nav_set_items(nav, label_strs, NULL, count);\n"
"  }\n"
"  for (size_t i = 0; i < count; i++) {\n"
"    if (label_temps[i]) ergo_release_val(EV_STR(label_temps[i]));\n"
"  }\n"
"  free(label_temps);\n"
"  free(label_strs);\n"
"}\n"
"\n"
"static void __cogito_bottom_nav_set_selected(ErgoVal navv, ErgoVal idxv) {\n"
"  cogito_node* nav = cogito_node_from_val(navv);\n"
"  cogito_bottom_nav_set_selected(nav, (int)ergo_as_int(idxv));\n"
"}\n"
"\n"
"static ErgoVal __cogito_bottom_nav_get_selected(ErgoVal navv) {\n"
"  cogito_node* nav = cogito_node_from_val(navv);\n"
"  return EV_INT(cogito_bottom_nav_get_selected(nav));\n"
"}\n"
"\n"
"static void __cogito_bottom_nav_on_change(ErgoVal navv, ErgoVal handler) {\n"
"  cogito_node* nav = cogito_node_from_val(navv);\n"
"  CogitoHandle* h = (CogitoHandle*)navv.as.p;\n"
"  if (handler.tag != EVT_FN) {\n"
"    cogito_set_handler(h, &h->on_select, handler);\n"
"    cogito_bottom_nav_on_change(nav, NULL, NULL);\n"
"    return;\n"
"  }\n"
"  cogito_set_handler(h, &h->on_select, handler);\n"
"  cogito_bottom_nav_on_change(nav, cogito_cb_select, h);\n"
"}\n"
"\n"
"static void __cogito_view_switcher_set_active(ErgoVal viewv, ErgoVal idv) {\n"
"  cogito_node* view = cogito_node_from_val(viewv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* id = cogito_required_cstr(idv, &tmp);\n"
"  cogito_view_switcher_set_active(view, id);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"static void __cogito_view_switcher_add(ErgoVal vsv, ErgoVal idv, ErgoVal builderv) {\n"
"  cogito_node* nvs = cogito_node_from_val(vsv);\n"
"  cogito_view_switcher_add_lazy_ergo(nvs, idv, builderv);\n"
"}\n"
"\n"
"static void __cogito_view_switcher_add_lazy(ErgoVal vsv, ErgoVal idv, ErgoVal builderv) {\n"
"  __cogito_view_switcher_add(vsv, idv, builderv);\n"
"}\n"
"\n"
"static void __cogito_progress_set_value(ErgoVal pv, ErgoVal valuev) {\n"
"  cogito_node* p = cogito_node_from_val(pv);\n"
"  cogito_progress_set_value(p, ergo_as_float(valuev));\n"
"}\n"
"\n"
"static ErgoVal __cogito_progress_get_value(ErgoVal pv) {\n"
"  cogito_node* p = cogito_node_from_val(pv);\n"
"  return EV_FLOAT(cogito_progress_get_value(p));\n"
"}\n"
"\n"
"static void __cogito_progress_set_indeterminate(ErgoVal pv, ErgoVal onv) {\n"
"  cogito_node* p = cogito_node_from_val(pv);\n"
"  cogito_progress_set_indeterminate(p, ergo_as_bool(onv));\n"
"}\n"
"\n"
"static ErgoVal __cogito_progress_get_indeterminate(ErgoVal pv) {\n"
"  cogito_node* p = cogito_node_from_val(pv);\n"
"  return EV_BOOL(cogito_progress_get_indeterminate(p));\n"
"}\n"
"\n"
"static void __cogito_progress_set_thickness(ErgoVal pv, ErgoVal pxv) {\n"
"  cogito_node* p = cogito_node_from_val(pv);\n"
"  cogito_progress_set_thickness(p, (int)ergo_as_int(pxv));\n"
"}\n"
"\n"
"static ErgoVal __cogito_progress_get_thickness(ErgoVal pv) {\n"
"  cogito_node* p = cogito_node_from_val(pv);\n"
"  return EV_INT(cogito_progress_get_thickness(p));\n"
"}\n"
"\n"
"static void __cogito_progress_set_wavy(ErgoVal pv, ErgoVal onv) {\n"
"  cogito_node* p = cogito_node_from_val(pv);\n"
"  cogito_progress_set_wavy(p, ergo_as_bool(onv));\n"
"}\n"
"\n"
"static ErgoVal __cogito_progress_get_wavy(ErgoVal pv) {\n"
"  cogito_node* p = cogito_node_from_val(pv);\n"
"  return EV_BOOL(cogito_progress_get_wavy(p));\n"
"}\n"
"\n"
"static void __cogito_progress_set_circular(ErgoVal pv, ErgoVal onv) {\n"
"  cogito_node* p = cogito_node_from_val(pv);\n"
"  cogito_progress_set_circular(p, ergo_as_bool(onv));\n"
"}\n"
"\n"
"static ErgoVal __cogito_progress_get_circular(ErgoVal pv) {\n"
"  cogito_node* p = cogito_node_from_val(pv);\n"
"  return EV_BOOL(cogito_progress_get_circular(p));\n"
"}\n"
"\n"
"static void __cogito_toast_set_text(ErgoVal tv, ErgoVal textv) {\n"
"  cogito_node* t = cogito_node_from_val(tv);\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* text = cogito_required_cstr(textv, &tmp);\n"
"  cogito_toast_set_text(t, text);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"static void __cogito_toast_on_click(ErgoVal tv, ErgoVal handler) {\n"
"  cogito_node* t = cogito_node_from_val(tv);\n"
"  CogitoHandle* h = (CogitoHandle*)tv.as.p;\n"
"  if (handler.tag != EVT_FN) {\n"
"    cogito_set_handler(h, &h->on_click, handler);\n"
"    cogito_toast_on_click(t, NULL, NULL);\n"
"    return;\n"
"  }\n"
"  cogito_set_handler(h, &h->on_click, handler);\n"
"  cogito_toast_on_click(t, cogito_cb_click, h);\n"
"}\n"
"\n"
"static void __cogito_toast_set_action(ErgoVal tv, ErgoVal textv, ErgoVal handler) {\n"
"  cogito_node* t = cogito_node_from_val(tv);\n"
"  CogitoHandle* h = (CogitoHandle*)tv.as.p;\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* text = cogito_required_cstr(textv, &tmp);\n"
"  if (handler.tag != EVT_FN) {\n"
"    cogito_set_handler(h, &h->on_action, handler);\n"
"    cogito_toast_set_action(t, text, NULL, NULL);\n"
"    if (tmp) ergo_release_val(EV_STR(tmp));\n"
"    return;\n"
"  }\n"
"  cogito_set_handler(h, &h->on_action, handler);\n"
"  cogito_toast_set_action(t, text, cogito_cb_action, h);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"static void __cogito_list_on_select(ErgoVal listv, ErgoVal handler) {\n"
"  cogito_node* list = cogito_node_from_val(listv);\n"
"  CogitoHandle* h = (CogitoHandle*)listv.as.p;\n"
"  if (handler.tag != EVT_FN) {\n"
"    cogito_set_handler(h, &h->on_select, handler);\n"
"    cogito_list_on_select(list, NULL, NULL);\n"
"    return;\n"
"  }\n"
"  cogito_set_handler(h, &h->on_select, handler);\n"
"  cogito_list_on_select(list, cogito_cb_select, h);\n"
"}\n"
"\n"
"static void __cogito_list_on_activate(ErgoVal listv, ErgoVal handler) {\n"
"  cogito_node* list = cogito_node_from_val(listv);\n"
"  CogitoHandle* h = (CogitoHandle*)listv.as.p;\n"
"  if (handler.tag != EVT_FN) {\n"
"    cogito_set_handler(h, &h->on_activate, handler);\n"
"    cogito_list_on_activate(list, NULL, NULL);\n"
"    return;\n"
"  }\n"
"  cogito_set_handler(h, &h->on_activate, handler);\n"
"  cogito_list_on_activate(list, cogito_cb_activate, h);\n"
"}\n"
"\n"
"static void __cogito_grid_on_select(ErgoVal gridv, ErgoVal handler) {\n"
"  cogito_node* grid = cogito_node_from_val(gridv);\n"
"  CogitoHandle* h = (CogitoHandle*)gridv.as.p;\n"
"  if (handler.tag != EVT_FN) {\n"
"    cogito_set_handler(h, &h->on_select, handler);\n"
"    cogito_grid_on_select(grid, NULL, NULL);\n"
"    return;\n"
"  }\n"
"  cogito_set_handler(h, &h->on_select, handler);\n"
"  cogito_grid_on_select(grid, cogito_cb_select, h);\n"
"}\n"
"\n"
"static void __cogito_grid_on_activate(ErgoVal gridv, ErgoVal handler) {\n"
"  cogito_node* grid = cogito_node_from_val(gridv);\n"
"  CogitoHandle* h = (CogitoHandle*)gridv.as.p;\n"
"  if (handler.tag != EVT_FN) {\n"
"    cogito_set_handler(h, &h->on_activate, handler);\n"
"    cogito_grid_on_activate(grid, NULL, NULL);\n"
"    return;\n"
"  }\n"
"  cogito_set_handler(h, &h->on_activate, handler);\n"
"  cogito_grid_on_activate(grid, cogito_cb_activate, h);\n"
"}\n"
"\n"
"static void __cogito_build(ErgoVal nodev, ErgoVal builder) {\n"
"  if (builder.tag != EVT_FN) ergo_trap(\"cogito.build expects function\");\n"
"  ErgoVal arg = nodev;\n"
"  ergo_retain_val(arg);\n"
"  ErgoVal ret = ergo_call(builder, 1, &arg);\n"
"  ergo_release_val(arg);\n"
"  ergo_release_val(ret);\n"
"}\n"
"\n"
"static ErgoVal __cogito_state_new(ErgoVal initial) { return cogito_state_new_val(initial); }\n"
"static ErgoVal __cogito_state_get(ErgoVal state) { return cogito_state_get_val(state); }\n"
"static void __cogito_state_set(ErgoVal state, ErgoVal value) { cogito_state_set_val(state, value); }\n"
"\n"
"static void __cogito_run(ErgoVal appv, ErgoVal winv) {\n"
"  cogito_app* app = cogito_app_from_val(appv);\n"
"  cogito_window* win = cogito_window_from_val(winv);\n"
"  cogito_app_run(app, win);\n"
"}\n"
"\n"
"static void __cogito_load_sum(ErgoVal pathv) {\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* path = cogito_required_cstr(pathv, &tmp);\n"
"  cogito_load_sum_file(path);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"static void __cogito_set_script_dir(ErgoVal dirv) {\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* dir = cogito_optional_cstr(dirv, &tmp);\n"
"  if (dir && dir[0]) cogito_set_script_dir(dir);  // Call the actual cogito library function\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"}\n"
"\n"
"static ErgoVal __cogito_open_url(ErgoVal urlv) {\n"
"  ErgoStr* tmp = NULL;\n"
"  const char* url = cogito_optional_cstr(urlv, &tmp);\n"
"  bool ok = false;\n"
"  if (url && url[0]) ok = cogito_open_url(url);\n"
"  if (tmp) ergo_release_val(EV_STR(tmp));\n"
"  return EV_BOOL(ok);\n"
"}\n"
"\n"
"// ---- Codegen aliases ----\n"
"#define cogito_app_new __cogito_app\n"
"#define cogito_app_set_appid __cogito_app_set_appid\n"
"#define cogito_app_set_app_name __cogito_app_set_app_name\n"
"#define cogito_app_set_accent_color __cogito_app_set_accent_color\n"
"#define cogito_app_set_icon __cogito_app_set_icon\n"
"#define cogito_app_get_icon __cogito_app_get_icon\n"
"#define cogito_open_url __cogito_open_url\n"
"#define cogito_window_new __cogito_window\n"
"#define cogito_window_set_resizable __cogito_window_set_resizable\n"
"#define cogito_window_set_autosize __cogito_window_set_autosize\n"
"#define cogito_window_set_a11y_label __cogito_window_set_a11y_label\n"
"#define cogito_window_set_builder __cogito_window_set_builder\n"
"#define cogito_button_new __cogito_button\n"
"#define cogito_iconbtn_new __cogito_iconbtn\n"
"#define cogito_fab_new __cogito_fab\n"
"#define cogito_label_new __cogito_label\n"
"#define cogito_dialog_new __cogito_dialog\n"
"#define cogito_dialog_slot_new __cogito_dialog_slot\n"
"#define cogito_image_new __cogito_image\n"
"#define cogito_checkbox_new __cogito_checkbox\n"
"#define cogito_switch_new __cogito_switch\n"
"#define cogito_textfield_new __cogito_textfield\n"
"#define cogito_searchfield_new __cogito_searchfield\n"
"#define cogito_textview_new __cogito_textview\n"
"#define cogito_dropdown_new __cogito_dropdown\n"
"#define cogito_datepicker_new __cogito_datepicker\n"
"#define cogito_stepper_new __cogito_stepper\n"
"#define cogito_slider_new __cogito_slider\n"
"#define cogito_slider_range_new __cogito_slider_range\n"
"#define cogito_tabs_new __cogito_tabs\n"
"#define cogito_nav_rail_new __cogito_nav_rail\n"
"#define cogito_bottom_nav_new __cogito_bottom_nav\n"
"#define cogito_segmented_new __cogito_segmented\n"
"#define cogito_view_switcher_new __cogito_view_switcher\n"
"#define cogito_progress_new __cogito_progress\n"
"#define cogito_treeview_new __cogito_treeview\n"
"#define cogito_colorpicker_new __cogito_colorpicker\n"
"#define cogito_toasts_new __cogito_toasts\n"
"#define cogito_toast_new __cogito_toast\n"
"#define cogito_appbar_new __cogito_appbar\n"
"#define cogito_toolbar_new __cogito_toolbar\n"
"#define cogito_vstack_new __cogito_vstack\n"
"#define cogito_hstack_new __cogito_hstack\n"
"#define cogito_zstack_new __cogito_zstack\n"
"#define cogito_fixed_new __cogito_fixed\n"
"#define cogito_scroller_new __cogito_scroller\n"
"#define cogito_carousel_new __cogito_carousel\n"
"#define cogito_carousel_item_new __cogito_carousel_item\n"
"#define cogito_carousel_item_set_text __cogito_carousel_item_set_text\n"
"#define cogito_carousel_item_set_halign __cogito_carousel_item_set_halign\n"
"#define cogito_carousel_item_set_valign __cogito_carousel_item_set_valign\n"
"#define cogito_carousel_set_active_index __cogito_carousel_set_active_index\n"
"#define cogito_carousel_get_active_index __cogito_carousel_get_active_index\n"
"#define cogito_list_new __cogito_list\n"
"#define cogito_grid_new __cogito_grid\n"
"#define cogito_container_add __cogito_container_add\n"
"#define cogito_container_set_margins __cogito_container_set_margins\n"
"#define cogito_container_set_align __cogito_container_set_align\n"
"#define cogito_container_set_halign __cogito_container_set_halign\n"
"#define cogito_container_set_valign __cogito_container_set_valign\n"
"#define cogito_container_set_hexpand __cogito_container_set_hexpand\n"
"#define cogito_container_set_vexpand __cogito_container_set_vexpand\n"
"#define cogito_container_set_gap __cogito_container_set_gap\n"
"#define cogito_dialog_slot_show __cogito_dialog_slot_show\n"
"#define cogito_dialog_slot_clear __cogito_dialog_slot_clear\n"
"#define cogito_container_set_padding __cogito_container_set_padding\n"
"#define cogito_fixed_set_pos __cogito_fixed_set_pos\n"
"#define cogito_scroller_set_axes __cogito_scroller_set_axes\n"
"#define cogito_grid_set_gap __cogito_grid_set_gap\n"
"#define cogito_grid_set_span __cogito_grid_set_span\n"
"#define cogito_grid_set_align __cogito_grid_set_align\n"
"#define cogito_label_set_class __cogito_label_set_class\n"
"#define cogito_label_set_text __cogito_label_set_text\n"
"#define cogito_label_set_wrap __cogito_label_set_wrap\n"
"#define cogito_label_set_ellipsis __cogito_label_set_ellipsis\n"
"#define cogito_label_set_align __cogito_label_set_align\n"
"#define cogito_node_set_disabled __cogito_node_set_disabled\n"
"#define cogito_node_set_editable __cogito_node_set_editable\n"
"#define cogito_node_get_editable __cogito_node_get_editable\n"
"#define cogito_node_set_id __cogito_node_set_id\n"
"#define cogito_node_set_class __cogito_node_set_class\n"
"#define cogito_node_set_a11y_label __cogito_node_set_a11y_label\n"
"#define cogito_node_set_a11y_role __cogito_node_set_a11y_role\n"
"#define cogito_node_set_tooltip_val __cogito_node_set_tooltip\n"
"#define cogito_app_set_appid __cogito_app_set_appid\n"
"#define cogito_app_set_app_name __cogito_app_set_app_name\n"
"#define cogito_app_set_accent_color __cogito_app_set_accent_color\n"
"#define cogito_app_set_icon __cogito_app_set_icon\n"
"#define cogito_app_get_icon __cogito_app_get_icon\n"
"#define cogito_pointer_capture_set __cogito_pointer_capture\n"
"#define cogito_pointer_capture_clear __cogito_pointer_release\n"
"#define cogito_view_switcher_set_active __cogito_view_switcher_set_active\n"
"#define cogito_view_switcher_add __cogito_view_switcher_add\n"
"#define cogito_textfield_set_text __cogito_textfield_set_text\n"
"#define cogito_textfield_get_text __cogito_textfield_get_text\n"
"#define cogito_textfield_set_hint __cogito_textfield_set_hint\n"
"#define cogito_textfield_get_hint __cogito_textfield_get_hint\n"
"#define cogito_searchfield_set_text __cogito_searchfield_set_text\n"
"#define cogito_searchfield_get_text __cogito_searchfield_get_text\n"
"#define cogito_searchfield_on_change __cogito_searchfield_on_change\n"
"#define cogito_textfield_on_change __cogito_textfield_on_change\n"
"#define cogito_textview_set_text __cogito_textview_set_text\n"
"#define cogito_textview_get_text __cogito_textview_get_text\n"
"#define cogito_textview_on_change __cogito_textview_on_change\n"
"#define cogito_datepicker_on_change __cogito_datepicker_on_change\n"
"#define cogito_dropdown_set_items __cogito_dropdown_set_items\n"
"#define cogito_dropdown_set_selected __cogito_dropdown_set_selected\n"
"#define cogito_dropdown_get_selected __cogito_dropdown_get_selected\n"
"#define cogito_dropdown_on_change __cogito_dropdown_on_change\n"
"#define cogito_slider_set_value __cogito_slider_set_value\n"
"#define cogito_slider_get_value __cogito_slider_get_value\n"
"#define cogito_slider_set_size __cogito_slider_set_size\n"
"#define cogito_slider_get_size __cogito_slider_get_size\n"
"#define cogito_slider_set_icon __cogito_slider_set_icon\n"
"#define cogito_slider_set_centered __cogito_slider_set_centered\n"
"#define cogito_slider_get_centered __cogito_slider_get_centered\n"
"#define cogito_slider_set_range __cogito_slider_set_range\n"
"#define cogito_slider_set_range_start __cogito_slider_set_range_start\n"
"#define cogito_slider_set_range_end __cogito_slider_set_range_end\n"
"#define cogito_slider_get_range_start __cogito_slider_get_range_start\n"
"#define cogito_slider_get_range_end __cogito_slider_get_range_end\n"
"#define cogito_slider_on_change __cogito_slider_on_change\n"
"#define cogito_colorpicker_on_change __cogito_colorpicker_on_change\n"
"#define cogito_tabs_set_items __cogito_tabs_set_items\n"
"#define cogito_tabs_set_ids __cogito_tabs_set_ids\n"
"#define cogito_tabs_set_selected __cogito_tabs_set_selected\n"
"#define cogito_tabs_get_selected __cogito_tabs_get_selected\n"
"#define cogito_tabs_on_change __cogito_tabs_on_change\n"
"#define cogito_tabs_bind __cogito_tabs_bind\n"
"#define cogito_nav_rail_set_items __cogito_nav_rail_set_items\n"
"#define cogito_nav_rail_set_badges __cogito_nav_rail_set_badges\n"
"#define cogito_nav_rail_set_toggle __cogito_nav_rail_set_toggle\n"
"#define cogito_nav_rail_set_selected __cogito_nav_rail_set_selected\n"
"#define cogito_nav_rail_get_selected __cogito_nav_rail_get_selected\n"
"#define cogito_nav_rail_on_change __cogito_nav_rail_on_change\n"
"#define cogito_bottom_nav_set_items __cogito_bottom_nav_set_items\n"
"#define cogito_bottom_nav_set_selected __cogito_bottom_nav_set_selected\n"
"#define cogito_bottom_nav_get_selected __cogito_bottom_nav_get_selected\n"
"#define cogito_bottom_nav_on_change __cogito_bottom_nav_on_change\n"
"#define cogito_progress_set_value __cogito_progress_set_value\n"
"#define cogito_progress_get_value __cogito_progress_get_value\n"
"#define cogito_progress_set_indeterminate __cogito_progress_set_indeterminate\n"
"#define cogito_progress_get_indeterminate __cogito_progress_get_indeterminate\n"
"#define cogito_progress_set_thickness __cogito_progress_set_thickness\n"
"#define cogito_progress_get_thickness __cogito_progress_get_thickness\n"
"#define cogito_progress_set_wavy __cogito_progress_set_wavy\n"
"#define cogito_progress_get_wavy __cogito_progress_get_wavy\n"
"#define cogito_progress_set_circular __cogito_progress_set_circular\n"
"#define cogito_progress_get_circular __cogito_progress_get_circular\n"
"#define cogito_toast_set_text __cogito_toast_set_text\n"
"#define cogito_toast_on_click __cogito_toast_on_click\n"
"#define cogito_toast_set_action __cogito_toast_set_action\n"
"#define cogito_window_set_autosize __cogito_window_set_autosize\n"
"#define cogito_window_set_resizable __cogito_window_set_resizable\n"
"#define cogito_window_set_dialog __cogito_window_set_dialog\n"
"#define cogito_window_clear_dialog __cogito_window_clear_dialog\n"
"#define cogito_node_window_val __cogito_node_window\n"
"#define cogito_find_parent __cogito_find_parent\n"
"#define cogito_find_children __cogito_find_children\n"
"#define cogito_build __cogito_build\n"
"#define cogito_window_set_builder __cogito_window_set_builder\n"
"#define cogito_state_new __cogito_state_new\n"
"#define cogito_state_get __cogito_state_get\n"
"#define cogito_state_set __cogito_state_set\n"
"#define cogito_button_set_text __cogito_button_set_text\n"
"#define cogito_button_set_size __cogito_button_set_size\n"
"#define cogito_button_get_size __cogito_button_get_size\n"
"#define cogito_image_set_icon __cogito_image_set_icon\n"
"#define cogito_image_set_size __cogito_image_set_size\n"
"#define cogito_image_set_radius __cogito_image_set_radius\n"
"#define cogito_checkbox_set_checked __cogito_checkbox_set_checked\n"
"#define cogito_checkbox_get_checked __cogito_checkbox_get_checked\n"
"#define cogito_switch_set_checked __cogito_switch_set_checked\n"
"#define cogito_switch_get_checked __cogito_switch_get_checked\n"
"#define cogito_checkbox_on_change __cogito_checkbox_on_change\n"
"#define cogito_switch_on_change __cogito_switch_on_change\n"
"#define cogito_list_on_select __cogito_list_on_select\n"
"#define cogito_list_on_activate __cogito_list_on_activate\n"
"#define cogito_grid_on_select __cogito_grid_on_select\n"
"#define cogito_grid_on_activate __cogito_grid_on_activate\n"
"// Forward declare FFI functions with ErgoVal signature\n"
"void __cogito_button_on_click(ErgoVal btn, ErgoVal handler);\n"
"#define cogito_button_on_click __cogito_button_on_click\n"
"#define cogito_button_add_menu __cogito_button_add_menu\n"
"#define cogito_iconbtn_add_menu __cogito_iconbtn_add_menu\n"
"#define cogito_iconbtn_set_shape __cogito_iconbtn_set_shape\n"
"#define cogito_iconbtn_get_shape __cogito_iconbtn_get_shape\n"
"#define cogito_iconbtn_set_color_style __cogito_iconbtn_set_color_style\n"
"#define cogito_iconbtn_get_color_style __cogito_iconbtn_get_color_style\n"
"#define cogito_iconbtn_set_width __cogito_iconbtn_set_width\n"
"#define cogito_iconbtn_get_width __cogito_iconbtn_get_width\n"
"#define cogito_iconbtn_set_toggle __cogito_iconbtn_set_toggle\n"
"#define cogito_iconbtn_get_toggle __cogito_iconbtn_get_toggle\n"
"#define cogito_iconbtn_set_checked __cogito_iconbtn_set_checked\n"
"#define cogito_iconbtn_get_checked __cogito_iconbtn_get_checked\n"
"#define cogito_fab_set_extended __cogito_fab_set_extended\n"
"#define cogito_fab_on_click __cogito_fab_on_click\n"
"#define cogito_chip_new __cogito_chip\n"
"#define cogito_chip_set_selected __cogito_chip_set_selected\n"
"#define cogito_chip_get_selected __cogito_chip_get_selected\n"
"#define cogito_chip_set_closable __cogito_chip_set_closable\n"
"#define cogito_chip_on_click __cogito_chip_on_click\n"
"#define cogito_chip_on_close __cogito_chip_on_close\n"
"#define cogito_divider_new __cogito_divider\n"
"#define cogito_card_new __cogito_card\n"
"#define cogito_avatar_new __cogito_avatar\n"
"#define cogito_avatar_set_image __cogito_avatar_set_image\n"
"#define cogito_badge_new __cogito_badge\n"
"#define cogito_badge_set_count __cogito_badge_set_count\n"
"#define cogito_badge_get_count __cogito_badge_get_count\n"
"#define cogito_banner_new __cogito_banner\n"
"#define cogito_banner_set_action __cogito_banner_set_action\n"
"#define cogito_banner_set_icon __cogito_banner_set_icon\n"
"#define cogito_bottom_sheet_new __cogito_bottom_sheet\n"
"#define cogito_timepicker_new __cogito_timepicker\n"
"#define cogito_timepicker_on_change __cogito_timepicker_on_change\n"
"#define cogito_timepicker_get_hour __cogito_timepicker_get_hour\n"
"#define cogito_timepicker_get_minute __cogito_timepicker_get_minute\n"
"#define cogito_timepicker_set_time __cogito_timepicker_set_time\n"
"#define cogito_appbar_add_button __cogito_appbar_add_button\n"
"#define cogito_appbar_set_controls __cogito_appbar_set_controls\n"
"#define cogito_appbar_set_title __cogito_appbar_set_title\n"
"#define cogito_appbar_set_subtitle __cogito_appbar_set_subtitle\n"
"#define cogito_iconbtn_add_menu __cogito_iconbtn_add_menu\n"
"#define cogito_run __cogito_run\n"
"#define cogito_load_sum __cogito_load_sum\n"
"#define cogito_set_script_dir __cogito_set_script_dir\n"
"#define cogito_active_indicator_new __cogito_active_indicator\n"
"#define cogito_switchbar_new __cogito_switchbar\n"
"#define cogito_switchbar_get_checked __cogito_switchbar_get_checked\n"
"#define cogito_switchbar_set_checked __cogito_switchbar_set_checked\n"
"#define cogito_switchbar_on_change __cogito_switchbar_on_change\n"
"#define cogito_content_list_new __cogito_content_list\n"
"#define cogito_empty_page_new __cogito_empty_page\n"
"#define cogito_empty_page_set_description __cogito_empty_page_set_description\n"
"#define cogito_empty_page_set_icon __cogito_empty_page_set_icon\n"
"#define cogito_empty_page_set_action __cogito_empty_page_set_action\n"
"#define cogito_tip_view_new __cogito_tip_view\n"
"#define cogito_tip_view_set_title __cogito_tip_view_set_title\n"
"#define cogito_settings_window_new __cogito_settings_window\n"
"#define cogito_settings_page_new __cogito_settings_page\n"
"#define cogito_settings_list_new __cogito_settings_list\n"
"#define cogito_settings_row_new __cogito_settings_row\n"
"#define cogito_welcome_screen_new __cogito_welcome_screen\n"
"#define cogito_welcome_screen_set_description __cogito_welcome_screen_set_description\n"
"#define cogito_welcome_screen_set_icon __cogito_welcome_screen_set_icon\n"
"#define cogito_welcome_screen_set_action __cogito_welcome_screen_set_action\n"
"#define cogito_view_dual_new __cogito_view_dual\n"
"#define cogito_view_dual_set_ratio __cogito_view_dual_set_ratio\n"
"#define cogito_view_chooser_new __cogito_view_chooser\n"
"#define cogito_view_chooser_set_items __cogito_view_chooser_set_items\n"
"#define cogito_view_chooser_bind __cogito_view_chooser_bind\n"
"#define cogito_about_window_new __cogito_about_window\n"
"#define cogito_about_window_set_icon __cogito_about_window_set_icon\n"
"#define cogito_about_window_set_description __cogito_about_window_set_description\n"
"#define cogito_about_window_set_website __cogito_about_window_set_website\n"
"#define cogito_about_window_set_issue_url __cogito_about_window_set_issue_url\n"
"#define cogito_menu_button_new __cogito_menu_button\n"
"#define cogito_split_button_new __cogito_split_button\n"
"#define cogito_split_button_add_menu __cogito_split_button_add_menu\n"
"// cogito_set_script_dir is provided by the cogito library\n"
"\n"
;
static const unsigned int ergo_runtime_embedded_len = (unsigned int)(sizeof(ergo_runtime_embedded) - 1);

#endif
