cask main

bring stdr
bring cogito

macro with_ext(ext = string) (( string )) {
    @"$this$ext"
}

def editor = cogito.textview(@"")
def bar = cogito.appbar(@"Untitled.txt", @"Ready")
def ?title_text = @"Untitled.txt"
def ?subtitle_text = @"Ready"
def ?current_path = @""
def ?suspend_dirty = false
def ?is_dirty = false
def ABOUT_MORE_INFO_URL = @"https://github.com/lainsce/ergo"
def ABOUT_REPORT_BUG_URL = @"https://github.com/lainsce/ergo/issues"

fun is_txt_path(path = string) (( bool )) {
    let n = len(path)
    if n < 4 || path[n - 4] != @"." {
        return false
    }
    let c1 = path[n - 3]
    let c2 = path[n - 2]
    let c3 = path[n - 1]
    -- .txt or .TXT (retro)
    return (c1 == @"t" || c1 == @"T") &&
           (c2 == @"x" || c2 == @"X") &&
           (c3 == @"t" || c3 == @"T")
}

fun basename(path = string) (( string )) {
    let n = len(path)
    let ?last_sep = -1
    for (let ?i = 0; i < n; i += 1) {
        let ch = path[i]
        if ch == @"/" || ch == @"\\" {
            last_sep = i
        }
    }
    if last_sep < 0 {
        return path
    }

    let ?name = @""
    for (let ?i = last_sep + 1; i < n; i += 1) {
        name = @"$name$path[i]"
    }
    return name
}

fun set_status(text = string) (( -- )) {
    subtitle_text = text
    bar.set_subtitle(subtitle_text)
}

fun refresh_header() (( -- )) {
    let name = if current_path != @"" { basename(current_path) } else { @"Untitled.txt" }
    title_text = if is_dirty { @"$name *" } else { name }
    bar.set_title(title_text)
}

fun set_editor_text(text = string) (( -- )) {
    suspend_dirty = true
    editor.set_text(text)
    suspend_dirty = false
}

fun new_document() (( -- )) {
    set_editor_text(@"")
    current_path = @""
    is_dirty = false
    refresh_header()
    set_status(@"New document")
}

fun default_save_name() (( string )) {
    return if current_path == @"" { @"Untitled.txt" } else { current_path }
}

fun show_open_dialog() (( -- )) {
    let picked = stdr.open_file_dialog(@"Open .txt", @"txt")
    if is_null(picked) {
        set_status(@"Open canceled")
        return
    }
    let path = str(picked)
    let text = stdr.read_text_file(path)
    if !is_txt_path(path) {
        set_status(@"Open failed: choose a .txt file")
    } elif is_null(text) {
        set_status(@"Open failed: cannot read file")
    } else {
        set_editor_text(str(text))
        current_path = path
        is_dirty = false
        refresh_header()
        set_status(@"Opened $basename(path)")
    }
}

fun show_save_dialog() (( -- )) {
    let picked = stdr.save_file_dialog(@"Save As .txt", default_save_name(), @"txt")
    if is_null(picked) {
        set_status(@"Save canceled")
        return
    }

    let ?path = str(picked)
    if !is_txt_path(path) {
        path = path !with_ext @".txt"
    }

    let ok = stdr.write_text_file(path, editor.text())
    if !ok {
        set_status(@"Save failed: cannot write file")
    } else {
        current_path = path
        is_dirty = false
        refresh_header()
        set_status(@"Saved $basename(path)")
    }
}

fun show_about_window(win = cogito.Window) (( -- )) {
    let dlg = cogito.dialog(@"")

    let aw = cogito.about_window(@"Ergo Text Editor", @"MIT License")
    .set_icon(@"sf:doc.text")
    .set_website(ABOUT_MORE_INFO_URL)
    .set_issue_url(ABOUT_REPORT_BUG_URL)

    dlg.add(aw)
    win.set_dialog(dlg)
}

entry() (( -- )) {
    let app = cogito.app()
    .set_appid(@"ergo.cogito.TextEditor")
    .set_app_name(@"ErgoText")
    .set_accent_color(@"#4838d7", false)

    cogito.load_sum(@"ergotexteditor.sum")

    let win = cogito.window_size(@"ErgoText", 900, 640)
    .set_autosize(false)
    .set_resizable(true)

    let root = cogito.vstack()
    .set_gap(0)
    .set_hexpand(true)
    .set_vexpand(true)

    title_text = @"Untitled.txt"
    subtitle_text = @"Ready"
    bar.set_title(title_text)
    bar.set_subtitle(subtitle_text)
    bar.set_hexpand(true)

    let file_btn = bar.add_button(@"sf:gearshape", (b = cogito.Button) => {
    })
    file_btn.add_menu(@"New", (b = any) => {
        new_document()
    })
    file_btn.add_menu(@"Open…", (b = any) => {
        show_open_dialog()
    })
    file_btn.add_menu(@"Save As…", (b = any) => {
        show_save_dialog()
    })

    let about_btn = bar.add_button(@"sf:questionmark", (b = cogito.Button) => {
        show_about_window(win)
    })

    root.add(bar)

    editor.set_hexpand(true)
    .set_vexpand(true)
    .on_change((tv = cogito.TextView) => {
        if !suspend_dirty {
            is_dirty = true
            refresh_header()
            if current_path == @"" {
                set_status(@"Editing unsaved document")
            } else {
                set_status(@"Modified document")
            }
        }
    })
    root.add(editor)

    refresh_header()

    win.add(root)
    app.run(win)
}
