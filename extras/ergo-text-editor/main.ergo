bring stdr
bring cogito

def editor = cogito.textview(@"")
def bar = cogito.appbar(@"Untitled.txt", @"Ready")
def ?title_text = @"Untitled.txt"
def ?subtitle_text = @"Ready"
def ?current_path = @""
def ?suspend_dirty = false
def ?is_dirty = false

fun is_txt_path(path = string) (( bool )) {
    let n = len(path)
    if n < 4 || path[n - 4] != @"." {
        return false
    }
    let c1 = path[n - 3]
    let c2 = path[n - 2]
    let c3 = path[n - 1]
    -- .txt or .TXT (retro)
    return (c1 == @"t" || c1 == @"T") &&
           (c2 == @"x" || c2 == @"X") &&
           (c3 == @"t" || c3 == @"T")
}

fun basename(path = string) (( string )) {
    let n = len(path)
    let ?last_sep = -1
    for (let ?i = 0; i < n; i += 1) {
        let ch = path[i]
        if ch == @"/" || ch == @"\\" {
            last_sep = i
        }
    }
    if last_sep < 0 {
        return path
    }

    let ?name = @""
    for (let ?i = last_sep + 1; i < n; i += 1) {
        name = @"$name$path[i]"
    }
    return name
}

fun set_status(text = string) (( -- )) {
    subtitle_text = text
    bar.set_subtitle(subtitle_text)
}

fun refresh_header() (( -- )) {
    let name = if current_path != @"" { basename(current_path) } else { @"Untitled.txt" }
    title_text = if is_dirty { @"$name *" } else { name }
    bar.set_title(title_text)
}

fun set_editor_text(text = string) (( -- )) {
    suspend_dirty = true
    editor.set_text(text)
    suspend_dirty = false
}

fun new_document() (( -- )) {
    set_editor_text(@"")
    current_path = @""
    is_dirty = false
    refresh_header()
    set_status(@"New document")
}

fun default_save_name() (( string )) {
    return if current_path == @"" { @"Untitled.txt" } else { current_path }
}

fun show_open_dialog() (( -- )) {
    let picked = stdr.open_file_dialog(@"Open .txt", @"txt")
    if is_null(picked) {
        set_status(@"Open canceled")
        return
    }
    let path = str(picked)
    let text = stdr.read_text_file(path)
    let shown = basename(path)
    if !is_txt_path(path) {
        set_status(@"Open failed: choose a .txt file")
    } elif is_null(text) {
        set_status(@"Open failed: cannot read file")
    } else {
        set_editor_text(str(text))
        current_path = path
        is_dirty = false
        refresh_header()
        set_status(@"Opened $shown")
    }
}

fun show_save_dialog() (( -- )) {
    let picked = stdr.save_file_dialog(@"Save As .txt", default_save_name(), @"txt")
    if is_null(picked) {
        set_status(@"Save canceled")
        return
    }

    let ?path = str(picked)
    if !is_txt_path(path) {
        path = @"$path.txt"
    }
    let shown = basename(path)

    let ok = stdr.write_text_file(path, editor.text())
    if !ok {
        set_status(@"Save failed: cannot write file")
    } else {
        current_path = path
        is_dirty = false
        refresh_header()
        set_status(@"Saved $shown")
    }
}

entry() (( -- )) {
    let app = cogito.app()
    app.set_appid(@"org.ergo.texteditor")
    app.set_app_name(@"Ergo Text Editor")
    app.set_accent_color(@"#7A6EE6", false)

    cogito.load_sum(@"ergotexteditor.sum")

    let win = cogito.window_size(@"Ergo Text Editor", 900, 640)
    win.set_autosize(false)
    win.set_resizable(true)

    let root = cogito.vstack()
    root.set_gap(0)
    root.set_hexpand(true)
    root.set_vexpand(true)

    title_text = @"Untitled.txt"
    subtitle_text = @"Ready"
    bar.set_title(title_text)
    bar.set_subtitle(subtitle_text)
    bar.set_hexpand(true)

    let new_btn = bar.add_button(@"sf:doc.badge.plus", (b = cogito.Button) => {
        new_document()
    })
    cogito.set_tooltip(new_btn, @"New")

    let open_btn = bar.add_button(@"sf:folder", (b = cogito.Button) => {
        show_open_dialog()
    })
    cogito.set_tooltip(open_btn, @"Open .txt")

    let save_btn = bar.add_button(@"sf:square.and.arrow.down", (b = cogito.Button) => {
        show_save_dialog()
    })
    cogito.set_tooltip(save_btn, @"Save As .txt")

    root.add(bar)

    editor.set_hexpand(true)
    editor.set_vexpand(true)
    editor.on_change((tv = cogito.TextView) => {
        if !suspend_dirty {
            is_dirty = true
            refresh_header()
            if current_path == @"" {
                set_status(@"Editing unsaved document")
            } else {
                set_status(@"Modified document")
            }
        }
    })
    root.add(editor)

    refresh_header()

    win.add(root)
    app.run(win)
}
